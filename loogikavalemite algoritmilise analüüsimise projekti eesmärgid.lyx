#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
väidete algoritmilise analüüsimise 
\begin_inset Quotes eld
\end_inset

projekti
\begin_inset Quotes erd
\end_inset

 eesmärgid
\end_layout

\begin_layout Author
Olger Männik
\end_layout

\begin_layout Part
Sissejuhatus
\end_layout

\begin_layout Standard
Selles failis on kirjeldatud ainult projekti eesmärgid.
 Mul on rohkem faile, kus on eesmärkide saavutamist alustatud ja sellega
 üsna kaugele jõutud.
\end_layout

\begin_layout Paragraph
sõna 
\begin_inset Quotes eld
\end_inset

väide
\begin_inset Quotes erd
\end_inset

 lahtiseletus:
\end_layout

\begin_layout Standard
Sõna väide on selles failis formaalloogika tähenduses, aga see on väga sarnane
 selle sõna tavakeelsele tähendusele, ehk see on miski, mille tõele vastamisest
 järeldub mingi tõsiasi.
 Selles failis kasutan väidete kirja panemiseks kindlat syntaxit, kus väiteid
 kirjeldavad tekstilõigud võivad sisaldada boolean-operaatoreid, kvantoreid
 ja predikaate(või elementaarseoseid või algasju predikaatide asemel).
\end_layout

\begin_layout Paragraph
eesmärgid
\end_layout

\begin_layout Standard
Eesmärk on koostada algoritm ja implementeerida see arvutiprogrammina, mille
 abil saaks väiteid minimaalsel vabadusastmel salvestada.
 Minimaalsel vabadusastmel salvestatud väiteid saaks kergesti analüüsida.
 Kasutaja sisestaks väited kergesti loetavas syntaxis(seda on kirjeldatud
 peatükis 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:süntax"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Seda saaks kasutada näiteks kõige üldisemate matemaatiliste probeemide
 (mis võivad olla võrranditena esitatud) lihtsustamiseks, lahendamiseks
 ja lahendite kontrollimiseks.
 
\end_layout

\begin_layout Standard
Kuna iga väide on salvestatud minimaalsel vabadusastmel, siis saab lihtsasti
 kontrollida, et kas see on üheselt vale, üheselt tõene või mitte kumbagi,
 sest kõigile üheselt valedele ja üheselt tõestele väidetele vastab sama
 arv.
 Tõenäoliselt ongi praktilisel kasutamisel kõige olulisem küsimus, et kas
 väide vormis 
\begin_inset ERT
status open

\begin_layout Plain Layout

$aksioomid 
\backslash
to vaide$
\end_layout

\end_inset

 on üheselt vale, üheselt õige või mitte kumbagi (
\begin_inset ERT
status open

\begin_layout Plain Layout

$programm(aksioomid 
\backslash
to vaide)$
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Kui väidete minimaalsel vabadusastmel salvestamine on võimatu, sellise algoritmi
 koostamine liiga raske, algoritm ajaliselt liiga keerukas et seda praktiliselt
 kasutada saaks või algoritm liiga palju mälu nõudev et seda praktiliselt
 kasutada saaks, siis on alternatiivseks eesmärgiks teha algoritmi, mis
 määrab, et kas sisendiks antud väide on vastuoluline või mitte ilma seda
 väidet minimaalsel vabadusastmel salvestamata ning implementeerida see
 algoritm arvutiprogrammina.
\end_layout

\begin_layout Standard
Kui ka sellise programmi tegemine pole võimalik (mõned inimesed on väitnus,
 et see pole kas Gödeli 2.
 ebatäielikkuse teoreemi või predikaatarvutuse mittelahenduvuse teoreemi
 kohaselt võimalik), siis on järgmiseks alternatiivseks eesmärgiks teha
 programm, mis piiramatult jätkab kontrollimist, et kas mingi väide on vastuolul
ine või mitte.
 Kuigi see programm ei pruugiks iga sisendi puhul tagastada, et kas sisendiks
 antud väide on kindlasti vastuoluline või see kindalsti ei ole vastuoluline(on
 kooskõlaline), tagastaks see, et peale kui mitut tsüklit ei leidnud see
 algoritm, et väide on vastuoluline.
\end_layout

\begin_layout Standard
Hea oleks käsitleda minimaalsel vabadusastmel kirjeldatud väiteid naturaalarvude
na.
 Tähistan naturaalarvu, mis kirjeldab väidet 
\begin_inset ERT
status open

\begin_layout Plain Layout

$S$
\end_layout

\end_inset

 tähisega 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

.
 Selleks tuleb defineerida bijektiivne vastavus võimalike väidete(võimalik
 vist ainult kindlas notatsioonis olevate väidete korral) ja naturaalarvude
 vahele.
 Juhul kui selline vastavus defineerimine on võimalik, on võimalik defineerida
 lõpmatult erinevaid selliseid vastavusi.
 Tähistan funktsiooni, mis seab väite 
\begin_inset ERT
status open

\begin_layout Plain Layout

$S$
\end_layout

\end_inset

 vastavusse naturaalarvuga 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

$F$
\end_layout

\end_inset

'iga.
 Seega 
\begin_inset ERT
status open

\begin_layout Plain Layout

$F(S)=n_S$
\end_layout

\end_inset

.
 Selle pöördfunktsiooni tähistan 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f$
\end_layout

\end_inset

'iga.
 Seega 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f(n_S)=S$
\end_layout

\end_inset

.
 Järgnevalt loetlen omadusi, mis vastavusel (ja funktsioonil 
\begin_inset ERT
status open

\begin_layout Plain Layout

$F$
\end_layout

\end_inset

) võiks olla, et sellisel kujul olevat väidet praktikas mugav kasutada oleks:
\end_layout

\begin_layout Itemize
Hea on kui sellisel kujul estitatud väidete vahelisi loogikatehteid (näiteks
 AND, NAND, OR, NOR ja XOR) saab kergesti arvutada rakendades väiteid kirjeldava
tele naturaalarvudele (
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

) loogikatehele vastavaid lihtsasti arvutatavaid funktsioone.
\end_layout

\begin_layout Itemize
Hea on kui tavalises notatsioonis lühidalt kirjapandav väide on ka väikese
 või lihtsasti kirjeldatava naturaalarvuga vastavusse pandud.
\end_layout

\begin_layout Itemize
Hea on kui Falsele(kõigile üheselt valedele väidetele) vastab 0.
\end_layout

\begin_layout Itemize
Hea on kui Truele(kõigile üheselt tõestele väidetele) vastab 1.
\end_layout

\begin_layout Standard
lühemad eesmärgid prioriteetsuse järjekorras:
\end_layout

\begin_layout Enumerate
koostada algoritm, mis võtaks sisendiks väite ja tagastaks, et kas see on
 vastuoluline või mitte.
\end_layout

\begin_layout Enumerate
implementeerida see algoritm arvutiprogrammina.
\end_layout

\begin_layout Enumerate
koostada oma süntax , mida see programm sisendiks võtab, väidete mugavamaks
 kirjapanemiseks.
\end_layout

\begin_layout Enumerate
lisada pogrammile funktsionaalsus, väitedete salvestamiseks, kujul, mis
 on: Minimaalse vabadusastmete arvuga ehk mistahes 2 erinevat bittide kombinatsi
ooni (kui see on binaarkujul esitatud) tähistavad erinevaid loogikalisi
 lauseid ja universaalne ehk millega saab mingi bittide kombinatsiooniga
 (kui see on binaarkujul esitatud) iga loogikalise lause kirja panna.
 Teisisõnu funktsioon väite ja tähistuse vahel on bijektiivne.
\end_layout

\begin_layout Enumerate
lisada programmile funktsionaalsus esitada väiteid standardsel ja kergesti
 loetaval kujul.
\end_layout

\begin_layout Enumerate
lisada programmile funktsionaalsus hinnata väite keerukust mingi parameetriga.
\end_layout

\begin_layout Enumerate
lisada programmile funktsionaalsus määrata väite parameeter K, ehk ,et kui
 mitme kvantori sees kõige rohkemate kvantorite sees asuv kvantor on ,kui
 väide on esitatud vormis, kus kõige rohkemate kvantorite sees asuv kvantor
 on võimalikult väheste kvantorite sees.
\end_layout

\begin_layout Quote
Minu teada sama asja tegevat programmi ei ole veel tehtud.
 Sarnasemad programmid on Prolog ja Julog.jl , aga ned ei suuda nii üldiseid
 ja keerukaid ülesandeid lahendada kui programm, mida mina teha tahan suudaks,
 ning nende syntax on ebamugavam.
 Näiteks Wolfram ei oska lahendada lihtsamaidki sarnaseid ülesanded.
 Sisend 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_x(
\backslash
exists_y(A(x,y)))
\backslash
land 
\backslash
neg 
\backslash
exists_x(
\backslash
exists_y(A(y,x)))$
\end_layout

\end_inset

, mille peale minu programm peaks tagastama, et see on vastuoluline on Wolframi
 syntaxis 
\begin_inset Quotes eld
\end_inset

Exists[x,Exists[y,A[x,y]]]&& !Exists[x,Exists[y,A[y,x]]]
\begin_inset Quotes erd
\end_inset

, aga wolfram ei saa aru, et see on vastuoluline.
 Olen teinud isegi ühe foorumi postituse Wolframi foorumisee, kus inimesed
 kinnitasid, et Wolfram ei suuda selliseid ülesandeid lahendada.
 Selle postituse URL on https://community.wolfram.com/groups/-/m/t/2416379
 .
\end_layout

\begin_layout Section
Näited programmi kasutamisest
\end_layout

\begin_layout Subsection
lihtsamad näited
\end_layout

\begin_layout Standard
Järgnevates näidetes on kasutatud peatükis 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:kvanteeritavate-nimede-sugar"
plural "false"
caps "false"
noprefix "false"

\end_inset

 kirjeldatud syntaxsugarit.
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide on üheselt vale (lühendatult
 
\series bold
ÜV
\series default
): 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(A(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists(A(x_1))$
\end_layout

\end_inset

 (sama väide ilma peatükis 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:kvanteeritavate-nimede-sugar"
plural "false"
caps "false"
noprefix "false"

\end_inset

 kirjeldatud syntaxsugarit kasutamata 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(A(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1}(A(x_1))$
\end_layout

\end_inset

), sest on väidetud, et miski, mis rahuldab predikaati A eksisteerib, ning
 samuti on väidetud, et seda ei eksisteeri.
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide pole üheselt vale: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(A(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists(A(x_1)
\backslash
land B(x_1))$
\end_layout

\end_inset

 (sama väide ilma peatükis 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:kvanteeritavate-nimede-sugar"
plural "false"
caps "false"
noprefix "false"

\end_inset

 kirjeldatud syntaxsugarit kasutamata 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(A(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1}(A(x_1)
\backslash
land B(x_1))$
\end_layout

\end_inset

), sest on väidetud, et eksisteerib miski, mis rahuldab predikaati A, aga
 ei eksisteeri midagi, mis rahuldaks nii predikaati A kui ka predikaati
 B ning vastuolu ei ole.
 Sellest on lihtsam aru saada kui panna predikaatidele mingid intuitiivselt
 lihtsamini mõistetavad nimed.
 nt.: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_loom(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists(on
\backslash
_loom(x_1)
\backslash
land on
\backslash
_auto(x_1))$
\end_layout

\end_inset

.
 Ehk on väidetud, et eksisteerib mingi asi, mis on loom(eksisteerib mingi
 loom), aga ei eksisteeri midagi, mis oleks nii loom kui ka auto.
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide on üheselt vale: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(A(x_1)
\backslash
land B(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists(A(x_1))$
\end_layout

\end_inset

, sest on väidetud, et eksisteerib miski, mis rahuldab nii predikaati A
 kui ka predikaati B, aga ei eksisteeri midagi, mis rahuldaks predikaati
 A.
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide on üheselt vale: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
exists(A(x_1,x_2)
\backslash
land 
\backslash
exists(A(x_2,x_3)
\backslash
land A(x_2,x_2))))
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
exists(
\backslash
exists( A(x_2,x_1)
\backslash
land A(x_1,x_3)
\backslash
land A(x_1,x_1))))$
\end_layout

\end_inset

,sest on väidetud, et eksisteerib miski (
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_2$
\end_layout

\end_inset

), mis rahuldab millegagi predikaati A olles ise 2.
 argument, rahuldab millegi muuga predikaati A, olles ise 1.
 argument ja rahuldab predikaati A olles selle mõlemaks argumendiks ning
 väite teises osas on väidetud, et selliste omadustega asja just ei eksisteeri.
\end_layout

\begin_layout Standard
Eelnevalt näiteks toodud väidete vastuolulisust on kerge intuitiivselt,
 ilma arvuti abita kontrollida, aga pikkade ja keerukate väidete vastuolulisust
 on niimoodi väga raske kontrollida.
 Selliste valemita analüüsimiseks olekski see programm kasulik.
 Järgnevalt toon mõned näited keerukamatest väidetest, mille vastuolulisust
 on raske kontrollida:
\end_layout

\begin_layout Itemize
järgneva väite korral programm tagastab, et väide ei ole üheselt vale: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_mari(x_1) 
\backslash
land  
\backslash
neg
\backslash
exists(M(x_1, x_2) 
\backslash
land  
\backslash
exists(M(x_1, x_3) 
\backslash
land  
\backslash
neg M(x_2, x_3) 
\backslash
land  M(x_3, x_1)) 
\backslash
land  
\backslash
exists(M(x_1, x_3) 
\backslash
land  M(x_2, x_3)) 
\backslash
land  
\backslash
neg 
\backslash
exists(M(x_2, x_3) 
\backslash
land  M(x_3, x_3))))
\backslash
land             
\backslash
exists(
\backslash
exists(on
\backslash
_mari(x_2)
\backslash
land M(x_2,x_1)
\backslash
land 
\backslash
exists(M(x_1,x_3)
\backslash
land M(x_2,x_3))
\backslash
land 
\backslash
exists(M(x_2,x_3)
\backslash
land M(x_3,x_2)
\backslash
land 
\backslash
neg M(x_1,x_3)))
\backslash
land 
\backslash
neg 
\backslash
exists(M(x_2,x_1)
\backslash
land M(x_2,x_2)))
\backslash
lor
\backslash
exists(M(x_1,x_1)
\backslash
land 
\backslash
neg 
\backslash
exists(M(x_1,x_2)
\backslash
land M(x_2,x_2)
\backslash
land M(x_2,x_1)))$
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Sellest, et vastuolu pole, on lihtsam aru saada kui panna predikaatidele
 intuitiivselt lihtsamini mõistetavamad nimed.
 nt.:predikaat M on 
\begin_inset Quotes eld
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1$
\end_layout

\end_inset

'le meeldib 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_2$
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, ehk kui 
\begin_inset ERT
status open

\begin_layout Plain Layout

$M(x_1,x_2)$
\end_layout

\end_inset

, siis 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1$
\end_layout

\end_inset

 meeldib 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_2$
\end_layout

\end_inset

'le.
 Siis on väidetud , et: [kõigil, kes Marile meeldivad,[ei ole kedagi kes
 Marile meeldiks, aga temale mitte ja kellele meeldiks Mari] või [ei ole
 kedagi, kes nii talle kui Marile meeldiks] või [on keegi, kes neile meeldib
 ja kes iseendale meeldib]] ja leidub keegi, kes meeldib marile, nii, et
 eksisteerib [keegi, kes meeldib nii marile kui talle] ja [keegi, kes meeldib
 marile, kellele mari meeldib ja kelle ei meeldi talle] ja ei leidu kedagi,
 kes nii iseendale kui ka talle ta meeldiks või [on keegi(x_1) kes endale
 meeldib, aga [kellel pole kedagi kes nii talle kui iseendale meeldiks ja
 kellele meeldiks tema(x_1)]].
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide on üheselt vale:
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(A(x_1,x_1)
\backslash
land 
\backslash
exists(A(x_2,x_2) 
\backslash
land A(x_2,x_1) 
\backslash
land A(x_1,x_2)) 
\backslash
land 
\backslash
exists(
\backslash
neg A(x_2,x_2) 
\backslash
land 
\backslash
neg A(x_1,x_2) 
\backslash
land A(x_2,x_1) 
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
neg A(x_3,x_3) 
\backslash
land 
\backslash
neg A(x_3,x_2) 
\backslash
land A(x_3,x_1) 
\backslash
land A(x_2,x_3) 
\backslash
land A(x_1,x_3))))
\backslash
land
\end_layout

\begin_layout Plain Layout


\backslash
neg 
\backslash
exists(
\backslash
exists(
\backslash
exists(
\backslash
neg A(x_1,x_1)
\backslash
land 
\backslash
neg A(x_1,x_2)
\backslash
land 
\backslash
neg A(x_2,x_1)
\backslash
land 
\backslash
neg A(x_2,x_2)
\backslash
land 
\backslash
neg A(x_3,x_1)
\backslash
land 
\backslash
neg A(x_3,x_2)
\backslash
land 
\backslash
neg A(x_3,x_3)
\backslash
land 
\backslash
neg A(x_1,x_3)
\backslash
land 
\backslash
neg A(x_2,x_3)))
\backslash
lor A(x_1,x_1) 
\backslash
land 
\backslash
exists(A(x_2,x_2) 
\backslash
land 
\backslash
neg A(x_2,x_1) 
\backslash
land A(x_1,x_2) 
\backslash
neg 
\backslash
exists(
\backslash
neg A(x_3,x_3) 
\backslash
land A(x_3,x_2) 
\backslash
neg 
\backslash
land A(x_3,x_1) 
\backslash
land A(x_2,x_3) 
\backslash
land A(x_1,x_3)) ))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Siin on toodud mõned väited, mille üheselt valesust saaks minu programmiga
 kontrollida, aga mille vastuolulisuse kontrollimiseks on vaja kasutada
 matemaatiliste tehte märkide tähendusi kirjeldavaid väiteid ja arvude kohta
 käivaid aksioome.
 Programmi kasutaja ei peaks neid käsitsi sisestama vaid saaks need standard
 libarist võtta.
 Standard libariks olevat väidet tähistan siinkohal nimega STANDARD.
 Samuti on selleks vaja kasutada mõndasid syntax-sugareid.
\end_layout

\begin_layout Standard
mitte ÜV: 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists(x_1+3=7 
\backslash
land on
\backslash
_reaalarv(x_1))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists(0*x_1=3 
\backslash
land on
\backslash
_reaalarv(x_1))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists((on
\backslash
_naturaalarv(x_1) 
\backslash
to x_1>x_1) 
\backslash
lor x_1=x_1+1)$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists(on
\backslash
_reaalarv(x_1)
\backslash
land 
\backslash
exists(x_1+x_2=23
\backslash
land x_1+2*x_2=37 
\backslash
land x_1<53 
\backslash
land x_1*x_2<200 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists (
\backslash
neg 
\backslash
exists (x_1>x_2 
\backslash
land on
\backslash
_reaalarv(x_1) 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

 ei leidu arvu, millest suuremat ei leiduks.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists (
\backslash
exists (x_1>x_2
\backslash
land x_1<x_2 
\backslash
land on
\backslash
_reaalarv(x_1) 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

ei leidu kahte arvu nii, et mõlemad oleksid teisest suuremad.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists (
\backslash
neg 
\backslash
exists (x_1*x_2 
\backslash
not = 0 
\backslash
land on
\backslash
_reaalarv(x_1) 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

Leidub arv(0), nii et ei leiduks arvu, millega seda korrutades ei saaks
 vastuseks nulli.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists (
\backslash
exists (x_1+x_2=9
\backslash
land x_1*x_2=20
\backslash
land x_1>x_2 
\backslash
land on
\backslash
_reaalarv(x_1) 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

 Need arvud on 5 ja 4.
\end_layout

\begin_layout Standard
ÜV:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists(
\backslash
exists({x_1}^3-4*{x_1}^2+6*x_1-24-{x_2}^4+3*x_2=0 
\backslash
land x_2>1))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists(on
\backslash
_reaalarv(x_1)
\backslash
land 
\backslash
neg 
\backslash
exists(x_1<x_2 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

eksiseerib selline reaalarv, nii et ei leidu ühtegi teist reaalarvu, mis
 sellest suurem oleks.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists(on
\backslash
_kompleksarv(x_1)
\backslash
land 
\backslash
exists(x_1<x_2 
\backslash
land on
\backslash
_kompleksarv(x_2) 
\backslash
land x_1^2=x_2^2))$
\end_layout

\end_inset

 ei leidu kahte kompleksarvu, mille ruut oleks sama ja millest esimene oleks
 teisest suurem.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists(on
\backslash
_kompleksarv(x_1)
\backslash
land 
\backslash
exists(on
\backslash
_kompleksarv(x_2) 
\backslash
land 
\backslash
exists(on
\backslash
_kompleksarv(x_3) 
\backslash
land x_1^5=x_2^5 
\backslash
land x_2^5=x_3^5 
\backslash
land x_1 
\backslash
neq x_2 
\backslash
land x_2 
\backslash
neq x_3 
\backslash
land x_1 
\backslash
neq x_3)))$
\end_layout

\end_inset

 ei leidu 3e erinevat kompleksarvu, mille 5 aste oleks sama.
\end_layout

\begin_layout Standard
Saaks kontrollida ka, et kas mingi hüpotees(teoreem) järeldub aksioomidest(ehk
 standard libarist).
 Kui standard libaris on piisavalt palju infot, siis järgneva seose korral
 programm tagastab, et see seos on ÜV, ehk et see hüpotees oli tõene.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg (STANDARD 
\backslash
to 
\backslash
neg 
\backslash
exists(on
\backslash
_naturaalarv(x_1) 
\backslash
land 
\backslash
exists(on
\backslash
_naturaalarv(x_2) 
\backslash
land 
\backslash
exists( on
\backslash
_naturaalarv(x_3) 
\backslash
land 
\backslash
exists(x_1^{x_4}+x_2^{x_4}=x_3^{x_4} 
\backslash
land x_4>2 
\backslash
land on
\backslash
_naturaalarv(x_4))))))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
(sama väide ilma peatükis 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:kvanteeritavate-nimede-sugar"
plural "false"
caps "false"
noprefix "false"

\end_inset

 kirjeldatud syntaxsugarit kasutamata 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg (STANDARD 
\backslash
to 
\backslash
neg 
\backslash
exists_{x_1}(on
\backslash
_naturaalarv(x_1) 
\backslash
land 
\backslash
exists_{x_2}(on
\backslash
_naturaalarv(x_2) 
\backslash
land 
\backslash
exists_{x_3}( on
\backslash
_naturaalarv(x_3) 
\backslash
land 
\backslash
exists_{x_4}(x_1^{x_4}+x_2^{x_4}=x_3^{x_4} 
\backslash
land x_4>2 
\backslash
land on
\backslash
_naturaalarv(x_4))))))$
\end_layout

\end_inset

)
\end_layout

\begin_layout Section
süntax
\begin_inset CommandInset label
LatexCommand label
name "sec:süntax"

\end_inset


\end_layout

\begin_layout Subsection
pythoni moodulina
\end_layout

\begin_layout Standard
Predikaadid ja kvantorid on vastavate klasside objektid.
 Loogikatehted on ka objektid ja lisaks python ülelaaditavad operaatorid.
 On meetodid: __bool__ ja kas_min_nested.
\end_layout

\begin_layout Subsection
eraldi fail
\end_layout

\begin_layout Subsubsection
predikaadid
\end_layout

\begin_layout Standard
Predikaadid on tähistatud kas operaatori-syntaxis või funktsiooni-syntaxis.
\end_layout

\begin_layout Paragraph
operaatorisyntax
\end_layout

\begin_layout Standard
eraldi lõigud, mille vahel on sulgude sees argumendid.
 näiteks 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(aaa(x_1)(x_2)bbb(x_3)ccc)$
\end_layout

\end_inset

 tähendab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$aaa()()bbb()ccc(x_1,x_2,x_3)$
\end_layout

\end_inset

.
 näiteks 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(x_1<x_2)$
\end_layout

\end_inset

 tähendab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$()<()(x_1,x_2)$
\end_layout

\end_inset

.
 Funktsioonisyntaxis ei ole vaja predikaatide lõpus olevaid argumente tühjade
 sulgudega vaja tähistada.
 Näiteks: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$()<()(x_1,x_2)$
\end_layout

\end_inset

 asemel
\begin_inset ERT
status open

\begin_layout Plain Layout

$()<(x_1,x_2)$
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
funktsioonisyntax
\end_layout

\begin_layout Standard
kohtadesse kus operaatori syntaxis oli vahekoht argumendi jaoks on tühjad
 sulud.
 juhul kui see predikaat on jutumärkides on tühjade sulgude asemel argumendikoht
ades kahekordsd jutumärid.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Sama predikaat võib samas väite lähtekoodis nii operaatori kui funktsioonisyntax
is tähistatud olla.
 Kui predikaadi nimi sisaldab sulge peab see predikaat olema jutumärkide
 sees.
 jutumärgid predikaadi nime alguses lõpus või argumendi kohtade kõrval tähistada
 tagurpidi kaldkriipsuga(nagu pythoni syntaxis.).
\end_layout

\begin_layout Standard
Kõik mis pole loogikatehted, sulud ega kvantorid tõlgendada predikaatidena(2
 argumendilise puhul nagu operaatori syntax.).
 
\end_layout

\begin_layout Standard
Kõik 16(10) funktsiooni 2 booleanist ühte booleani sisseehitatud operaatoritena
 või olemas mingi funktsionaalselt täielik hulk neid ja kasutaja saab ise
 ülejäänud defineerida.
 Samuti oleks siis 1 kvantor a kasutaja ise saaaks teis defineerida.
\end_layout

\begin_layout Standard
peale iga võitust uus rida.
\end_layout

\begin_layout Standard
Peale iga kvantorit taane.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
kui predikaat sisaldab mingit sümbolit, millel on ka muu tähendus, siis
 on see kas keelatud või tuleb tagurpidi kaldkriipuga tähistada.
\end_layout

\begin_layout Standard
Küsimärkidel eraldi tähendus.
 Kahekordse kriipsuga järeldusmärkidlja ekvivalentsusmärkidel eraldi tähendus.
 {} optimeerimis tingimused.
\end_layout

\begin_layout Standard
Eraldi funktsooni sees saab sisestada käske.
\end_layout

\begin_layout Subsection
syntaxsugar
\end_layout

\begin_layout Standard
Eraldi võimalik märkida alad kus kehtib mingi syntaxsugar nt.
 
\backslash
sugar(
\begin_inset Quotes eld
\end_inset

boolean
\begin_inset Quotes erd
\end_inset

){},
\end_layout

\begin_layout Subsubsection
kvanteeritavate-nimede sugar
\begin_inset CommandInset label
LatexCommand label
name "subsec:kvanteeritavate-nimede-sugar"

\end_inset


\end_layout

\begin_layout Standard
Kui kvantori alaindeksiks pole kvanteeritava nime kirjutatud, siis eeldatakse,
 et selle kvantori kvanteeritava nimi on 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_{k+1}$
\end_layout

\end_inset

 kus 
\begin_inset ERT
status open

\begin_layout Plain Layout

$k$
\end_layout

\end_inset

 näitab, et mitme kvantori sees antud kvantor on.
 Et seda süntax-sugarit kasutavas notatsioonis kirjeldatud seost seda süntax-sug
arit mitte kasutavasse notatsiooni ümber kirjutatada tuleb kvantoritele
 kvanteeritavate nimed (alaindeksitena) juurde kirjutada.
\end_layout

\begin_layout Standard
Näiteks järgnevas valemis, kus pole kvanteeritavate nimesi kirjutatud:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
exists(
\backslash
exists(A(x_1,x_2,x_3,x_2))))
\backslash
land 
\backslash
exists(
\backslash
exists(
\backslash
forall(
\backslash
exists(A(x_1,x_2,x_3,x_4)) 
\backslash
to 
\backslash
exists( 
\backslash
neg A(x_1,x_1,x_3,x_4) ))))
\backslash
land 
\backslash
neg 
\backslash
forall(
\backslash
neg A(x_1,x_1,x_1,x_1))$
\end_layout

\end_inset

 eeldatakse need olema: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(
\backslash
exists_{x_2}(
\backslash
exists_{x_3}(A(x_1,x_2,x_3,x_2))))
\backslash
land 
\backslash
exists_{x_1}(
\backslash
exists_{x_2}(
\backslash
forall_{x_3}(
\backslash
exists_{x_4}(A(x_1,x_2,x_3,x_4)) 
\backslash
to 
\backslash
exists_{x_4}( 
\backslash
neg A(x_1,x_1,x_3,x_4) ))))
\backslash
land 
\backslash
neg 
\backslash
forall_{x_1}(
\backslash
neg A(x_1,x_1,x_1,x_1))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Võib küll tekkida mitmeid samanimelisi kvanteeritavaid(ehkmkvantori fiktiivmuutu
jaid), aga need ei saa mitte kunagi samas kohas valemis kasutusel olla.
 Juhul kui tahetakse vabaneda ka olukorrast, kus on mitu samanimelist kvanteerit
avat võib kõigi kvanteeritavate nimedele lisada punkti ja peale seda arvu,
 mis näitab, et mitu samanimelise kvanteeritavaga kvantorit sellest kvantorist
 vasakul pool asub.
 Näiteks toodud väite puhul:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_{1.0}}(
\backslash
exists_{x_{2.0}}(
\backslash
exists_{x_{3.0}}(A(x_{1.0},x_{2.0},x_{3.0},x_{2.0}))))
\backslash
land 
\backslash
exists_{x_{1.1}}(
\backslash
exists_{x_{2.1}}(
\backslash
forall_{x_{3.1}}(
\backslash
exists_{x_{4.0}}(A(x_{1.1},x_{2.1},x_{3.1},x_{4.0})) 
\backslash
to 
\backslash
exists_{x_{4.1}}( 
\backslash
neg A(x_{1.1},x_{1.1},x_{3.1},x_{4.0}) ))))
\backslash
land 
\backslash
neg 
\backslash
forall_{x_{1.2}}(
\backslash
neg A(x_{1.2},x_{1.2},x_{1.2},x_{1.2}))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sellises süntaks-sugariga saab kirjeldada kõiki väiteid, mida ilma selle
 sütax-sugaritagi saab kirjeldada.
 Et seda süntax-sugarit mitte kasutavas notatsioonis kirjeldatud seost seda
 süntax-sugarit kasutavasse notatsiooni ümber kirjutatada tuleb kõigepealt
 muuta kvanteeritavate nimed eespool kirjeldatudeks ja seejärel eemaldada
 kvanteeritavate nimed kvantorite juurest (alaindeksitena).
\end_layout

\begin_layout Standard
Näiteks järgnev valem:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_a(
\backslash
neg A(a,a) 
\backslash
land 
\backslash
exists_b(A(a,b) 
\backslash
land 
\backslash
neg A(b,a) 
\backslash
land 
\backslash
neg A(b,b) 
\backslash
land 
\backslash
exists_c(
\backslash
neg A(a,c) 
\backslash
land A(b,c) 
\backslash
land 
\backslash
neg A(c,a) 
\backslash
land 
\backslash
neg A(c,b) 
\backslash
land 
\backslash
neg A(c,c)) 
\backslash
land 
\backslash
exists_d(
\backslash
neg A(a, d) 
\backslash
land A(b,d) 
\backslash
land 
\backslash
neg A(d,a) 
\backslash
land 
\backslash
neg A(d,b) 
\backslash
land A(d,d)))) 
\backslash
land 
\backslash
neg 
\backslash
exists_e(
\backslash
neg A(e,e) 
\backslash
land 
\backslash
exists_f(
\backslash
neg A(e,f) 
\backslash
land A(f,e) 
\backslash
land 
\backslash
neg A(f,f) 
\backslash
land 
\backslash
exists_g(A(e, g) 
\backslash
land 
\backslash
neg A(f,g) 
\backslash
land 
\backslash
neg A(g,e) 
\backslash
land 
\backslash
neg A(g,f) 
\backslash
land 
\backslash
neg A(g,g)) 
\backslash
land 
\backslash
exists_h(A(e,h) 
\backslash
land 
\backslash
neg A(f,h) 
\backslash
land 
\backslash
neg A(h,e) 
\backslash
land 
\backslash
neg A(h,f) 
\backslash
land A(h,h))))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
selle syntax-sugariga kirjeldatuna on:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
neg A(x_1, x_1) 
\backslash
land 
\backslash
exists(A(x_1, x_2) 
\backslash
land 
\backslash
neg A(x_2, x_1) 
\backslash
land 
\backslash
neg A(x_2, x_2) 
\backslash
land 
\backslash
exists(
\backslash
neg A(x_1, x_3) 
\backslash
land A(x_2, x_3) 
\backslash
land 
\backslash
neg A(x_3, x_1) 
\backslash
land 
\backslash
neg A(x_3, x_2) 
\backslash
land 
\backslash
neg A(x_3, x_3)) 
\backslash
land 
\backslash
exists(
\backslash
neg A(x_1, x_3) 
\backslash
land A(x_2, x_3) 
\backslash
land 
\backslash
neg A(x_3, x_1) 
\backslash
land 
\backslash
neg A(x_3, x_2) 
\backslash
land A(x_3, x_3)))) 
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
neg A(x_1, x_1) 
\backslash
land 
\backslash
exists(
\backslash
neg A(x_1, x_2) 
\backslash
land A(x_2, x_1) 
\backslash
land 
\backslash
neg A(x_2, x_2) 
\backslash
land 
\backslash
exists(A(x_1, x_3) 
\backslash
land 
\backslash
neg A(x_2, x_3) 
\backslash
land 
\backslash
neg A(x_3, x_1) 
\backslash
land 
\backslash
neg A(x_3, x_2) 
\backslash
land 
\backslash
neg A(x_3, x_3)) 
\backslash
land 
\backslash
exists(A(x_1, x_3) 
\backslash
land 
\backslash
neg A(x_2, x_3) 
\backslash
land 
\backslash
neg A(x_3, x_1) 
\backslash
land 
\backslash
neg A(x_3, x_2) 
\backslash
land A(x_3, x_3))))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
või alternatiivselt:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
neg A(1, 1) 
\backslash
land 
\backslash
exists(A(1, 2) 
\backslash
land 
\backslash
neg A(2, 1) 
\backslash
land 
\backslash
neg A(2, 2) 
\backslash
land 
\backslash
exists(
\backslash
neg A(1, 3) 
\backslash
land A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land 
\backslash
neg A(3, 3)) 
\backslash
land 
\backslash
exists(
\backslash
neg A(1, 3) 
\backslash
land A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land A(3, 3)))) 
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
neg A(1, 1) 
\backslash
land 
\backslash
exists(
\backslash
neg A(1, 2) 
\backslash
land A(2, 1) 
\backslash
land 
\backslash
neg A(2, 2) 
\backslash
land 
\backslash
exists(A(1, 3) 
\backslash
land 
\backslash
neg A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land 
\backslash
neg A(3, 3)) 
\backslash
land 
\backslash
exists(A(1, 3) 
\backslash
land 
\backslash
neg A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land A(3, 3))))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
boolean sugar
\end_layout

\begin_layout Standard
väiteid saab panna predikaadi argumendiks.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$A(
\backslash
forall(...))$
\end_layout

\end_inset

 asemel 
\begin_inset ERT
status open

\begin_layout Plain Layout

$boolean(x)
\backslash
land (toene(x) 
\backslash
iff 
\backslash
forall(...)) 
\backslash
land A(x)$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
operaatorite (järjekorraga) sugar
\begin_inset CommandInset label
LatexCommand label
name "subsec:operaatorite-(järjekorraga)-sugar"

\end_inset


\end_layout

\begin_layout Enumerate
kuni valemis operaatoreid on:
\end_layout

\begin_layout Enumerate
: : paneb operaatoritega valemi ümber universaalsuskvantori nt.
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_{11}+x_{12}*x_{13}=x_{14}$
\end_layout

\end_inset

 peale seda sammu: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(x_{11}+x_{12}*x_{13}=x_{14})$
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
: : jaatab olemasolevale väite uus kvanteeritav on võrdne kõige esimesena
 tehtava operatsiooni tulemusega.
 näteks 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(x_{11}+x_{12}*x_{13}=x_{14})$
\end_layout

\end_inset

 peale seda sammu on: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(*(x_{12},x_{13},x_{15}) 
\backslash
land x_{11}+x_{12}*x_{13}=x_{14})$
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
: : asendab kõige esimesena tehtava operatsiooni uue kvanteeritavaga, et
 selle tehte tulemus on võrdne uue kvanteeritavaga.
 nt.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(*(x_{12},x_{13},x_{15}) 
\backslash
land x_{11}+x_{12}*x_{13}=x_{14})$
\end_layout

\end_inset

 peale seda sammu: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(*(x_{12},x_{13},x_{15}) 
\backslash
land x_{11}+x_{15}=x_{14})$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
näited:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$+(x_1,x_2,x_3)$
\end_layout

\end_inset

 tähendab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1+x_2=x_3$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$*(x_1,x_2,x_3)$
\end_layout

\end_inset

 tähendab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1*x_2=x_3$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$CALL(x_1,...,x_n)$
\end_layout

\end_inset

 tähendab, et funktsioon 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1$
\end_layout

\end_inset

 argumentidega ...
 tagastab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_n$
\end_layout

\end_inset

'i.
\end_layout

\begin_layout Standard
operaatorite järjekord: **,[*,/],[+,-]
\end_layout

\begin_layout Subparagraph
näide
\end_layout

\begin_layout Standard
näiteks teisendab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
exists(
\backslash
exists(x_1*x_2+x_3=f(x_3,x_2,x_1,x_2))))$
\end_layout

\end_inset

 järgenvaks:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$*(x_1,x_2,x_4) 
\backslash
land +(x_4,x_3,x_5) 
\backslash
land on
\backslash
_f(x_6) 
\backslash
land CALL(x_6,x_3,x_2,x_1,x_2,x_7)$
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
näide
\end_layout

\begin_layout Standard
näiteks teisendab valemi:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_null(x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(x_1=x_1)
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(x_1=x_2
\backslash
land x_2=x_3 
\backslash
to x_3=x_1)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(on
\backslash
_naturaalarv(x_1)
\backslash
land x_1=x_2 
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(on
\backslash
_naturaalarv(x_1)
\backslash
land S(x_1,x_2)
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(=(x_1,x_2) 
\backslash
land S(x_1,x_3) 
\backslash
land S(x_2,x_4) 
\backslash
leftrightarrow =(x_3,x_4))) 
\backslash
land 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
to 
\backslash
neg 
\backslash
exists( S(x_2,x_1)
\backslash
land on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
exists(on
\backslash
_null(x_1) 
\backslash
land x_1 
\backslash
in K)
\backslash
land 
\backslash
forall(
\backslash
forall(x_1 
\backslash
in K 
\backslash
land S(x_1,x_2) 
\backslash
to x_2 
\backslash
in K)) 
\backslash
to 
\backslash
forall(x_1 
\backslash
in K)%edasi liitmise definitsioon
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2+x_1=x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1+S(x_2)=S(x_1+x_2)
\end_layout

\begin_layout Plain Layout

))%edasi korrutamise definitsioon
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2*x_1=x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1*S(x_2)=x_1+x_1*x_2
\end_layout

\begin_layout Plain Layout

))
\end_layout

\begin_layout Plain Layout

$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
kujule:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_null(x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(=(x_1,x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(=(x_1,x_2)
\backslash
land =(x_2,x_3)
\backslash
to =(x_3,x_1))))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(on
\backslash
_naturaalarv(x_1)
\backslash
land =(x_1,x_2)
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(on
\backslash
_naturaalarv(x_1)
\backslash
land S(x_1,x_2)
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(x_1=x_2 
\backslash
leftrightarrow S(x_1)=S(x_2))) 
\backslash
land 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
to 
\backslash
neg 
\backslash
exists( S(x_2,x_1)
\backslash
land on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
exists(on
\backslash
_null(x_1) 
\backslash
land x_1 
\backslash
in K)
\backslash
land 
\backslash
forall(
\backslash
forall(x_1 
\backslash
in K 
\backslash
land S(x_1,x_2) 
\backslash
to x_2 
\backslash
in K)) 
\backslash
to 
\backslash
forall(x_1 
\backslash
in K)
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(+(x_2,x_1,x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

S(x_2,x_3) 
\backslash
land +(x_1,x_2,x_4) 
\backslash
land S(x_4,x_5) 
\backslash
land +(x_1,x_3,x_6) 
\backslash
leftrightarrow =(x_6,x_5)
\end_layout

\begin_layout Plain Layout

))))))
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(*(x_2,x_1,x_1)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

S(x_2,x_3) 
\backslash
land *(x_1,x_2,x_4) 
\backslash
land +(x_1,x_4,x_5) 
\backslash
land  
\backslash
leftrightarrow =(x_6,x_5)
\end_layout

\begin_layout Plain Layout

))))))
\end_layout

\begin_layout Plain Layout

$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
transistiivsete operaatorite sugar
\end_layout

\begin_layout Standard
et
\begin_inset ERT
status open

\begin_layout Plain Layout

$a=b=c$
\end_layout

\end_inset

tähendab
\begin_inset ERT
status open

\begin_layout Plain Layout

$a=b 
\backslash
land b=c$
\end_layout

\end_inset

 nt.
 operaatorite rakendamise järjekord.
 syntax nt 
\backslash
enable_syntaxsugar(kommunitiivsed_võdusmärgid)
\end_layout

\begin_layout Standard
.
\end_layout

\begin_layout Subsubsection
kantsulgude sugar
\end_layout

\begin_layout Standard
Kantsulgudel sulgudel selline tähendus, et 
\begin_inset ERT
status open

\begin_layout Plain Layout

$[a OP1 b OP1 c OP1 d] OP2 e = (a OP2 e) OP1 (b OP2 e) OP1 (c OP2 e) OP1
 (d OP2 e)$
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
predikaatide overloading
\end_layout

\begin_layout Standard
võib olla mitu sama nime, aga erineva argumentide arvuga, predikaati.
 kui argumentide arv on erinev, aga siis on tegemist erinevate predikaatidega
 - sellel et nimi on sama pole mingit tähtsust.
\end_layout

\begin_layout Subsubsection
väited predikaatide argumentidena
\end_layout

\begin_layout Standard
Elementaarseoste argumentideks saavad olla väited kui eelenvalt on defineeritud
 True ja False.
 Et nende tähendus olks sama, mis intuitiivne tähendus peab lisama ka nendega
 seotud väited 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(("onTrue"(x_1)
\backslash
land "onTrue"(x_2)
\backslash
to "="(x_1,x_2)) 
\backslash
land ("onTrue"(x_1)
\backslash
land "onFalse"(x_2)
\backslash
to 
\backslash
neg "="(x_1,x_2))))$
\end_layout

\end_inset

.
 Elementeersesos(väide) tähendab: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(väide 
\backslash
to 
\backslash
exists("onTrue(x_1) 
\backslash
land "elementaatseos"(x_1)) 
\backslash
land (
\backslash
neg väide 
\backslash
to 
\backslash
exists("onFalse"(x_1) 
\backslash
land "elementaatseos"(x_1)))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
importimine
\end_layout

\begin_layout Standard
Kasutaja ei peaks iga kord uuesti kõiki (näiteks reaalarvude kohta käivaid)
 aksioome sisestama, vaid peaks saama neid moodulina 
\begin_inset Quotes eld
\end_inset

importida
\begin_inset Quotes erd
\end_inset

(
\begin_inset Quotes eld
\end_inset

includida
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
pannes sisendisse 
\backslash
include_from_URI(foo) asendatakse sisendis see käsk URIl foo olevaga.
 
\end_layout

\begin_layout Standard

\backslash
include_from_standarlibari(bar) asendatakse sisendis see käsk standarlibaris
 kohal bar olevaga.
\end_layout

\begin_layout Standard
imporditud väidetel on võivad olla viimased sulud puudu, sest need ütleva,
 et midagi eksisteerib, aga lasevad kasutajal sama kvantori (mille lähtekood
 on teises failis) väiteid juurde kirjutada.
\begin_inset Newline newline
\end_inset

Moodulid on eelnevalt 
\begin_inset Quotes eld
\end_inset

kompileeritud
\begin_inset Quotes eld
\end_inset

.
 Imortimisel nende väitenumbrit muudetakse nii , et see sobiks kokku ülejäänud
 predikaatide ja K'ga.
 Nii on efektiivsus suurem.
 Moodulite lähtekood ei pea kõigi moodulite puhul avalik olema.
\end_layout

\begin_layout Subsection
näiteid selles syntaxis definitsioonides
\end_layout

\begin_layout Subsubsection
piirväärtus
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$(lim_{x
\backslash
to a}(f(x))=A) 
\backslash
leftrightarrow 
\backslash
forall_{
\backslash
epsilon}(
\backslash
epsilon>0 
\backslash
to 
\backslash
exists_{
\backslash
delta}(
\backslash
delta>0 
\backslash
land 
\backslash
forall_x(((|x-a|<
\backslash
delta)
\backslash
land(|x-a|
\backslash
not =0))
\backslash
to|f(x)-A|<
\backslash
epsilon)))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Iga kauguse 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
epsilon$
\end_layout

\end_inset

 funktsiooni piiväärtusest kohal 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a$
\end_layout

\end_inset

, kohta leidub kaugus 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
delta$
\end_layout

\end_inset

 kohast 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a$
\end_layout

\end_inset

 nii, et iga koht 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x$
\end_layout

\end_inset

, mis on 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a$
\end_layout

\end_inset

'le lähemal kui 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
delta$
\end_layout

\end_inset

, aga mitte kohas 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a$
\end_layout

\end_inset

, korral on funktsioon kohal 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x$
\end_layout

\end_inset

 lähemal 
\begin_inset ERT
status open

\begin_layout Plain Layout

$A$
\end_layout

\end_inset

'le kui 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
epsilon$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Minu süntaksis on see definitsioon: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(lim_{x
\backslash
to a}(f(x))=A) 
\backslash
leftrightarrow 
\backslash
forall_{x_1}(x_1>0 
\backslash
to 
\backslash
exists_{x_2}(x_2>0 
\backslash
land 
\backslash
forall_{x_3}(((|x_3-a|<x_2)
\backslash
land(|x_3-a|
\backslash
not =0))
\backslash
to|f(x_3)-A|<x_1)))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
peano aksioomid
\end_layout

\begin_layout Standard
selles näites on kasutatud peatükis 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:operaatorite-(järjekorraga)-sugar"
plural "false"
caps "false"
noprefix "false"

\end_inset

 kirjeldatud syntaxsugarit.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_null(x_1))
\backslash
land
\backslash

\backslash
%peano 1
\end_layout

\begin_layout Plain Layout


\backslash
forall(x_1=x_1)
\backslash
land
\backslash

\backslash
%peano 2
\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(x_1=x_2
\backslash
land x_2=x_3 
\backslash
to x_3=x_1)))
\backslash
land
\backslash

\backslash
%võrduse peano 3,4
\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(on
\backslash
_naturaalarv(x_1)
\backslash
land x_1=x_2 
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash
%võduse peano 5
\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(on
\backslash
_naturaalarv(x_1)
\backslash
land S(x_1,x_2)
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash
%peano 6
\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(x_1=x_2 
\backslash
leftrightarrow S(x_1)=S(x_2)))%peano 7
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
to 
\backslash
neg 
\backslash
exists( S(x_2,x_1)
\backslash
land on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash
%peano 8
\end_layout

\begin_layout Plain Layout


\backslash
exists(on
\backslash
_null(x_1) 
\backslash
land x_1 
\backslash
in K)
\backslash
land 
\backslash
forall(
\backslash
forall(x_1 
\backslash
in K 
\backslash
land S(x_1,x_2) 
\backslash
to x_2 
\backslash
in K)) 
\backslash
to 
\backslash
forall(x_1 
\backslash
in K)$%peano 9
\end_layout

\end_inset


\end_layout

\begin_layout Standard
7.
 aksioom ilma väiteta, et kõik naturaalarvude alamhulgad eksisteerivad on
 kasutu.
\end_layout

\begin_layout Subsubsection
liitmine
\end_layout

\begin_layout Standard
selles näites on kasutatud peatükis 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:operaatorite-(järjekorraga)-sugar"
plural "false"
caps "false"
noprefix "false"

\end_inset

 kirjeldatud syntaxsugarit.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2+x_1=x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1+S(x_2)=S(x_1+x_2)
\end_layout

\begin_layout Plain Layout

))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
korrutamine
\end_layout

\begin_layout Standard
selles näites on kasutatud peatükis 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:operaatorite-(järjekorraga)-sugar"
plural "false"
caps "false"
noprefix "false"

\end_inset

 kirjeldatud syntaxsugarit.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2*x_1=x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1*S(x_2)=x_1+x_1*x_2
\end_layout

\begin_layout Plain Layout

))$
\end_layout

\end_inset


\end_layout

\begin_layout Part
standard libary
\end_layout

\begin_layout Standard
seal on igasugu kasulikke väiteid, mida kasutaja saab enda omadega jaatada,
 et enda omade tõesust kontrollida.
\end_layout

\begin_layout Paragraph
robinsoni aritmeetika
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_null(x_1) 
\backslash
neg 
\backslash
exists(S(x_1,x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall( x_1=x_2 
\backslash
land S(x_1,x_3)
\backslash
land S(x_2,x_4) 
\backslash
to x_3=x_4))))
\end_layout

\begin_layout Plain Layout

on
\backslash
_null(x_1)
\backslash
lor 
\backslash
exists(S(x_2,x_1))
\end_layout

\begin_layout Plain Layout

%edasi liitmise definitsioon
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2+x_1=x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1+S(x_2)=S(x_1+x_2)
\end_layout

\begin_layout Plain Layout

))%edasi korrutamise definitsioon
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2*x_1=x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1*S(x_2)=x_1+x_1*x_2
\end_layout

\begin_layout Plain Layout

))
\end_layout

\begin_layout Plain Layout

$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
astendamine
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2^{x_1}=S(x_1)))$
\end_layout

\end_inset

iga arv astmes 0 on 1.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1^{S(x_2)}=x_1^{x_2}*x_1
\end_layout

\begin_layout Plain Layout

))$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
lahutamine
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(
\backslash
forall(x_1-x_2=x_3 
\backslash
leftrightarrow x_2+x_3=x_1)))$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
jagamine
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(
\backslash
forall(x_1/x_2=x_3 
\backslash
leftrightarrow x_2*x_3=x_1)))$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
peano viimane naturaalarvude hulga võimsuse aksioom
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_null(x_1) 
\backslash
land x_1 
\backslash
in K)
\backslash
land 
\backslash
forall(
\backslash
forall(x_1 
\backslash
in K 
\backslash
land S(x_1,x_2) 
\backslash
to x_2 
\backslash
in K)) 
\backslash
to 
\backslash
forall(x_1 
\backslash
in K)$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
kõik naturaalarvud on reaalarvud
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_reaalarv(x_1)
\backslash
to on
\backslash
_naturaalarv(x_1))$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
reaalarvude võrdlemine
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(x_1>x_2 
\backslash
leftrightarrow 
\backslash
exists( on
\backslash
_naturaalarv(x_3) 
\backslash
land x_1*x_3>x_2*x_3)))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
reaalarvude pid
\end_layout

\begin_layout Paragraph
täisarvu definitsioon
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_täisarv(x_1)
\backslash
leftrightarrow 
\backslash
exists(on
\backslash
_naturaalarv(x_2)
\backslash
land on
\backslash
_naturaalarv(x_1+x_2)))$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
ratsionaalarvu definitsioon
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_ratsionaalarv(x_1)
\backslash
leftrightarrow 
\backslash
exists(on
\backslash
_naturaalarv(x_2)
\backslash
land on
\backslash
_täisarv(x_1*x_2)))$
\end_layout

\end_inset


\end_layout

\begin_layout Section
sünonüümidest
\end_layout

\begin_layout Standard
Kuna erinevates allikates kasutatakse samade asjade kohta erinevaid nimetusi,
 toon siin välja, et kuidas on mujal nimetatud asju, mida siin failis kasutan.
\end_layout

\begin_layout Standard

\series bold
väide
\series default
 ehk: formaalne süsteem, aksiomaatiline süsteem, valem, lause, seos.
\end_layout

\begin_layout Standard

\series bold
jaatus
\series default
 ehk: konjutsioon.
\end_layout

\begin_layout Standard

\series bold
võitus
\series default
 ehk: disjuktsioon.
\end_layout

\begin_layout Standard

\series bold
üheselt vale
\series default
 ehk: samaselt väär, vastuoluline, samaselt vale, mitte kehtestatav.
\end_layout

\begin_layout Standard

\series bold
üheselt tõene
\series default
 ehk: samaselt tõene.
\end_layout

\begin_layout Standard

\series bold
eksistentsaalsuskvantor
\series default
 ehk: olemasolukantor.
\end_layout

\begin_layout Standard

\series bold
universaalsuskvantor
\series default
 ehk: üldisuskvantor.
\end_layout

\begin_layout Standard

\series bold
elementaarseos
\series default
 ehk: notatsiooni poolt ette antud predikaat.
\end_layout

\begin_layout Standard

\series bold
element
\series default
 ehk: algasi, konstantsümbol.
\end_layout

\begin_layout Standard

\series bold
kvanteeritav
\series default
 ehk: kvantori fiktiivmuutuja
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Osades käsitlustes on ka kandjahulk, aga selle faili terminoloogias on selleks
 universaalne hulk (või seda pole) seega väited kehtivad kõigi asjade kohta.
 Kui tahad et väide kehtiks näiteks ainult naturaalarvude kohta, siis pane
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_x(f(x))$
\end_layout

\end_inset

 asemele 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_x(on
\backslash
_naturaalarv(x)
\backslash
to f(x))$
\end_layout

\end_inset


\end_layout

\end_body
\end_document
