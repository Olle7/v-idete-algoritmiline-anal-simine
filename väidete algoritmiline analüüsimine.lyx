#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{fullpage}
\usepackage{mathptmx} % rm & math
\usepackage[scaled=0.1]{helvet} % ss
\usepackage{amsmath}
\usepackage{xcolor}
\flushbottom
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 0cm
\topmargin 0cm
\rightmargin 0cm
\bottommargin 0cm
\headheight 0cm
\headsep 0cm
\footskip 0cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle empty
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
väidete algoritmiline analüüsimine
\end_layout

\begin_layout Author
Olger Männik
\end_layout

\begin_layout Part
Sissejuhatus
\end_layout

\begin_layout Paragraph
DEFINITSIOON:
\end_layout

\begin_layout Standard

\color yellow
(võibolla on ka üldisem definitsioon kus kvantorid asendatakse, millegagi,
 mis tagsatavad midagi muud kui booleane)
\end_layout

\begin_layout Standard
Sõna väide on siin töös tavalakeelses tähenduses, ehk see on miski, mille
 tõele vastamisest järeldub mingi tõsiasi.
 Siin töös kasutan ühte kindlaid syntaxeid väidete kirja panemiseks.
 Selles syntaxis tohivad väited sisaldada booleanalgebra, kvantoreid ja
 predikaate(või elementaarseoseid või algasju predikaatide asemel).
\end_layout

\begin_layout Paragraph
eesmärgid
\end_layout

\begin_layout Standard
Töö eesmärk on koostada algoritm ja implementeerida see arvutiprogrammina,
 mille abil saaks väiteid minimaalsel vabadusastmel salvestada.
 Minimaalsel vabadusastmel salvestatud väiteid saaks kergesti analüüsida.
 Kui minimaalsel vabadusastmel salvaestamine on liiga raskesti implementeeritav,
 liiga keerukas või liiga palju mälu nõudev, siis võib selle asemel teha
 algoritmi, mis väiteid analüüsib ilma neid minimaalsel vabadusastmel salvestama
ta.
 Kasutaja sisestaks väited kergesti loetavas syntaxis.
 Seda saaks kasutada näiteks kõige üldisemate matemaatiliste probeemide
 (mis võivad olla võrranditena esitatud) lihtsustamiseks, lahendamiseks
 ja lahendite kontrollimiseks.
\end_layout

\begin_layout Standard
Kuna iga väide on salvestatud minimaalsel vabadusastmel, siis saab lihtsasti
 kontrollida, et kas see on üheselt vale, üheselt tõene või mitte kumbagi,
 sest kõigile üheselt valedele ja üheselt tõestele väidetele vastab sama
 arv.
 Tõenäoliselt ongi praktilisel kasutamisel kõige olulisem küsimus, et kas
 väide vormis 
\begin_inset ERT
status open

\begin_layout Plain Layout

$aksioomid 
\backslash
to väide$
\end_layout

\end_inset

 on üheselt vale, üheselt õige või mitte kumbagi (
\begin_inset ERT
status open

\begin_layout Plain Layout

$programm(aksioomid 
\backslash
to väide)$
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Kui sellise programmi tegemine pole Gödeli teoreemi kohaselt võimalik, siis
 teha programm mis seni kuni kasutaja stopp paneb kontrollimist jätkab ja
 järjest täpsemaks läheb.
 arv 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

 peab siis sisaldama infot, et kui palju on selle poolt kirjeldatud väidet
 lihtsustatud.
 Võimalik, et ei saa ka kunagi kindel olla kas antud väide on üheselt vale,
 üheselt tõene või mitte kumbagi.
 Kuigi Gödeli teoreemi kohaselt pole võimalik kogu täisarvude matemaatikat
 aksiomaatiliselt kirjeldada(???), saab arvutile etteantavasse väiteesse
 alati uusi aksioome juurde lisada ja tõestada, et teatud arvust 
\begin_inset ERT
status open

\begin_layout Plain Layout

$K_{max}$
\end_layout

\end_inset

 väiksemate K parameetritega väidete abil kirjeldatavad aksioomid on lisatud.
 Kasutaja ei peaks iga kord uuesti kõiki (näiteks reaalarvude kohta käivaid)
 aksioome sisestama, vaid peaks saama neid moodulina 
\begin_inset Quotes eld
\end_inset

importida
\begin_inset Quotes erd
\end_inset

(
\begin_inset Quotes eld
\end_inset

includida
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
Hea oleks käsitleda minimaalsel vabadusastmel kirjeldatud väiteid naturaalarvude
na.
 Tähistame naturaalarvu, mis kirjeldab väidet 
\begin_inset ERT
status open

\begin_layout Plain Layout

$S$
\end_layout

\end_inset

 tähisega 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

.
 Selleks tuleb defineerida injektiivne vastavus võimalike väidete(võimalik
 vist ainult kindlas notatsioonis olevate väidete korral) ja naturaalarvude
 vahele.
 On võimalik defineerida mitmeid sarnaseid vastavusi.
 Tähistame funktsiooni, mis seab väite 
\begin_inset ERT
status open

\begin_layout Plain Layout

$S$
\end_layout

\end_inset

 vastavusse naturaalarvuga 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

 F'iga.
 Seega 
\begin_inset ERT
status open

\begin_layout Plain Layout

$F(S)=n_S$
\end_layout

\end_inset

.
 Selle pöördfunktsiooni tähistan f'iga.
 Seega 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f(n_S)=S$
\end_layout

\end_inset

.
 Järgnevalt loetlen omadusi, mis vastavusel (ja funktsioonil F) võiks olla,
 et sellisel kujul olevat väidet praktikas mugav kasutada oleks:
\end_layout

\begin_layout Itemize
Hea on kui sellisel kujul estitatud väidete vahel saab rakendada sagedasti
 kasututatavaid operaatoreid(näiteks AND, NAND, OR, NOR ja XOR) rakendades
 neile vastavaid lihtsasti arvutatavaid funktsioone väidet kirjeldavale
 arvule 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Hea on kui tavalises notatsioonis lühidalt kirjapandav väide on ka väikese
 või lihtsasti kirjeldatava naturaalarvuga vastavusse pandud.
\end_layout

\begin_layout Itemize
Hea on kui võimalikud väärtused jäävad 0 ja mingi arvu vahele (mis muide
 on 
\begin_inset ERT
status open

\begin_layout Plain Layout

(max $n_S$ väärtus)
\end_layout

\end_inset

)(kui K pole määratud, siis ei ole 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

 ülmist piiri) nii, et igale nende vahel olevale naturaalarvule vastab erinev
 väide.
 Seega on funktsioon F bijektiivne.
\end_layout

\begin_layout Itemize
Hea on kui Falsele(kõigile üheselt valedele väidetele) vastab 0.
\end_layout

\begin_layout Itemize
Hea on kui Truele(kõigile üheselt tõestele väidetele) vastab 1.
\end_layout

\begin_layout Standard
lühemad eesmärgid prioriteetsuse järjekorras:
\end_layout

\begin_layout Enumerate
koostada algoritm, mis võtaks sisendiks väite ja tagastaks, et kas see on
 vastuoluline või mitte.
\end_layout

\begin_layout Enumerate
implementeerida see algoritm arvutiprogrammina.
\end_layout

\begin_layout Enumerate
koostada oma süntax , mida see programm sisendiks võtab, väidete mugavamaks
 kirjapanemiseks.
\end_layout

\begin_layout Enumerate
lisada pogrammile funktsionaalsus, väitedete salvestamiseks, kujul, mis
 on: Minimaalse vabadusastmete arvuga ehk mistahes 2 erinevat bittide kombinatsi
ooni (kui see on binaarkujul esitatud) tähistavad erinevaid loogikalisi
 lauseid ja universaalne ehk millega saab mingi bittide kombinatsiooniga
 (kui see on binaarkujul esitatud) iga loogikalise lause kirja panna.
 Teisisõnu funktsioon väite ja tähistuse vahel on bijektiivne.
\end_layout

\begin_layout Enumerate
lisada programmile funktsionaalsus esitada väiteid standartsel ja kergesti
 käsitsi loetaval kujul.
\end_layout

\begin_layout Enumerate
lidsada programmile funktsionaalsus hinnata väite keerukust mingi paameetriga.
\end_layout

\begin_layout Enumerate
lisada programmile funktsionaalsus määrata väite parameeter K, ehk ,et kui
 mitme kvantori sees kõige rohkemate kvantorite sees asuv kvantor on ,kui
 esitada väide vormis, kus kõige rohkemate kvantorite sees asuv kvantor
 on võimalikult väheste kvantorite sees.
\end_layout

\begin_layout Section
Näited programmi kasutamisest
\end_layout

\begin_layout Subsection
lihtsamad näited
\end_layout

\begin_layout Standard
Järgnevates näidetes on kasutatud peatükis 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:kvanteeritavate-nimede-sugar"
plural "false"
caps "false"
noprefix "false"

\end_inset

 kirjeldatud syntaxsugarit.
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide on üheselt vale (lühendatult
 
\series bold
ÜV
\series default
): 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(A(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists(A(x_1))$
\end_layout

\end_inset

, sest on väidetud, et miski, mis rahuldab predikaati A eksisteerib, ning
 samuti on väidetud, et seda ei eksisteeri.
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide pole üheselt vale: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(A(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists(A(x_1)
\backslash
land B(x_1))$
\end_layout

\end_inset

, sest on väidetud, et eksisteerib miski, mis rahuldab predikaati A, aga
 ei eksisteeri midagi, mis rahuldaks nii predikaati A kui ka predikaati
 B ning vastuolu ei ole.
 Sellest on lihtsam aru saada kui panna predikaatidele mingid intuitiivselt
 lihtsamini mõistetavad nimed.
 nt.: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_loom(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists(on
\backslash
_loom(x_1)
\backslash
land on
\backslash
_auto(x_1))$
\end_layout

\end_inset

.
 Ehk on väidetud, et eksisteerib mingi asi, mis on loom(eksisteerib mingi
 loom), aga ei eksisteeri midagi, mis oleks nii loom kui ka auto.
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide on üheselt vale: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(A(x_1)
\backslash
land B(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists(A(x_1))$
\end_layout

\end_inset

, sest on väidetud, et eksisteerib miski, mis rahuldab nii predikaati A
 kui ka predikaati B, aga ei eksisteeri midagi, mis rahuldaks predikaati
 A.
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide on üheselt vale: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
exists(A(x_1,x_2)
\backslash
land 
\backslash
exists(A(x_2,x_3)
\backslash
land A(x_2,x_2))))
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
exists(
\backslash
exists( A(x_2,x_1)
\backslash
land A(x_1,x_3)
\backslash
land A(x_1,x_1))))$
\end_layout

\end_inset

,sest on väidetud, et eksisteerib miski (
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_2$
\end_layout

\end_inset

), mis rahuldab millegagi predikaati A olles ise 2.
 argument, rahuldab millegi muuga predikaati A, olles ise 1.
 argument ja rahuldab predikaati A olles selle mõlemaks argumendiks ning
 väite teises osas on väidetud, et selliste omadustega asja just ei eksisteeri.
\end_layout

\begin_layout Standard
Eelnevalt näiteks toodud väidete vastuolulisust on kerge intuitiivselt,
 ilma arvuti abita kontrollida, aga pikkade ja keerukate väidete vastuolulisust
 on niimoodi väga raske kontrollida.
 Siis ongi mu programm kasulik.
 Järgnevalt toon mõned näited keerukamatest väidetest, mille vastuolulisust
 on raske kontrollida:
\end_layout

\begin_layout Itemize
järgneva väite korral programm tagastab, et väide ei ole üheselt vale: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_mari(x_1) 
\backslash
land  
\backslash
neg
\backslash
exists(M(x_1, x_2) 
\backslash
land  
\backslash
exists(M(x_1, x_3) 
\backslash
land  
\backslash
neg M(x_2, x_3) 
\backslash
land  M(x_3, x_1)) 
\backslash
land  
\backslash
exists(M(x_1, x_3) 
\backslash
land  M(x_2, x_3)) 
\backslash
land  
\backslash
neg 
\backslash
exists(M(x_2, x_3) 
\backslash
land  M(x_3, x_3))))
\backslash
land             
\backslash
exists(
\backslash
exists(on
\backslash
_mari(x_2)
\backslash
land M(x_2,x_1)
\backslash
land 
\backslash
exists(M(x_1,x_3)
\backslash
land M(x_2,x_3))
\backslash
land 
\backslash
exists(M(x_2,x_3)
\backslash
land M(x_3,x_2)
\backslash
land 
\backslash
neg M(x_1,x_3)))
\backslash
land 
\backslash
neg 
\backslash
exists(M(x_2,x_1)
\backslash
land M(x_2,x_2)))
\backslash
lor
\backslash
exists(M(x_1,x_1)
\backslash
land 
\backslash
neg 
\backslash
exists(M(x_1,x_2)
\backslash
land M(x_2,x_2)
\backslash
land M(x_2,x_1)))$
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Sellest, et vastuolu pole, on lihtsam aru saada kui panna predikaatidele
 intuitiivselt lihtsamini mõistetavamad nimed.
 nt.:predikaat M on 
\begin_inset Quotes eld
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1$
\end_layout

\end_inset

'le meeldib 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_2$
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, ehk kui 
\begin_inset ERT
status open

\begin_layout Plain Layout

$M(x_1,x_2)$
\end_layout

\end_inset

, siis 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1$
\end_layout

\end_inset

 meeldib 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_2$
\end_layout

\end_inset

'le.
 Siis on väidetud , et: [kõigil, kes Marile meeldivad,[ei ole kedagi kes
 Marile meeldiks, aga temale mitte ja kellele meeldiks Mari] või [ei ole
 kedagi, kes nii talle kui Marile meeldiks] või [on keegi, kes neile meeldib
 ja kes iseendale meeldib]] ja leidub keegi, kes meeldib marile, nii, et
 eksisteerib [keegi, kes meeldib nii marile kui talle] ja [keegi, kes meeldib
 marile, kellele mari meeldib ja kelle ei meeldi talle] ja ei leidu kedagi,
 kes nii iseendale kui ka talle ta meeldiks või [on keegi(x_1) kes endale
 meeldib, aga [kellel pole kedagi kes nii talle kui iseendale meeldiks ja
 kellele meeldiks tema(x_1)]].
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide on üheselt vale:
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(A(x_1,x_1)
\backslash
land 
\backslash
exists(A(x_2,x_2) 
\backslash
land A(x_2,x_1) 
\backslash
land A(x_1,x_2)) 
\backslash
land 
\backslash
exists(
\backslash
neg A(x_2,x_2) 
\backslash
land 
\backslash
neg A(x_1,x_2) 
\backslash
land A(x_2,x_1) 
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
neg A(x_3,x_3) 
\backslash
land 
\backslash
neg A(x_3,x_2) 
\backslash
land A(x_3,x_1) 
\backslash
land A(x_2,x_3) 
\backslash
land A(x_1,x_3))))
\backslash
land
\end_layout

\begin_layout Plain Layout


\backslash
neg 
\backslash
exists(
\backslash
exists(
\backslash
exists(
\backslash
neg A(x_1,x_1)
\backslash
land 
\backslash
neg A(x_1,x_2)
\backslash
land 
\backslash
neg A(x_2,x_1)
\backslash
land 
\backslash
neg A(x_2,x_2)
\backslash
land 
\backslash
neg A(x_3,x_1)
\backslash
land 
\backslash
neg A(x_3,x_2)
\backslash
land 
\backslash
neg A(x_3,x_3)
\backslash
land 
\backslash
neg A(x_1,x_3)
\backslash
land 
\backslash
neg A(x_2,x_3)))
\backslash
lor A(x_1,x_1) 
\backslash
land 
\backslash
exists(A(x_2,x_2) 
\backslash
land 
\backslash
neg A(x_2,x_1) 
\backslash
land A(x_1,x_2) 
\backslash
neg 
\backslash
exists(
\backslash
neg A(x_3,x_3) 
\backslash
land A(x_3,x_2) 
\backslash
neg 
\backslash
land A(x_3,x_1) 
\backslash
land A(x_2,x_3) 
\backslash
land A(x_1,x_3)) ))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Siin on toodud mõned väited, mille üheselt valesust saaks minu programmiga
 kontrollida, aga mille vastuolulisuse kontrollimiseks on vaja kasutada
 matemaatiliste tehte märkide tähendusi kirjeldavaid väiteid ja arvude kohta
 käivaid aksioome.
 Programmi kasutaja ei peaks neid käsitsi sisestama vaid saaks need standard
 libarist võtta.
 Standard libariks olevat väidet tähistan siinkohal nimega STANDARD.
 Samuti on selleks vaja kasutada mõndasid syntax-sugareid.
\end_layout

\begin_layout Standard
mitte ÜV: 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists(x_1+3=7 
\backslash
land on
\backslash
_reaalarv(x_1))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists(0*x_1=3 
\backslash
land on
\backslash
_reaalarv(x_1))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists((on
\backslash
_naturaalarv(x_1) 
\backslash
to x_1>x_1) 
\backslash
lor x_1=x_1+1)$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists(on
\backslash
_reaalarv(x_1)
\backslash
land 
\backslash
exists(x_1+x_2=23
\backslash
land x_1+2*x_2=37 
\backslash
land x_1<53 
\backslash
land x_1*x_2<200 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists (
\backslash
neg 
\backslash
exists (x_1>x_2 
\backslash
land on
\backslash
_reaalarv(x_1) 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

 ei leidu arvu, millest suuremat ei leiduks.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists (
\backslash
exists (x_1>x_2
\backslash
land x_1<x_2 
\backslash
land on
\backslash
_reaalarv(x_1) 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

ei leidu kahte arvu nii, et mõlemad oleksid teisest suuremad.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists (
\backslash
neg 
\backslash
exists (x_1*x_2 
\backslash
not = 0 
\backslash
land on
\backslash
_reaalarv(x_1) 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

Leidub arv(0), nii et ei leiduks arvu, millega seda korrutades ei saaks
 vastuseks nulli.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists (
\backslash
exists (x_1+x_2=9
\backslash
land x_1*x_2=20
\backslash
land x_1>x_2 
\backslash
land on
\backslash
_reaalarv(x_1) 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

 Need arvud on 5 ja 4.
\end_layout

\begin_layout Standard
ÜV:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists(
\backslash
exists({x_1}^3-4*{x_1}^2+6*x_1-24-{x_2}^4+3*x_2=0 
\backslash
land x_2>1))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists(on
\backslash
_reaalarv(x_1)
\backslash
land 
\backslash
neg 
\backslash
exists(x_1<x_2 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

eksiseerib selline reaalarv, nii et ei leidu ühtegi teist reaalarvu, mis
 sellest suurem oleks.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists(on
\backslash
_kompleksarv(x_1)
\backslash
land 
\backslash
exists(x_1<x_2 
\backslash
land on
\backslash
_kompleksarv(x_2) 
\backslash
land x_1^2=x_2^2))$
\end_layout

\end_inset

 ei leidu kahte kompleksarvu, mille ruut oleks sama ja millest esimene oleks
 teisest suurem.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists(on
\backslash
_kompleksarv(x_1)
\backslash
land 
\backslash
exists(on
\backslash
_kompleksarv(x_2) 
\backslash
land 
\backslash
exists(on
\backslash
_kompleksarv(x_3) 
\backslash
land x_1^5=x_2^5 
\backslash
land x_2^5=x_3^5 
\backslash
land x_1 
\backslash
neq x_2 
\backslash
land x_2 
\backslash
neq x_3 
\backslash
land x_1 
\backslash
neq x_3)))$
\end_layout

\end_inset

 ei leidu 3e erinevat kompleksarvu, mille 5 aste oleks sama.
\end_layout

\begin_layout Standard
Saaks kontrollida ka, et kas mingi hüpotees(teoreem) järeldub aksioomidest(ehk
 standard libarist).
 Kui standard libaris on piisavalt palju infot, siis järgneva seose korral
 programm tagastab, et see seos on ÜV, ehk et see hüpotees oli tõene.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg (STANDARD 
\backslash
to 
\backslash
neg 
\backslash
exists(on
\backslash
_naturaalarv(x_1) 
\backslash
land 
\backslash
exists(on
\backslash
_naturaalarv(x_2) 
\backslash
land 
\backslash
exists( on
\backslash
_naturaalarv(x_3) 
\backslash
land 
\backslash
exists(x_1^{x_4}+x_2^{x_4}=x_3^{x_4} 
\backslash
land x_4>2 
\backslash
land on
\backslash
_naturaalarv(x_4))))))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Matemaatiliste mõistete vahelise väite kirjeldamine.
\end_layout

\begin_layout Subsection
algoritmi või arvutiprogrammi analüüsimiseks
\end_layout

\begin_layout Standard
igal pool asendada käsk x:=y väitega 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x(t+1)=y(t)$
\end_layout

\end_inset

, kus t on prgrammi samm.
\end_layout

\begin_layout Subsection
Füüsikalise mudeli kirjeldamiseks
\end_layout

\begin_layout Standard
Oluline on ka näidata, et milliste erinevate väärtuste korral on süsteemid
 füüsikaliselt identsed.
 Näiteks ei ole oluline potentsiaali 0-nivoo ja koordinaatide alguspunkt.
\end_layout

\begin_layout Standard
Oluliseks pointiks nii tõenäosuste kui geomeetrilise ruumi(intuitiivsetst
 vektoritest) on, et intuitiivse tähendusega aja korrutis arvuga on samuti
 intuitiivne.
 See on vist kuidagi taustsüsteemiga seotud.
 taust süsteemi, mille algus on kohas 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
vec{a}$
\end_layout

\end_inset

 olev vektor 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
vec{b}$
\end_layout

\end_inset

 asub kohas 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
vec{a}+
\backslash
vec{b}$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Füüsikalise väite(mudeli) kasulikkus on seda suurem, mida täpsemalt see
 katseandmetega klapib ja lihtsam on(mida väiksem on selle keerukus).
 Lihtsust on ilmselt õige hinnata kui füüsikalised suurused on kirjapandud
 minimaalsel vabadusastmel ja võimalikult sümmeetriliselt(näiteks ruumiline
 ja ajaline sümmeetria), et selgelt eristada matemaatilisi algmõisted (funktsioo
n, võrdsus, hulk, implikatsioon jne(siin näitena toodud mõisted ei moodusta
 minimaalset funktsionaalselt täielikku hulka)) ja füüsilisi algmõisted
 (ruum, aeg, elektromagnetväli, elektrimagnetväli, gravitomagnetväli, gravitimag
netväli, aegruum).
 Võtta kasutusele ka füüsikalised mõisted, mis ei ole algmõisted (nt.
 konkreetsed ained, tahke, vedel, gaasiline, aatom).
\end_layout

\begin_layout Standard
Ükski tõestamatu väide ei tohi omada füüsikalist tähendust(näiteks ei oma
 koordinaatide alguspunkti valik füüsikalist tähendust.) ja ükski füüsikalise
 tähenduseta väide ei tohi olla tõestatav.
 
\end_layout

\begin_layout Standard
Füüsikalise mudeli, mis sisaldab suuruseid(nt.
 Aeg, kordinaat ja väljatugevus) ja iseelommustakse reaalarvuga, kirjeldamiseks
 tuleb deineerida vastavad aritmeetilised tehted reaalarvudele.
 Kas alati tuleb defineerida ka jagamine, et saaks väita nt.
 ,et üks suurus on teisest 3 korda suurem?
\end_layout

\begin_layout Subsubsection
mudeli lihtsus
\end_layout

\begin_layout Standard
Katseadnmetega paremini kokku sobiv mudel on tõenäolisem.
 Lihtsam mudel tõenäolisem.
 ##tekstist on informatsioon puudu, vajab täiendamist
\end_layout

\begin_layout Standard
Mudelite lihtsuse võrdelmiseks peavad neil olema samad elementaarseosed.
 Kui ühel mudelil on rohkem predikaate või algasju kui teisel tuleb need
 eksistentsiaalsuskvantori abil eemaldada(näiteks ühes on ainult punktkehad
 ja teises ka väli, mille väärtus määra, et kui suure tõenäosusega punktkeha
 igas punktis asub).
 Keerukus arvutatakse juba töödeldud väitest.
 võibolla on see keerukus Gödeli keerukus?
\end_layout

\begin_layout Standard
Lisaks tavalisele keerukusele defineerida teine mõiste keerukus2 nii , et
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(
\backslash
frac{sobivus andmetega(mudel1)}{keerukus2(mudel1)}>
\backslash
frac{sobivus andmetega(mudel2)}{keerukus2(mudel2)}) 
\backslash
to (mudel1 "on parem mudel kui" mudel2)$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Paragraph
idee1 keerukuse hindamiseks
\end_layout

\begin_layout Standard
Üks võimalus mudeli lihtsuse kirjeldamiseks on hulga, mis sisaldab kõiki
 selle mudeliga sobivaid erinevaid füüsikalisi süsteeme võimsus.
 Kõik PML süsteemid saab kirjeldada ühe reaalarvuga (järjend, mis sisaldab
 kõiki PML üht reaalarvu)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Paragraph
idee2 keerukuse hindamiseks
\end_layout

\begin_layout Standard
Veel 1 võimalus keerukue hindamiseks: reaalarvude arv, mida onvaja mistahes
 mudeliga sobituva süsteemi kirjeldamiseks nii, et mistahes diferentsiaalse
 muutuse süsteemis saab teha mingi nendest reaalarvudest diferentsiaalselt
 väiksel määral muutes.
\end_layout

\begin_layout Subsection
näiteid selles syntaxis definitsioonides
\end_layout

\begin_layout Subsubsection
piirväärtus
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$(lim_{x
\backslash
to a}(f(x))=A) 
\backslash
leftrightarrow 
\backslash
forall_{
\backslash
epsilon}(
\backslash
epsilon>0 
\backslash
to 
\backslash
exists_{
\backslash
delta}(
\backslash
delta>0 
\backslash
land 
\backslash
forall_x(((|x-a|<
\backslash
delta)
\backslash
land(|x-a|
\backslash
not =0))
\backslash
to|f(x)-A|<
\backslash
epsilon)))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Iga kauguse 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
epsilon$
\end_layout

\end_inset

 funktsiooni piiväärtusest kohal 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a$
\end_layout

\end_inset

, kohta leidub kaugus 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
delta$
\end_layout

\end_inset

 kohast 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a$
\end_layout

\end_inset

 nii, et iga koht 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x$
\end_layout

\end_inset

, mis on 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a$
\end_layout

\end_inset

'le lähemal kui 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
delta$
\end_layout

\end_inset

, aga mitte kohas 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a$
\end_layout

\end_inset

, korral on funktsioon kohal 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x$
\end_layout

\end_inset

 lähemal 
\begin_inset ERT
status open

\begin_layout Plain Layout

$A$
\end_layout

\end_inset

'le kui 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
epsilon$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Minu süntaksis on see definitsioon: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(lim_{x
\backslash
to a}(f(x))=A) 
\backslash
leftrightarrow 
\backslash
forall_{x_1}(x_1>0 
\backslash
to 
\backslash
exists_{x_2}(x_2>0 
\backslash
land 
\backslash
forall_{x_3}(((|x_3-a|<x_2)
\backslash
land(|x_3-a|
\backslash
not =0))
\backslash
to|f(x_3)-A|<x_1)))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
peano aksioomid
\end_layout

\begin_layout Standard
selles näites on kasutatud peatükis 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:operaatorite-(järjekorraga)-sugar"
plural "false"
caps "false"
noprefix "false"

\end_inset

 kirjeldatud syntaxsugarit.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_null(x_1))
\backslash
land
\backslash

\backslash
%peano 1
\end_layout

\begin_layout Plain Layout


\backslash
forall(x_1=x_1)
\backslash
land
\backslash

\backslash
%peano 2
\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(x_1=x_2
\backslash
land x_2=x_3 
\backslash
to x_3=x_1)))
\backslash
land
\backslash

\backslash
%võrduse peano 3,4
\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(on
\backslash
_naturaalarv(x_1)
\backslash
land x_1=x_2 
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash
%võduse peano 5
\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(on
\backslash
_naturaalarv(x_1)
\backslash
land S(x_1,x_2)
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash
%peano 6
\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(x_1=x_2 
\backslash
leftrightarrow S(x_1)=S(x_2)))%peano 7
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
to 
\backslash
neg 
\backslash
exists( S(x_2,x_1)
\backslash
land on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash
%peano 8
\end_layout

\begin_layout Plain Layout


\backslash
exists(on
\backslash
_null(x_1) 
\backslash
land x_1 
\backslash
in K)
\backslash
land 
\backslash
forall(
\backslash
forall(x_1 
\backslash
in K 
\backslash
land S(x_1,x_2) 
\backslash
to x_2 
\backslash
in K)) 
\backslash
to 
\backslash
forall(x_1 
\backslash
in K)$%peano 9
\end_layout

\end_inset


\end_layout

\begin_layout Standard
7.
 aksioom ilma väiteta, et kõik naturaalarvude alamhulgad eksisteerivad on
 kasutu.
\end_layout

\begin_layout Subsubsection
liitmine
\end_layout

\begin_layout Standard
selles näites on kasutatud peatükis 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:operaatorite-(järjekorraga)-sugar"
plural "false"
caps "false"
noprefix "false"

\end_inset

 kirjeldatud syntaxsugarit.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2+x_1=x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1+S(x_2)=S(x_1+x_2)
\end_layout

\begin_layout Plain Layout

))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
korrutamine
\end_layout

\begin_layout Standard
selles näites on kasutatud peatükis 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:operaatorite-(järjekorraga)-sugar"
plural "false"
caps "false"
noprefix "false"

\end_inset

 kirjeldatud syntaxsugarit.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2*x_1=x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1*S(x_2)=x_1+x_1*x_2
\end_layout

\begin_layout Plain Layout

))$
\end_layout

\end_inset


\end_layout

\begin_layout Part
funktsiooni F struktuur
\end_layout

\begin_layout Standard
Kuna väide tohib koosneda ainult booleanalgebrast (taseme 1)kvantoritest
 ja argumentidest saab F'i kirjeldada väite abil, mis nende kvantorite vahelise
 booleanfunktsioonile naturaalarvu vastavusse paneb.
 Kuna erinevaid kvantoreid on lõpmatult
\end_layout

\begin_layout Standard
Seega saab vaadata iga funktsiooni F nendest osadest koosnevana 
\begin_inset ERT
status open

\begin_layout Plain Layout

$F(väide)=F_{boolean
\backslash
_funktsioon
\backslash
_naturaalarvuks}(F_{nummerda
\backslash
 lõplik
\backslash
 arv
\backslash
 kvantoreid}(t))=n_S$
\end_layout

\end_inset

.
 Jaotasin F'i osadeks, et selle defineerimise erinevaid võimalusi oleks
 lihtsam kirjeldada oleks.
 
\color red
kvantorite see võib ja k booleanfunktsioone olla
\end_layout

\begin_layout Standard
väite argumente on alati lõplikult.
 Erinevaid väiteid on loenduv lõpmatus.
 Iga väidet saab kirjeldada booleanfunktsiooni võimalikest kvantoritest
 kaudu.
 Kuna võimalikke kvantoreid on lõpmatult tuleb võtta mingi lisamuutuja 
\begin_inset ERT
status open

\begin_layout Plain Layout

$t$
\end_layout

\end_inset

, mis seab kvantoritele piirid nii, et iga 
\begin_inset ERT
status open

\begin_layout Plain Layout

$t$
\end_layout

\end_inset

 väärtuse korral on võimalikke kvantoreid lõplik arv ja ükskõik milliseid
 kvantoreid sisaldavad veerud saab mingi 
\begin_inset ERT
status open

\begin_layout Plain Layout

$t$
\end_layout

\end_inset

 väärtuse korral.
\end_layout

\begin_layout Section
filtreerida ja nummerdada veerud
\end_layout

\begin_layout Standard
Iga väite kirjeldamiseks piisab veergude vahelist boolenfunktsiooni.
 Osad veergude booleankombinatsioonid on üheselt valed.
\end_layout

\begin_layout Section
konverteerida booleanfunktsioon naturaalarvuks
\end_layout

\begin_layout Part
definitsiooonid
\end_layout

\begin_layout Standard
Tasemefunktsioon 
\begin_inset ERT
status open

\begin_layout Plain Layout

$h_i$
\end_layout

\end_inset

 on bijektiivses seoses kõigi elementaarfunktsioonide väärtustega, kui elementaa
seoste vähemalt üheks argumendiks on taseme i kvanteeritav ja ei ole kõrgema
 taseme kvanteeritavaid.
 Elemndi põhisest notatsioonist sellesse notatsiooni konverteerimisel võivad
 elementaarseoste argumentideks olla ka algasjad.
 Tasemefunktsiooni võimalikku väärtuste arvu tähistan H(k).
\end_layout

\begin_layout Part
Võimalusi argumentide ja kvanteeritavate vahelise suhte noteerimiseks
\end_layout

\begin_layout Standard
Väite argumendid on reaalsed asjad(mitte fiktiivmuutujad), mille kohta väide
 midagi ütleb.
 Sõltuvalt notatsioonist võivad võivad väite argumendid olla mitmel erineval
 kujul.
 Selles töös on käsitletud 3e erinevat kuju argumentidele, milleks on 
\series bold
predikaat
\series default
, 
\series bold
elementaarseos
\series default
 või 
\series bold
algas
\series default
i.
 Et väitest järlelduks midagi mingi asja kohta, ehk et väide mingi asja
 kohta saaks käia peab see seda asja argumenina sisaldama.
 Argumendi kuju sõltub notatsioonist, mille abil väite argumendi ja muu(kvanteer
itavate) vahelist suhet kirjeldatakse.
 Et väitel oleks intuitiivselt mõistetav tähendus, peab väite argument sisaldama
 midagi intuitiivselt mõistetavat.
 Vastavate argumentide valimise abil saab defineerida kõik matemaatilised
 mõisted.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Väite argumendi ja muu vahelist suhet võib kirjeldada ükskõik mis notatsioonis,
 milles saab suvalise lõpliku arvu võimalusi kirjeldada.
 Kuna nii on kirjutatut lihtne mõista ja see on levinud notatsioon on siin
 peamiselt kasutud hulga-põhist-notatsiooni.
\end_layout

\begin_layout Standard
Notatsioone saab üksteiseks ümber kirjutada ilma väidet muutmata.
 Väide on notatsiooni transformatsiooni suhtes invariantne.
\end_layout

\begin_layout Section
argumendiks on kasutaja sisestatud predikaadid
\end_layout

\begin_layout Standard
Predikaadi notatsioonis võib väite argumendist mõelda kui funktsioonidest,
 mis tagastavad booleane (kas True või False).
 Algväited võivad olla näiteks 
\begin_inset Quotes eld
\end_inset

x on null
\begin_inset Quotes erd
\end_inset

(x), 
\begin_inset Quotes eld
\end_inset

x on hulk
\begin_inset Quotes erd
\end_inset

(x) ,
\begin_inset Quotes erd
\end_inset

x on naturaalarv
\begin_inset Quotes erd
\end_inset

(x) 
\begin_inset Quotes eld
\end_inset

x on funktsioon
\begin_inset Quotes erd
\end_inset

(x) või 
\begin_inset Quotes eld
\end_inset

x_1 on suurem kui x_2
\begin_inset Quotes erd
\end_inset

(x_1,x_2).
\end_layout

\begin_layout Subsection
eriasjad
\end_layout

\begin_layout Standard
eriasjad on nagu predikaadid, aga võtavad kvanteeritavate asemel argumendiks
 kas booleane või booleanseoseid.
 Muidu võiks sulgusid ka eriasjaks pidada, aga need lihtsalt, mis mille
 argumendiks on.
 Kas siis kui kõigi predikaatide argumentide arv on teada pole sulge vaja?
 A(B(3,4),C(1,2)) vs A(B(3,4),C(1,2))
\end_layout

\begin_layout Subsubsection
Võimalikke eriasjade valikuid:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(B)$
\end_layout

\end_inset

, NOR
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(B)$
\end_layout

\end_inset

, NAND
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(NOR(B1,B2))$
\end_layout

\end_inset

 (See on sama, mis 
\begin_inset ERT
status open

\begin_layout Plain Layout

$NOR(
\backslash
forall(B1),
\backslash
forall(B2))$
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg 
\backslash
forall(OR(B1,B2))$
\end_layout

\end_inset

!
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$NOR(
\backslash
forall(B1),B2)$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$OR(
\backslash
neg 
\backslash
forall(B1),
\backslash
neg B2)$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(NAND(B1,B2))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg 
\backslash
forall(AND(B1,B2))$
\end_layout

\end_inset

 (See on sama, mis 
\begin_inset ERT
status open

\begin_layout Plain Layout

$NAND(
\backslash
forall(B1),
\backslash
forall(B2))$
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$NAND(
\backslash
forall(B1),B2)$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$AND(
\backslash
neg 
\backslash
forall(B1),
\backslash
neg B2)$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mõistlikuim on noest ilmselt See valida, mille korral algoritm kõige lihtsam
 tuleb.
 NORK ehk 
\begin_inset ERT
status open

\begin_layout Plain Layout

$NORK=
\backslash
forall(NOR(B1,B2))=NOR(
\backslash
forall(B1),
\backslash
forall(B2))=
\backslash
neg 
\backslash
forall(B1) 
\backslash
land 
\backslash
neg 
\backslash
forall(B2))= 
\backslash
exists(
\backslash
neg B1) 
\backslash
land 
\backslash
exists(
\backslash
neg B2))$
\end_layout

\end_inset

, tundub hea, sest saab kergesti DNF vormi kirjutada sellega
\end_layout

\begin_layout Section
Argumendiks on elementaarseosed
\end_layout

\begin_layout Standard
Selles notatsioonis on väidete argumentideks elementaarseosed kanteeritavate
 vahel.
 Miski muu peale kvanteeritavate ei tohi elementaarseoste argumendiks olla.
 Elementaarseosed on notatsiooni poolt ette antud ja kasutaja neid lisada
 ega eemaldada ei saa.
\end_layout

\begin_layout Standard
Võimalikud elementaarseose põhised notatsioonid erinevad selle poolest,
 et kui mitme asja kaupa kvanteeritavate vahelisis elementaarseoste väiteid
 kirjeldatakse ja et kui mitmel erineval viisil saavad samad asjad samas
 elementaaresoses olla.
 Tähistan arvu, mille kaupa asjade vahelist seost kirjeldatakse a'ga ja
 erinevate elementaarseoste arvu b'ga.
\end_layout

\begin_layout Standard

\color yellow
Kas iga väidet saab ümber kirjutada a ja b väärtustega kirjeldatuks ilma
 algmõisteid muutmata? a Kas iga väidet saab ümber kirjutada a ja b väärtustega
 kirjeldatuks ilma algmõisteid muutmata? a ja b väärtustega kirjeldatuks
 ilma algmõisteid muutmata? 
\end_layout

\begin_layout Standard

\color yellow
Kas elementaarseostel peab ka intuitiivne tähendus olema, et väitel intuitiivne
 tähendus oleks?
\end_layout

\begin_layout Standard
Võimalikud elementaarseose põhised notatsioonid erinevad järgnevate omaduste
 poolest
\end_layout

\begin_layout Itemize
Kas elementaarseose väide sõltub argumentide järjekorrast.
 Ehk kas 
\begin_inset ERT
status open

\begin_layout Plain Layout

$A(x_1,x_2)=A(X_2,x_1)$
\end_layout

\end_inset

 (kas saab mitte sümmeetrilisi seoseid kirjeldada.)
\end_layout

\begin_layout Itemize
Mitu argumenti on elementaarseostel.
 Ehk, et kui mitme asja kaupa kvanteeritavate vahelisis elementaarseoste
 väiteid kirjeldatakse.
 Tähistan arvu, mille kaupa asjade vahelist seost kirjeldatakse a'ga.
\end_layout

\begin_layout Itemize
Kui palju erinevaid võimalikke väärtusi kindlate argumentidega kindlal elemaarse
ose väite olla saab.
 Üldiselt eeldatakse, et see arv on 2 (True ja False).
\end_layout

\begin_layout Standard
Väite argumendi kohta vähem eeldusi tehes saab mõndasi väiteid mäluefektiivsemal
t kirjeldada.
 Rohkem eeldusi tehes on argumente lihtsam tõlgendada.
\end_layout

\begin_layout Subsection
väited elementaaresote kohta?
\end_layout

\begin_layout Standard
Osade väidete formuleeiming sõltub väites olvatest predikaatidest.
 Nii, et kui kasutaja sisestab uue predikaadi tuleb need väited alati ümber
 kirjutada.
 See teeks minu programmi kasutaminse ebamugavaks.
\end_layout

\begin_layout Standard
Näiteks võrdususe väitmiseks tuleb lisada eraldi võrdsuse elementaarseos
 
\begin_inset Quotes eld
\end_inset

x_1 ja x_2 on võrdsed
\begin_inset Quotes erd
\end_inset

(x_1,x_2).
 Et selle tähendus oleks kooskõlaline selle intuitiivse tähendusega, peab
 väitele lisama väite, et kui 2 asja on võrdsed, siis pole ükski elementaarfunkt
sioon neist asjadest erineva väärtusega(ükskõik mitu argumenti elementaarfunktsi
oonil on ja mis elementaarfunktsioonide ülejäänud argumentideks on) (See
 võrdusmärgi asi võib olla seotud Gödeli II teoreemiga).
 Kõigi argumentide puhul ei pruugi kehtida vastupidine, et kui kõik elementaarse
osed 2 asjast on võrdsed, siis on need asjad ise võrdsed.
 Peale võrusmärgi peab teisigi väiteid, mis peavad kõigi predikaatide korral
 kehtima formuleerima kõigi predikaatide valikute puhul erinevalt.
 Kuna predikaadid ja nende argumentida arv on teada saab universaalsuskvantori,
 mis kehtib predikaatide kohta asendada jaatusega ja eksistentsiaalsuskvantori
 võitusega.
 Saab lisada ka mingi syntaxi, mis automaatselt lisab, et mingi väide kehtib
 kõigi preikaatidekohta.
 Osade argumentide puhul võib väitele lisada veel mingeid elementaarseoseid
 elementaarseosega 
\begin_inset Quotes eld
\end_inset

x_1 ja x_2 on võrdsed
\begin_inset Quotes erd
\end_inset

(x_1,x_2)
\begin_inset Quotes erd
\end_inset

 siduvaid väiteid nagu näiteks, et kui 2 hulka sisaldavad samu asju, siis
 on nad võrdsed.
\end_layout

\begin_layout Standard
Näiteks funktsioonide defineerimisel tuleb väide, et leidub funktsioone,
 mis _..._ lisada erinevate predikaatie valikute puhul erinevalt.
 Muidu ei saaks näiteks Peano aksioomi 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_{x_1}("onfunktsioon"(x_1) 
\backslash
to 
\backslash
forall_{x_2}(x_2 
\backslash
in N 
\backslash
to ("rakenda"(x_1,x_2)
\backslash
to"rakenda"(x_1,x_2+1))
\backslash
land "rakenda"(x_1,0) 
\backslash
to 
\backslash
forall_{x_2}(x_2 
\backslash
in N 
\backslash
to rakenda(x_1,x_2))))$
\end_layout

\end_inset

 kasutada, sest väites ei ole kirjas, et leidub funktsioone, mis kõiki erinevaid
 naturaalarvusid asju eristavad.
 Kui väites on kirjas, et mingi predikaat on rahuldatud 0 puhul ja sellest,
 et see mingi arvu puhul rahuldatud on järeldub, et see on sellest arvust
 ühe võrra suurema arvu puhul rahuldatud ja, et see ei ole mingi naturaalarvu
 puhul rahuldatud, ei saa programm seda väidet Falseks lihtsustada, sest
 väites ei ole kirjas, et leidub funktsioon, mis on tõene ainult nende elementid
e puhul, mis seda predikaati rahuldavad.
\end_layout

\begin_layout Standard
Hulkade defineerimisel tekib analoogne probleem ehk, et ei ole kirjas, et
 leidub misathes sialduvusega hulkasid.
\end_layout

\begin_layout Standard
Üks võimals on teha vaikiv eeldus, et kõik hulgad eksisteerivad ja anna
 kirja, et millised teised asjad eksisteerivad hulkade kaudu.
 Näiteks:
\end_layout

\begin_layout Itemize
võrduse probleem: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(=(x_1,x_2)
\backslash
leftrightarrow 
\backslash
forall(on
\backslash
_hulk(x_3)
\backslash
to (x_1 
\backslash
in x_3 
\backslash
leftrightarrow x_2
\backslash
in x_3))))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
see ,et kõik 2 argumendilised funktsioonid eksisteerivad: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(on
\backslash
_hulk(x_1)
\backslash
land on
\backslash
_hulk(x_2)
\backslash
land on
\backslash
_hulk(x_3)
\backslash
land
\end_layout

\begin_layout Plain Layout

x_4
\backslash
in x_1
\backslash
land x_5
\backslash
in x_2
\backslash
land x_6
\backslash
in x_3
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
to 
\backslash
exists(on
\backslash
_funktsioon(x_7)
\backslash
land rakenda(x_7,x_4,x_5,x_6))
\backslash
land 
\end_layout

\begin_layout Plain Layout


\backslash
exists(on
\backslash
_funktsioon(x_7)
\backslash
land 
\backslash
neg rakenda(x_7,x_1,x_2,x_3)) )))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Võimalikud lahendused
\end_layout

\begin_layout Paragraph
kvanteerimine üle predikaatide
\end_layout

\begin_layout Standard
igale universaalsuskvantorile lisada jaatusega, et sama väide kehtib ka
 predikatide kohta ja konstantfunktsioon 
\begin_inset Quotes eld
\end_inset

rakenda
\begin_inset Quotes erd
\end_inset

 asendada predikaadi rakendamisega.
\end_layout

\begin_layout Paragraph
Syntax mis sisab väitele jaatuse üle predikaatide
\end_layout

\begin_layout Paragraph
mingid konstantsed funktsioonid, mille abil saab kõik väite kõigi argumentide
 korral kirjeldada, mida interpreteeitakse eeldatava väitega, mis sisaldab
 jaatust üle kõigi kvantorite
\end_layout

\begin_layout Standard
Äkki võrdusmärgist piisab? Näiteks hulkade puhul: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall("onhulk"(x_1)
\backslash
land 
\backslash
neg (x_2 
\backslash
in x_1) 
\backslash
to 
\backslash
exists("onhulk"(x_3)
\backslash
land (x_2 
\backslash
in x_3) 
\backslash
land 
\backslash
forall(x_4!=x_2 
\backslash
to(x_4 
\backslash
in x_1 
\backslash
leftrightarrow x_4 
\backslash
in x_3)))))
\backslash
land 
\backslash
exists("onhulk"(x_1)
\backslash
land 
\backslash
forall(
\backslash
neg(x_2 
\backslash
in x_1)))$
\end_layout

\end_inset

 või
\begin_inset Newline newline
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall("onhulk"(x_1)
\backslash
land 
\backslash
exists("onhulk"(x_3) 
\backslash
land 
\backslash
forall(x_4=x_2 
\backslash
neg 
\backslash
leftrightarrow (x_4 
\backslash
in x_1  
\backslash
leftrightarrow x_4 
\backslash
in x_3)))))
\backslash
land 
\backslash
exists("onhulk"(x_1)) 
\backslash
land 
\backslash
forall(
\backslash
forall("onhulk"(x_1)
\backslash
land "onhulk"(x_2)
\backslash
to (x_1=x_2 
\backslash
leftrightarrow 
\backslash
forall(x_3 
\backslash
in x_1 
\backslash
leftrightarrow x_3 
\backslash
in x_2))))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Kas see loendumatude hulkade puhul kehtib? Vaja on põhjendust, et iga väite
 puhul piisab võrdusmägist, et väite kuju ei sõltuks elementaarseoste valikust.
\end_layout

\begin_layout Paragraph
mingid konstantsed funktsioonid, mille abil saab kõik väite kõigi argumentide
 korral kirjeldada, mida programm predikaatide lisamisel automaatselt täiendab
\end_layout

\begin_layout Standard
Äkki võrdusmärgist piisab?
\end_layout

\begin_layout Standard
Äkki piisab funktsioonist L, mapib kõigi predikaatide väärtused, kui nende
 argumentideks on kõik erinevad variatsioonid ülejäänud L'i argumentidest,
 mis sisaldavad (vähemalt 1 korra) L'i esimest argumenti, naturaalarvudele.
 Hulkade(ja ühe argumndiliste funktsioonide, mis tagastavad booleane) puhul
 näiteks: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Pi_{b=0}^{2^{H(a)}}(
\backslash
forall_{Ax}(
\backslash
exists_Y(
\backslash
sum_{i=0}^{H(A)}(L(Y,x,x..x)=i
\backslash
land b[i]))
\backslash
to 
\backslash
exists_{x_h}("onhulk"(x_h)
\backslash
land 
\backslash
forall_e(
\backslash
sum_{i=0}^{H(A)}(L(e,x,x..x)=i
\backslash
land b[i])
\backslash
leftrightarrow(e
\backslash
in x_h)))))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A on predikaadi, millel on kõige rohkem argumente, argumentide arv.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_{Ax}$
\end_layout

\end_inset

 tähendab A kvantorit
\end_layout

\begin_layout Standard
või lausa:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Pi_{b=0}^{2^{H(a)}}(
\backslash
forall_{Ax}(
\backslash
exists_{x_h}("onhulk"(x_h)
\backslash
land 
\backslash
forall_e(
\backslash
sum_{i=0}^{H(A)}(L(e,x,x..x)=i
\backslash
land b[i])
\backslash
leftrightarrow(e
\backslash
in x_h)))))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
võrdusmärgi korral: _.._
\end_layout

\begin_layout Standard
kõik need väited saab teadaolevate predikaatide abil kirja panna nii, et
 jaatus üle b'de, võitus üle i'de ja funktsioon L jäävad ära.
\end_layout

\begin_layout Subsection
Elementaarseosed eraldi
\end_layout

\begin_layout Standard
Sama argumentide arvuga elementaarseoseid võib olla mitu.
\end_layout

\begin_layout Subsection
Iga argumentide arvu jaoks üks elementaarseos
\end_layout

\begin_layout Standard
Kirjeldada kõiki võrdsete argumentidega elementaarväiteid ühe elementaarseosega
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_Q(kvanteeritavad)$
\end_layout

\end_inset

.
 Tuleb otsustada, et kas seosefunktsiooni väärtus sõltub argumentide järjekorras
t.
 Kirjeldatavast väitest sõltub, et kui paljude argumentidega seosefunktsioone
 on ja, et kui palju on elementaarseosetel võimalikke väärtusi.
\end_layout

\begin_layout Standard
Et konverteerida väide notatsioonist 
\begin_inset Quotes eld
\end_inset

Elementaarseosed eraldi
\begin_inset Quotes erd
\end_inset

 notatsiooni 
\begin_inset Quotes eld
\end_inset

Iga argumentide arvu jaoks üks elementaarseos
\begin_inset Quotes erd
\end_inset

 tuleb tuleb uued elementaarseosed viia bijektiivsesse sõltuvusse kõigi
 vanade võrdsete argumentide arvuga elementaarseoste väärtustega.
\end_layout

\begin_layout Standard
Kui selle funktsiooni tagastatavad väärtusi tõlgendada naturaalarvudena
 ei ole probleemiks, et väites ei ole veel naturaalarve defineeritud, sest
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_Q$
\end_layout

\end_inset

 tagastavatele elementidele ei ole vaja rakendada naturaalarvude kohta käivaid
 aksioome.
\end_layout

\begin_layout Subsubsection
täpsemad stanardid
\end_layout

\begin_layout Standard
Seosefunktsiooni väärtus ei sõltu argumentide järjekorrast.
 Ei täpsusta et kui paljude argumentidega seosefunktsioone on ja, et kui
 palju on seosefunktsioonidel võimalikke väärtusi.
\end_layout

\begin_layout Standard
Kui selle funktsiooni tagastatavad väärtusi tõlgendada naturaalarvudena
 ei ole probleemiks, et väites ei ole veel naturaalarve defineeritud, sest
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_Q$
\end_layout

\end_inset

 tagastavatele elementidele ei ole vaja rakendada naturaalarvude kohta käivaid
 aksioome.
\end_layout

\begin_layout Section
Elemendi põhine ehk argumendiks on algasjad
\end_layout

\begin_layout Standard

\color green
kõikide argumentide arvudega seosefunktsioonid saab lihtsalt panna kirja
 kahe argumendiga seosefunktsioonidega.
 lihtsalt võtta uus kvanteeritav ja siduda kõik algse seosefunktsiooni argumendi
d sellega uue 2 argumendise seosefunktsiooni abil.
 nt 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_{mingi}(a,b,c)=
\backslash
exists_x(f(x,mingi),f(x,a),f(x,b),f(x,c))$
\end_layout

\end_inset

.
 Mitmeargumendiliste seosefunktsioonide puhul see ei kehti.
\end_layout

\begin_layout Standard

\color yellow
(Kas tohib teha väiteid konstantsete elementaarseoste kohta)
\end_layout

\begin_layout LyX-Code
Selles notatsioonis on väite argumentideks algasjad ehk algmõisted, mida
 lisaks kvanteeritavatele elementaarseostele rakendatakse.
 Elementaarseoste omadused ei sõltu kirjeldatavast väitest ega selle argumentide
st.
 
\color yellow
(Kas peab olema kõigi erinevate argumentide arvudega elementaarfunktsioone?)
\color inherit
 Kuna kõigi asjade vahelised väited on kindlaksmääratud omadustega elementaarseo
ste abil defineeritud saab eeldada, et kõik asjad on mingit kindlat tüüpi
 elmendid.
 Elementide tüübi määrab see ,et millised omadused on neil kindlaks määratud
 elementaarseostel.
 
\color yellow
(Mõistlik on ilmselt valida konsantsetele elementaarseostele nii karmid
 tingimused kui võimalik, aga nii, et kõiki väiteid saaks siiski teha)
\end_layout

\begin_layout Standard
Selle notatsiooni halvaks küljeks on, et tekib mitmeid väiteid, mida on
 raske tõlgendada nt g(+,+,*) või g(>,>).
\end_layout

\begin_layout Standard
Näiteks elementaarsuhte 
\begin_inset Quotes eld
\end_inset

x on null
\begin_inset Quotes eld
\end_inset

 konverteerimiseks elementaarseosepõhisest notatsioonist elemendipõhiseks
 tuleb elementaarfunktsiooni on_null(x_1) asemel võtta algasi 0.
\end_layout

\begin_layout Standard
Notatsiooni heaks küljeks on, et saab eemaldada algmõisteid väitest.
 Näiteks kui algmõiste A4 on defineeritud algmõiste A3 kaudu, algmõiste
 34 on defineeritud algmõiste A2 kaudu ja algmõiste A2 on defineeritud algmõiste
 A1 kaudu, siis saab eemaldada väitest algmõisted A3 ja A2 pannes väite
 ümber(ette) eksistentsiaalkvantorid 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{A3}$
\end_layout

\end_inset

 ja 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{A4}$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Näiteks elementaarsuhte 
\begin_inset Quotes eld
\end_inset

a+b=c
\begin_inset Quotes eld
\end_inset

 konverteerimiseks elementaarseosepõhisest notatsioonist elemendipõhiseks
 tuleb elementaarfunktsiooni 
\begin_inset Quotes eld
\end_inset

x_1+x_2=x_3
\begin_inset Quotes erd
\end_inset

(x_1,x_2,x_3) võtta algasi + nii, et konstantne elemetaarfunktsioon g(+,x_1,x_2,
x_3) on kindla väärtusega siis kui x_1+x_2=x_3.
\end_layout

\begin_layout Standard
Tähistame elemente, mille vahelistes suhetes on a elementi ja on b erinevat
 võimalikku suhet järgnevalt: element(a,b).
 Selles tähistuses oleks hulgad tähistatud kui element(2,4).
 Näiteks erinevus hulkade ja elementide(2,2) vahel on, et kui kaks hulka
 võivad omavahel olla 4 erinevas suhtes, siis 2 elementi võivad omavahel
 olla 2´es suhtes.
 Hulkadeks võivad olla ka kvanteeritavad.
 Selle notatsiooni halvaks küljeks on, et see on vähem tuntud.
 Kui a ja b pole naturaalarvud, siis on elementide vahelised suhted üksteisest
 sõltuvad.
 Suhe ei tähenda siin jagatist.
\end_layout

\begin_layout Standard
Elemendi-põhises-notatsioonis võib ka muude asjade vahel olla kvantoritega
 väiteid, kuid muuks asjaks loetakse ikkagi K´d kvanteeritavat, mille kohta
 käib, nende omavahelisi suhteid ja nende suhteid algelementidega iseloomustav,
 kvantoreid sisaldav booleanfunktsioon.
 Kuna osadest asjadest(K´st kvanteeritavast, mille vahel on kvantoritega
 seosed) järeldub väiteid teiste muude asjade kohta, siis ei pruugi 
\begin_inset ERT
status open

\begin_layout Plain Layout

$F_Q$
\end_layout

\end_inset

´l olla naturaalarv võimalikke väärtusi.
\end_layout

\begin_layout Standard
Sellises notatsioonis kirjutatud väidete iseloomustamiseks saab kasutada
 arv K ja N.
 K ja N on üheselt seotud asjade arvuga, mille eksisteerimise vahelist boolean
 funktsiooni väide kirjeldab.
\end_layout

\begin_layout Itemize
N on algelementide arv.
\end_layout

\begin_layout Itemize
K näitab, et kui mitme kvantori sees üks predikaatväide maksimaalselt on,
 kui väide on pandud kirja sellisel kujul, et predikaatväide, mis kõige
 rohkemate kvanorite sees olev väide on, oleks võimalikult väheste kvantorite
 sees.
\end_layout

\begin_layout Standard
Osade väidete konverteerimisel elemendipõhiseks ei pruugi K ja N olla naturaalar
vud.
\end_layout

\begin_layout Subsection
element(2,4)´e-põhine-notatsioon ehk hulga-põhine-notatsioon (Pole kindel
 kas toimib)
\end_layout

\begin_layout Standard
Hulga-põhises-notatsioonis on väite argument on noteeritud argument-hulkade(algh
ulkade) abil ja muid asju hulkade abil, mida iseloomustab nende omavahelised
 kuuluvus-sisaldumis suhted ning kuulumis-sisaldumissuhted nende ja alghulkade
 vahel.
 Et hulk A kuulub hulka B tähitatakse 
\begin_inset ERT
status open

\begin_layout Plain Layout

$A
\backslash
in B$
\end_layout

\end_inset

.
 Selle hulga-põhise notatsiooni saab teisenda funktsioonipõhiseks teades,
 et ühe hulga kuuluvusuhteks n hulgaga on 
\begin_inset ERT
status open

\begin_layout Plain Layout

$2^{n*4}$
\end_layout

\end_inset

 võimalust.
 Selleks tuleb viia iga hulkade vahelise kuuluvuse booleankombinatsioon
 vastavusse ühe funktsiooni 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_Q$
\end_layout

\end_inset

 väärtusega saades funktsiooni, millel on 
\begin_inset ERT
status open

\begin_layout Plain Layout

$2^{n*4}$
\end_layout

\end_inset

 erinevat väärtust.
 
\end_layout

\begin_layout Standard
Selle notatsiooni eeliseks hulga-põhise-notatsiooni ees on, et väidete kirjeldam
isel DNF tabelina tekib vähem mõtetuid ridu.
\end_layout

\begin_layout Standard
Näiteks hulga-põhises-notatsioonis kirjeldatud väite 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_x(
\backslash
forall_y(
\backslash
neg 
\backslash
forall_z(z 
\backslash
in x 
\backslash
iff z 
\backslash
in y) 
\backslash
wedge x 
\backslash
in y 
\backslash
to y 
\backslash
in A)$
\end_layout

\end_inset

 ( A'sse kuuluvad kõik hulgad, mis sisaldavad mingit hulka peale iseenda)
 K=3 ja N=1.
\end_layout

\begin_layout Subsubsection
konstantväide
\end_layout

\begin_layout Standard
Hulgad, mille elemendid on samad on ise samade asjade elemendid.
 ehk sama sisaldavusega hulgad on ka sama sisaldamisega ja, et hulgad, mis
 sisaldavad samu elemente on võrdsed.
\end_layout

\begin_layout Subsection
element(2,2)´e-põhine-notatsioon (Pole kindel kas toimib)
\end_layout

\begin_layout Standard
Elementidest(2,2) või mõelda kui 
\begin_inset Quotes eld
\end_inset

asjadest
\begin_inset Quotes erd
\end_inset

, mis ei saa midagi sisaldada, kuid saavad omavahel 
\begin_inset Quotes eld
\end_inset

ühendatud
\begin_inset Quotes erd
\end_inset

 olla.
\end_layout

\begin_layout Standard
Üks võimalus konvertida hulkade-notatsiooni olev väide nende element(2,2)ede
 vahelises notatsiooni olevak väiteks, on asendada iga hulk kahe element(2,2)´
 ga.
 Nimetame neid kahte element(2,2)´esid kuulumis ja sisaldumis elementideks.
 Kui hulga-põhises-notatsioonis sisaldab mingi hulk mingit teist hulka,
 siis elemendi-põhisesse-notatsiooni on esimese hulga sisaldamiselement
 ühenduses teise hulga kuulumiselemendiga.
 Kui hulgapõhises-notatsioonis sisaldab mingi hulk iseenneast, siis elemendipõhi
ses notatsioonis on sellele hulgale vastav kuulumiselement ja sisaldumiselement
 omavahel ühenduses.
 Veel tuleb elemendi-põhisesse-notatsiooni lidada väide, et ükski kuuluvus-eleme
nt ei ole ühegi kuuluvus-elemendiga ühenduses ja ükski sisalduvus-element
 ei ole ühegi sisalduvus-elemendiga ühenduses.
 Selline konvertimine ei ole kõige efektiivsem, sest saaks konvertida ka
 nii, et tekiks vähem elemente.
\end_layout

\begin_layout Subsection
element(e,e)-põhine-notatsioon(Pole kindel kas toimib)
\end_layout

\begin_layout Subsection
algmõisteteks predikaadi
\end_layout

\begin_layout Standard
kasutaja saab algmõistetena ainult predikaate lisada.
 Selle eeliseks on, et ei pea ühtegi väidet kirjeldama erinevalt sõltuvalt
 väites olevate predikaatide valikust.
\end_layout

\begin_layout Standard
konstantseteks elementaarfunktsioonideks on:
\end_layout

\begin_layout Itemize
rakenda(predikaat,järjend) tagastab kas predikaat on True/False kui selle
 argumendiks on järjendis olevad asjad.
\end_layout

\begin_layout Itemize
järjekord(järjend,x1,x2) tagastab, et kas x1 on x2'est järjendis eespool
 või tagapool.
\end_layout

\begin_layout Standard
Eriti stiili lisab, et kvantor oleks justkui 1 argumendiline elementaarseos
 ja kui rakenda argumendid on väited, siis võib neid tõlgendada NAND'ina,
 mis annavad kvantorifunktsionaalselt täieliku hulga.
\end_layout

\begin_layout Standard
Kvanteeritavad peavad saama olla predikaadid, sest muidu sõltuks ikkagi
 osade väidete kuju predikaatide valikust.
 p(x) asemele tuleb p([x]).
\begin_inset Newline newline
\end_inset

Lõppridade üheselt valesuse kontroll peaks samasugune tulema, sest kõigi
 platode predikaatide osa saab lihtsalt asenada rakenda(P,x)'iga.
\end_layout

\begin_layout Standard
Tuleb lisada konstantne väide.
\end_layout

\begin_layout Subsubsection
konstantne väide
\end_layout

\begin_layout Standard
järjekord on transitiivne.
 kui x1 või x2 ei kuulu järejendisse on tagastab elementaarseos järjekord
 False.
 Ükski järjen ei kuulu ühegisse järjendisse.
 iga järjendi plato eelaste järjekord ja kuulumine sellesse järjendisse
 on määratud selles platos.
\end_layout

\begin_layout Standard
kui rakena esimene argument ei ole predikaat, siis on rakenda alati False.
\end_layout

\begin_layout Subsection
eeldused seosefunktsioonidele
\end_layout

\begin_layout Standard
2 võimalikku väärtust (kas True või False).
 Algmõisted pannakse ainult esimeseks argumendiks (See ei ole sama, mis
 eeldus, et kui algmõiste ei ole ei ole esimene argument, siis on elementaarseos
 üheselt vale, sest kuna kvantorid peavad kõigi asjade kohta kehtima peavad
 need ka algmõistete kohta kehtima.
 Ka kvanteeritavad võivad almõistetega võrdsed olla.)
\end_layout

\begin_layout Section
näiteid notatsiooni konverteerimisest.
\end_layout

\begin_layout Subsection
elemendi põhisest elementaarseose põhiseks
\end_layout

\begin_layout Standard
Niipidi saab alati konverteerida.
\end_layout

\begin_layout Standard
algasi A asemel võta elementaarseos 
\begin_inset Quotes eld
\end_inset

x_on_A
\begin_inset Quotes erd
\end_inset

 ja lisa väitele väide, et ainult 1 asi rahuldab seda (kui kaks kvanteeritavat
 seda rahuldavad, siis on nad vürdsed.).
\end_layout

\begin_layout Standard
Luua uuued prediakaadid, mis tähistavad predikaadi väärtust, kui nende argumenti
deks on algasjad.
 Näiteks: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_{x_1}(
\backslash
forall_{x_2}(F(a,x_1,x_2)=F_1(x_1,x_2) 
\backslash
land F(x_1,a,x_2)=F_2(x_1,x_2) 
\backslash
land F(x_1,x_2,a)=F_3(x_1,x_2)))$
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
elementaarseose põhisest elemendi põhiseks
\end_layout

\begin_layout Standard
Iga elementaarseoses põhises notatsioonis kirjeldatud väidet ei saa igattüüpi
 (tüüp näitab millised on konstantsed funktsioonid) elemendipõhiseks konverteeri
da.
 Näiteks ei saa 3 argumendilise predikaadiga väiteid konverteerida element(2,2)
 põhiseks konverteerida.
 Uurida, et millise elemendipõhiseks saab iga elemetaarseosepõhist väidet
 konverteerida.
\end_layout

\begin_layout Standard
n argumendise elementaarseose f_1 asemele pane algasi, millega mingis elementaar
seoses olevad asjad on ainult n'i teise asjaga elementaarseoses(eeldab,
 et elemendi(a,b) a>n).
\end_layout

\begin_layout Standard

\color red
Vist ei saa alati, sest konstantse elementaarsesest argumentide arvust suurema
 argumentide arvuga predikaate konverteerida hulgapõhiseks.
\end_layout

\begin_layout Standard
Vist ikka saab: pannes argumendidjärjendisse ja kirjeldada järjendi elementide
 arv võrreldes elementide järjekorda järjendis elementide järjekorraga paarides.
 Selleks on vaja kahte 2 argumendilist seosefunktsiooni f1 ja f2.
 näiteks:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$F(a,b,c,d)
\backslash
iff 
\backslash
exists_{x_1}(f_1(a,x_1)
\backslash
land f_1(b,x_1)
\backslash
land f_1(c,x_1)
\backslash
land f_1(d,x_2)
\backslash
land
\end_layout

\begin_layout Plain Layout


\backslash
exists_{x_2} (f_1(a,x_2) 
\backslash
land f_2(b,x_2) 
\backslash
land samajarjekord(x_1,x_2))
\end_layout

\begin_layout Plain Layout


\backslash
exists_{x_2} (f_1(b,x_2) 
\backslash
land f_2(c,x_2) 
\backslash
land samajarjekord(x_1,x_2))
\end_layout

\begin_layout Plain Layout


\backslash
exists_{x_2} (f_1(c,x_2) 
\backslash
land f_2(d,x_2) 
\backslash
land samajarjekord(x_1,x_2))
\end_layout

\begin_layout Plain Layout

)$
\end_layout

\end_inset


\end_layout

\begin_layout Part
Ideid funktsiooni F defineerimiseks
\end_layout

\begin_layout Section
Funktsioonide F tüüp a
\end_layout

\begin_layout Paragraph
definitsioon:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$F(S)=P(S,K(S)) 
\backslash
land 
\backslash
forall_s(
\backslash
forall_k(P(s,k)=
\backslash
sum_{i=0}(2^i*(False 
\backslash
not =(S 
\backslash
land P(i))))$
\end_layout

\end_inset

pole valmis
\end_layout

\begin_layout Paragraph
pöördfunktsioon:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_{n_S}(f(n_S) 
\backslash
leftrightarrow 
\backslash
exists_i(plato(i,0,[]) 
\backslash
land lopprea
\backslash
_mark(n_S,i))) 
\backslash
land 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout


\backslash
forall_n(
\backslash
forall_k (
\backslash
forall_{kv}(plato(n_s,k,kv) 
\backslash
leftrightarrow
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

(h(n,kv) 
\backslash
land 
\backslash
forall_i((i 
\backslash
in N 
\backslash
land(i<veerge(k)))
\backslash
to(
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

saa
\backslash
_haru
\backslash
_märk(n,i) 
\backslash
leftrightarrow 
\backslash
exists_x(plato(i,k+1,kv+x)))))$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Lühikirjeldus:
\end_layout

\begin_layout Standard
Saa_h kirjeldab anud taseme kvanteeritava elementaarseoseid madalamate tasemete
 kvanteeritavatega.
\end_layout

\begin_layout Standard
Seda tüüpi funktsioond on kõik funktsioonid, mis eeltoodud kujul on.
 Ükskõik millised saa_h ja saa_haru_märk täpselt on, on sellises vormis
 funktsioon a tüüpi funktsioon.
 
\color yellow
(kas kõik võimalikud F funktsioonid, mille abil saab kõiki väiteid töödelda
 mitte a-tüüpi ei ole? vt section struktuur.
 Vist ei ole, kuid iga funktsioon, mis seab lõppreale arvu vastavusse on
 a- tüüpi funktsioon)
\end_layout

\begin_layout Standard
See, et kas läheb vaja tingimst 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(i 
\backslash
in N 
\backslash
land(i<veerge(k)))$
\end_layout

\end_inset

 sõltub funktsioonide h ja saahrumärk valikust.
\end_layout

\begin_layout Subsection
K ja predikaadide nimetuste n_S'i panemine
\end_layout

\begin_layout Paragraph
idee1
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

 binaarvormi alguses on nii palju 1esid järjest kui on K väärtus.
 peale neid ühtesid tuleb 0 ja siis ülejäänud osa n_S'ist.
 See poleks enam min vabadusastme(F pole bijektiivne), sest täheduseta on
 need n_Sid kus 0ile järnev arv on suurem kui antud K ja prdikaatie korral
 ülejäänud n_S osa olla saab.
 predikaadide kirjeldused peavad olema väitega koos mingi muus vorms(tõenäolisel
t stringina).
\end_layout

\begin_layout Standard
Panna alati 1 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

 ette.
 Siis on järelolevate bittide arvu järgi K teada kui predikaatide argumentide
 arv on teada.
 Binaarsalvetuses piisab ees olevate nullide arvu teadmisest.
\end_layout

\begin_layout Subsection
Lihtne DNF
\end_layout

\begin_layout Paragraph
definitsioon:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$F(S)=$
\end_layout

\end_inset

pole valmis
\end_layout

\begin_layout Paragraph
pöördfunktsioon:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_{n_S}(f(n_S) 
\backslash
leftrightarrow 
\backslash
exists_i(plato(i,0,[]) 
\backslash
land (
\backslash
lfloor n_S*2^{-i} 
\backslash
rfloor 
\backslash
%2=1))) 
\backslash
land 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout


\backslash
forall_n(
\backslash
forall_k (
\backslash
forall_{kv}(plato(n,k,kv) 
\backslash
leftrightarrow
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

(h(n,kv) 
\backslash
land 
\backslash
forall_i((i 
\backslash
in N 
\backslash
land(i<veerge(k)))
\backslash
to(
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

( 
\backslash
lfloor n*2^{-i} 
\backslash
rfloor 
\backslash
%2=1) 
\backslash
leftrightarrow 
\backslash
exists_x(plato(i,k+1,kv+x)))))
\backslash
land 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_k(veerge(k)=H(k+1)*2^{veerge(k+1)})
\backslash
land 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

veerge(K)=0
\backslash
land 
\backslash

\backslash
 veerge(k)=H(k+1)*2^{veerge(k+1)}$
\end_layout

\end_inset

pole valmis
\end_layout

\begin_layout Paragraph
omadused:
\end_layout

\begin_layout Itemize
osadele väärtustele 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

 vastavad samad väited.
\end_layout

\begin_layout Itemize
Raske loetavasse vormi panna, sest üheselt samaväärsete lõppridade tuvastamine
 on raske.
\end_layout

\begin_layout Paragraph
Lühikirjeldus:
\end_layout

\begin_layout Standard
a tüüpi, funktsioon, kus 
\begin_inset ERT
status open

\begin_layout Plain Layout

$harummärk(x,k)$
\end_layout

\end_inset

 ja 
\begin_inset ERT
status open

\begin_layout Plain Layout

$ saa
\backslash
_h(x,k)$
\end_layout

\end_inset

 on sellised, et:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
begin{cases}
\end_layout

\begin_layout Plain Layout

loppreamark(n,i)=(
\backslash
lfloor n*2^{-i} 
\backslash
rfloor 
\backslash
%2=1)
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

harummark(n,i)=(
\backslash
lfloor n*2^{-i} 
\backslash
rfloor 
\backslash
%2=1)
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

saah(k)=
\backslash
lfloor n_s*2^{-veerge(k)} 
\backslash
rfloor 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

veerge(k)=H(k+1)*2^{veerge(k+1)}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

veerge(K)=0
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
end{cases}$
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$H(k)$
\end_layout

\end_inset

 näitab , et kui mitmes erinevas seoses saab k'nda taseme kvanteeritav 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_k$
\end_layout

\end_inset

 enda ja endast madalamate kvanteeritavatega olla.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$H(0)=0$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
veerge(k) näitab, et mitu haru on k'ndal tasemel.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
funktsiooni harumärk saab kirja panna ka järgnevatel kujudel 
\begin_inset ERT
status open

\begin_layout Plain Layout

$harummark(n,i)=((n-n 
\backslash
%2^{i})*2^{-i} 
\backslash
%2 =1)$
\end_layout

\end_inset

 ; 
\begin_inset ERT
status open

\begin_layout Plain Layout

$harummark(n,i)=((n-n 
\backslash
%2^{i}) 
\backslash
%2^{i+1} 
\backslash
not =0)$
\end_layout

\end_inset

 ; 
\begin_inset ERT
status open

\begin_layout Plain Layout

$harummark(n,i)=
\backslash
exists_{x_1}(x_1
\backslash
in N 
\backslash
land 
\backslash
exists_{x_2}(x_2
\backslash
in N 
\backslash
land x_2<2^i
\backslash
land n=x_1*2^{i+1}+2^{i}+x_2))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Taseme K sees olevad harud võib tähelepanuta jätta, sest need(koos märgiga)
 on üheselt tõesed 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg 
\backslash
exists_x(False)$
\end_layout

\end_inset

, sest harumärk(x,K)=0, kui x>0 ja saaH(K+1)=lõpmatus.
\end_layout

\begin_layout Standard
Idee põhineb tähelepanekul, et kui
\end_layout

\begin_layout Enumerate
kõik universaalsuskvantorid asendada eksistentsaalsuskvantoritega vastavalt
 reeglile 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_x(f(x))=
\backslash
neg 
\backslash
exists_x(
\backslash
neg f(x))$
\end_layout

\end_inset

,
\end_layout

\begin_layout Enumerate
viia kõik seosefunktsioonide väited kõige välimiste võimalike kvantorite
 sisse (Ehk võimalikest madalaimale tasemele)(ehk selle kõrgeima taseme
 argumendi tasemele)(sest muidu tekiks mitu samaväärst rida.
 nt.
 _..._ .)
\end_layout

\begin_layout Enumerate
viia kõik kvantorite sisud ja kvantorite välised väited DNF-vormi (kus on
 alati jaatatud kõikide erinevate argumentidega seosefunktsioonid(näiteks
 kui K=2 ja seosefunktsiooni argumentide järjekord pole oluline, kõigil
 elementaarseostel on 2 argumenti ja 3 võimalikku väärtust tuleb 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f(x_1,x_1)=0 
\backslash
wedge f(x_1,x_2)=0$
\end_layout

\end_inset

 asendada 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f(x_1,x_1)=0 
\backslash
wedge f(x_1,x_2)=0 
\backslash
wedge f(x_2,x_2)=0 
\backslash
lor f(x_1,x_1)=0 
\backslash
wedge f(x_1,x_2)=0 
\backslash
wedge f(x_2,x_2)=1$
\end_layout

\end_inset

))
\begin_inset Newline newline
\end_inset

ja _.._(täpsemat seletus vaja)
\end_layout

\begin_layout Enumerate
kõik võitused vastavalt reeglile 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(f_1(x) 
\backslash
lor f_2(x))=
\backslash
exists(f_1(x)) 
\backslash
lor 
\backslash
exists(f_2(x))$
\end_layout

\end_inset

 kvantorite seest välja tuua.
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
saab mistahes väite vormi viia, mis sisaldab mingi sisuga omavahel võitatud
 üksteist välistavaid väiteid(lõppridu)(mille sees on ainult seosefunktsioonid,
 jaatused ja eitused), millele saab vastvusse panna naturaalarvu.
 Nimetame neid väiteid edaspidi lõppridadeks.
 Osad lõppread on üheselt valed ehk väite argumendst sõltumatult valed.
 Kõik lõppread, mis pole väite argumendst sõltumatult valed on omavahel
 erinevad.
\end_layout

\begin_layout Standard
Võib jääda ekslik arvamus, et kui defineerida kõik elementaarseosed olema
 K argumendiga ja jaatatada väitega väide, et osade elementaarseoste väärtus
 ei sõltu osadel posotsioonidel olevatest argumentidest, siis vastaks ka
 järjestuses igale naturaalarvule vahemikus 0 kuni N_max erinev lõpprida,
 kuid see ei ole võimalik, sest väide et osade elementaarseoste väärtus
 ei sõltu osadel posotsioonidel olevatest argumentidest sisaldab rohkem
 kui K'd kvanteeritavat üksteise sees.
\end_layout

\begin_layout Standard
Millisele lõppreale milline naturaalarv vastab sõltub ainult K'st, elementaarseo
ste argumentide arvudest ja seosefunktsiooni võimalike väärtuste arvust.
 Seega saab väite üheselt kirjeldada kirjeldades, et millistele naturaalarvudele
 vastavad lõppread on kirjeldatava väitega kooskõlas.
 Kirjeldamaks, et millised lõppread on kirjeldatava väitega kooskõlas moodustan
 jada(ehk lõppveeru), mille liikmeteks on (boolean), et kas liikme indeksile(nat
uraalarvule) vastav lõpprida on väitega kooskõlas.
 Lõppveerg tõlgendatult kahendsüsteemis arvuna ongi arv 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_s$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
K ja elementaarseoste argumentide ja võimalike väärtuste arv ning muud omadused
 on eraldi kirjeldatud või bijektiivse funktsiooni abil lisatud arvule 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Seletan siin mitmes lõigus sama ideed.
 Kõikides lõikudes on sama ideed erinevalt kirjeldatud.
\end_layout

\begin_layout Subsubsection
Seletus 1
\end_layout

\begin_layout Standard
Iga taseme jaoks teha eraldi DNFtabel, mille veergudeks on selle taseme
 veerge moodustava tabeli read.
 Taseme-veerge moodustava tabeli veergudeks on selle taseme kvanteeritava
 ja madlamata kvanteeritavate ning selle taseme kvanteeritava ja algasjade
 vahelisel seosefunktsiooni väärtused.
 Taseme-veerge moodustavat tabelit loetakse jaatades väiteid, et veeru seosefunk
tsioonil on vastav väärtus.
\end_layout

\begin_layout Standard
Iga taseme tabeli igas reas on iga veeru jaoks lahter arvuga, mis kirjeldab,
 et milliseid järgmise taseme ridu sisaldavad selle taseme kvantorid on
 omavahelises jaatuses eitatud ja millised mitte(so.
 DNF vorm).
 Iga erinevate arvudega täidetud ridu on täpselt üks.
 Kõrgeima taseme tabeli(mille number=K) ridades on iga veeru kohta ainult
 üks arv(boolen), mis kirjeldab ainult, et kas veerg on eitatud või mitte,
 sest pole järgmist taset, ega järgmise taseme ridu.
 Madalaima taseme tabeli(mille number=0) veergudeks on algasjade vaheliste
 seosefunktsioonide väärtused.
 Madalaima taseme tabel on lõppDNF-tabel, mille read on lõppread, tabeli
 lõppveerg on töödeldud DNF vormis väite lõppveerg.
\end_layout

\begin_layout Subsubsection
Seletus hargnemisega
\end_layout

\begin_layout Standard
Iga taseme jaoks teha eraldi DNFtabel, mille veerutüvedeks on selle taseme-veerg
e moodustava tabeli read.
 Iga taseme tabeli iga veerutüvi hargneb veergudeks, mis erinevad selle
 poolest, et millist järgmise(ühe võrra suurema) taseme tabeli rida selle
 taseme kvantor sisaldab.
 Iga veeru(haru) ümber on eraldi selle taseme eksistentsiaalkvantor.
\end_layout

\begin_layout Standard
Taseme-veerge moodustava tabeli veergudeks on selle taseme kvanteeritava
 ja madalamata kvanteeritavate ning selle taseme kvanteeritava ja algasjade
 vahelise seosefunktsiooni väärtus.
 Kui palju erinevaid vääruseid ühel seosefunktsioonil võib olla sõltub kirjeldat
avast väitest.
 Seosefunktsiooni argumentideks võivad olla ainult kvanteeritavad ja algasjad.
 Seosefunktsioonil võib olla ükskõik kui palju argumente.
 Taseme-veerge moodustavat tabeli ridu loetakse jaatades väiteid, et veergude
 seosefunktsioonidel on vastavad väärtused.
 Kui seosefunktsiooni argumentide järjekord on oluline tuleb igas tasemes
 panna argumendid kõigis järjekordades.
\end_layout

\begin_layout Standard
Kõik veergude vahelised seosed võib arvesse võtta arvestades, et osade tasemete
 tabelite osad read on väite argumendst sõltumatult valed.
 DNF tabeli olemuse tõttu lõppridade vahelisi seoseid ei ole.
 Kas rida on väite argumendst sõltumatult vale kontrollimiseks tuleb kõrgema
 taseme kvanteeritava asemele asendada madalama taseme kvanteeritavad.
\end_layout

\begin_layout Standard
Kõrgeima taseme tabeli(mille number=K) veerud ei hargne, sest pole järgmist
 taset, ega järgmise taseme ridu.
 Madalaima taseme tabeli(mille number=0) veergudeks on algasjade vaheliste
 seosefunktsioonide väärtused.
 Madalaima taseme tabel on lõppDNF-tabel, mille read on lõppread, tabeli
 lõppveerg on töödeldud DNF vormis väite lõppveerg.
 
\end_layout

\begin_layout Standard
Kuna kõik tabelid on DNF tabelid, siis:(VALE)
\end_layout

\begin_layout Itemize
Iga taseme tabeli igas reas on iga veeru kohta üks bitt, mis kirjeldab,
 et kas veerg (mille sees on selle taseme kvantor) on rea siseses jaatuses
 eitatud ja või mitte(so.
 DNF vorm).
\end_layout

\begin_layout Itemize
Iga erinevate bittidega täidetud ridu on täpselt üks.
\end_layout

\begin_layout Itemize
read on üksteist välistavad ehk omavahel vastuolus.
\end_layout

\begin_layout Subsubsection
Seletus Ühe tabelina.
\end_layout

\begin_layout Standard
Tabelis on kõik esimese taseme veerud.
 Iga taseme kõik read lähevad iga ühe võrra madalama taseme iga veeru juurde
 alaveergudeks.
\end_layout

\begin_layout Subsubsection
Seletus ühe tabelina(ei toimi)
\end_layout

\begin_layout Standard
Veergudeks on eksistentsiaalkvantorid.
 Iga veeru, mille kvanteeritava tase ei ole K, sees on ühe võrra kõrgema
 taseme eksistentsiaalkvantorid.
 Iga ühe võrra madalama taseme kvantori sees on 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a(k)$
\end_layout

\end_inset

 k'nda taseme kvantorit.
 Esimese taseme kvantorid ei ole ühegi kvantori sees neid on a(k)'st tükki.
\end_layout

\begin_layout Subsubsection
Seletus ühe tabelina pöördveergudega alustades seletamist 0-tasemest.
\end_layout

\begin_layout Standard
0 taseme seosefunktsioon(seosefunktsioonid, mille argumentideks on ainult
 algasjad) on tabeli veerg.
 Iga taseme, mille number pole K, veergudeks on seosefunktsioonid, mille
 argumentideks on selle ja madalama taseme kvanteeritavad ja algasjad, ja
 kõrgema taseme read.
 Knda taseme veergudeks on ainult taseme K seosefunktsioon.
 Kuna iga taseme read ristuvad kõrgema taseme ridadega (on 90 kraadi pöördes)
 ja iga taseme veerud ristuvad kõrgema taseme veergudega (on 90 kraadi pöördes)
 nimetan seda seletust pöördveergudega seletuseks.
\end_layout

\begin_layout Subsubsection
Seletus ühe tabelina pöördveergudega alustades seletamist K-tasemest.
\end_layout

\begin_layout Standard
K taseme seosefunktsioon(seosefunktsioonid, mille argumentideks on ainult
 algasjad) on Knda taseme tabeli veerg.
 Iga taseme, mille number pole 0, read on, koos ühe võrra madalama taseme
 seosefunktsiooniga, veergudeks ühe võrra madalamale tasemele.
 0taseme seosefunktsioon on (lõpp)tabeli veerg.
 Kuna iga taseme read ristuvad kõrgema taseme ridadega (on 90 kraadi pöördes)
 ja iga taseme veerud ristuvad kõrgema taseme veergudega (on 90 kraadi pöördes)
 nimetan seda seletust pöördveergudega seletuseks.
\end_layout

\begin_layout Subsubsection
seletus
\end_layout

\begin_layout Standard
iga plato iga bitt näitab, et et kas selle biti indeksiga haru on eitatud
 või jaatatud.
\end_layout

\begin_layout Subsection
DNF, mille osad read on eemaldatud
\end_layout

\begin_layout Paragraph
definitsioon:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$F(S)=P(S,K(S)) 
\backslash
land 
\backslash
forall_s(
\backslash
forall_k(P(s,k)=
\backslash
sum_{i=0}(2^{i-
\backslash
sum_{j=0}^i(neg
\backslash
 
\backslash
exists_S(False 
\backslash
not =(S 
\backslash
land P(j))))}*(False 
\backslash
not =(S 
\backslash
land P(i))))$
\end_layout

\end_inset

pole valmis
\end_layout

\begin_layout Paragraph
pöördfunktsioon:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$f(n_S)=$
\end_layout

\end_inset

pole valmis
\end_layout

\begin_layout Paragraph
omadused:
\end_layout

\begin_layout Itemize
Raske käsitsi loetavast vormist arvutiloetavsse panna, sest üheselt valede
 lõppridade tuvastamine on raske.
\end_layout

\begin_layout Paragraph
Lühikirjeldus:
\end_layout

\begin_layout Standard
Muidu sama nagu lihtne DNF tabel ainult, et üheselt valed lõppridadele vastavad
 arvud on vahele jäätud.
 
\color yellow
(Kas jätab iga plato üheselt valed harud vahele või ainult lõpprea üheselt
 valed harud?)
\color inherit
 Ja väited, mida saab väiksema K'ga on ka vahele jäätud numeratsioonist.
 väidete, mida saab ka väiksema K'ga kirjeldada kõikide lubatud lõppridade
 taseme K-1 platode kõik harud on sama märgiga (ei ole kindel, et kõik väited,
 mida saab ka väiksema K'ga kirjeldada seda tingimust täidavad).
\end_layout

\begin_layout Standard
Numeratsioon jätab vahele need naturaalarvud, milellele vastav väide on
 sõltumatult kirjeldatavast väitest valed, kuid ei muuda seda, et millisele
 lõppreale vastab suurem arv ja millisele väiksem arv.
\end_layout

\begin_layout Standard
Lõpprida on üheselt vale kui see on kõigi väite argumentide puhul vale ehk
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg 
\backslash
exists_Q(LR(Q))$
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
väite argumendst sõltumatult valedele väidetele vastavate arvude leidmine
 ehk veergude vahelise seose arvestamine
\end_layout

\begin_layout Enumerate
eitatud harud asendatavad universaalsuskvantoritega.
 võttes harumärgi funktsiooni kujul 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_n(
\backslash
forall_k (
\backslash
forall_{kv}(plato(n,k,kv) 
\backslash
leftrightarrow
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

(h(n,kv) 
\backslash
land 
\backslash
forall_i((i 
\backslash
in N 
\backslash
land(i<veerge(k)))
\backslash
to(
\backslash

\backslash
( 
\backslash
lfloor n*2^{-i} 
\backslash
rfloor 
\backslash
%2=1) 
\backslash
to
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
exists_x(plato(i,k+1,kv+x)))) 
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_x(plato(i,k+1,kx+x)
\backslash
to
\backslash
exists_i(i 
\backslash
in N 
\backslash
land(i<veerge(k))
\backslash
land 
\backslash
lfloor n*2^{-i} 
\backslash
rfloor 
\backslash
%2=1)))))$
\end_layout

\end_inset

.
 Sellel kujul on ilmselege, et tagumisest osast ei järeldu midagi, peal
 selle, et ei eksisteeri asju, mis ei rahuldaksid tingimusi, mida rahuldavad
 asjad mis esimese osa kohaselt peavad eksisteerima.
 Kui eeldada, et kvantorist saab välja tuua ainult selle info,mis on ülejäänuga
 jaatatud, siis saab seda eeldust põhjendada sellega, et see mida saab jaatuse
 ette tuua peab kõigi harude platofunktsioonidel ühine olema, aga see info
 on ka väite esimeses eksistentsiaalkvantori-osas olemas.
 Arusaamist lihtsustab kitsam näide selest kujust 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(p_1(x_1))
\backslash
land 
\backslash
exists_{x_1}(p_2(x_1)) 
\backslash
land 
\backslash
forall_{x_1}(p_1(x_1)
\backslash
lor p_2(x_1))$
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
piisab kui kontrollida, et kõik asjad, mis peavad eksisteerima täidaksid
 kõiki tingimusi, mida kõik asjad peavad täitma.
 Kõik asjad, mis eksisteerima peavad on eksistentsiaalsuskvantorites.
 Kõik tingimused, mida asjad täitma peavad on universaalsuskvatorites.
\end_layout

\begin_layout Enumerate
Iga plato universaalsus kvantori sees on võitatud need tingimused, mis on
 selle haru eksistensaalsuskvantorite sees.
\begin_inset Newline newline
\end_inset

Plato kvanteeritava kirjeldamiseks tehtud väited kehtivad kõikjal, selle
 kvantori plato sees(sh selle kvantori sees olevate eitamata kvantorite
 sees).
 Seega kui mingi plato p haru teeb väite, mis on kvantorite, mille sees
 plato p on kvanteeritavatele seatud tingimusega vatuolus on see plato p
 väite argumendst sõltumatult vale.
 Kuna väide on sellises vormis, et kõikide võimalike tingimuste kohta on
 öeldud, et nad on kas tõesed või valed peab nende kohta olema jaatatud
 haru.
\end_layout

\begin_layout Enumerate
piisab kui kontrollida, et iga plato kvanteeritav täidab samu tingimusi
 kui iga teise plato vähemalt 1 haru.
 VIGA PARANDADA KOPEERIDA JUPPE 27.
 JUUNI JA 30.
 JUULI VERSIOONIST.
\end_layout

\begin_layout Enumerate

\series bold
Lõpprida ei ole üheselt vale parajasti siis kui mistahes(kõigi) plato(mille
 ükski haru ei ole juba võrdsustatud ja), kuhu pääseb ilma eitusi läbimata,
 (vähemalt) ühe haru(p2) (universaalsuskvantori kvanteritava) saab võrdsustada,
 mistahes teise plato(p1), kuhu pääseb ilma eitusi läbimata, kvanteeritavaga
 nii, et eelnevad võrdsustused jäävad kehtima.
\series default
\color red

\begin_inset Newline newline
\end_inset

Efektiivselt säilivad p1'ede vahelised ja p2'ede vahelised elementaarseosed
 ja elementaarseosed px'i ja madalamate eelastega.
 Tegelikult säilivad kõik elemantaarseosed, aga kui universaalsuskvantor,
 mille kvanteeritavat (p2) võrdsustatakse ise on teise universaalsuskvantori(px)
 sees, siis ei saa olla kirjeldatud elemetaarseosed tema kvanteeritavate,
 mille tase on kõrgem kui kõrgeima tasemga eksistentsaailuskvantor, mille
 sees ta on(ehk madalaima tasemega universaalsuskvantor(px), mille sees
 ta on) vahel.
 Kahe argumendiliste predikaatide korral: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_{i_1}(
\backslash
forall_{i_2}(g(P1(i_1),P1(i_2))=g(P2(i_1),P1(i_2))))$
\end_layout

\end_inset

.
 sama indeksiga p1 ja p2'e vahelinelised elementaarseosed ei pruugi olla
 samad, mis mitme selle indeksiga p1'e vaheline elementaarseos ,sest isegi
 kui mõnel p1'el ja p2'el on tavalises puugraafi visualiseeringus ühiseid
 eelasi või järglasi, on p2'ed universaalsuskvantorite kvanteeritavad ja
 p1'ed eksistentsiaalsuskvantorite kvanteeritavad ehk tegu ei ole siiski
 samade kanteeritavatega.
 Kuna p1'esid valitakse ainult platodest kuhu pääseb ilma eitusi läbimata,
 siis ei saa universallsuskvantorite seest p1'esid valida (see on selgem
 r'i vormis kus universaalsuskvantori asemel on eitatud eksistentsiaalsuskvantor
id).
 Sama p1'e(eksistentsiaalkvantori kvanteeritavat) peab saama võrdsustada
 ka mitme plato vähemalt ühe haruga.
 Võrdusustada mingit plato p2 kvateeritavat haruga ei saa kui plato p2 mingi
 haru kvanteeritava elementaarfunktsioonid on erinevad selle haru kvanteeritava
 elementaarfunktsioonidest(elementaarfunktsioonide argumentideks võivad
 olla ka madalama taseme kvanteeritavad, mis on mingi muu plato kanteeritavaga
 võrdsustatud.
 Kas ka kõrgema taseme kvanteeritavad?).
\begin_inset Newline newline
\end_inset


\color inherit
NB: kui mingid P1'ed ja neile vastavad P2'ed o juba valitud ei tohi P1'ede
 lisamine P2'esid muuta, sest muidu ei saaks kontrollid, et on olemas haru,
 millel on mitu nõutud haru.
\color red

\begin_inset Newline newline
\end_inset

Teisisõnu lõpprida on üheselt vale parajasti siis kui mingite platode (korraga),
 kuhu pääseb ilma eitusi läbimata, ühtegi haru ei saa võrdsustada, mingite
 teiste platode, kuhu pääseb ilma eitusi läbimata, kvanteeritavatega.
\begin_inset Newline newline
\end_inset

Selles meetodis võrdsustakse universaalsuskvantorite kvanteeritad teiste
 platode eksistentiaalkvantorite kvanteeritavatega.
\end_layout

\begin_layout Enumerate

\color red
Platode, millest kumbgi pole teisele eelaseks ega järglaseks kvanteeritavate
 vahelisi elementaarseoseid ei ole kirjeldatud, seega saab need korraga
 võrdsustada mingite teiste kvanteeritavatega parajasti siis kui neid saab
 eraldi võrdsustada nende teiste kvanteeritavatega.
 Et kontrollida kas mingi plato tasemega k vähemalt ühe haru kvanteeritav
 võib mitmete asjadega mitmes erinvas elementaarseoses olla (ehk, et kas
 sellel on mitu haru olemas) nii, et ka nende asjade vahelised elementarseosed
 on määratud, saab kõigepealt P1[k+1:K]'ks valida need asjad ja siis võtta
 eelmise sammu P2(k+1) selle sammu P1(k+1)'ks (vastavalt postulaadile sobib
 selle sammu P2(k+1)'ks siis ainult P1(k+1)) P1[k+1:K]'ks samuti need asjad,
 ga teistesjärjekordades.
 See toimib, sest kõik esimese sammu P2'ede vahelised elementaarseosed peavad
 olema samad kui nende asjade vahelised.
 Seega võib ÜV'd kontrollida tehes asendused(p2'ed) ühte suuatud lihtahelasse
 korraga.
 Ühe suunatud lihtahela maksimaalne pikkus on K.
\begin_inset Newline newline
\end_inset

Seega 
\series bold
lõpprida ei ole üheselt vale parajasti siis kui kõikide hulkade, kuhu kuuluvad
 platod millest igaüks on teisele kas eelaseks või järglaseks ja kuhu pääseb
 ilma eitusi läbimata, iga elemendi (vähemalt) ühe haru kvanteeritava saab
 võrdsustada, mistahes teise plato p1, kuhu pääseb ilma eitusi läbimata,
 kvanteeritavaga(nii ,et platode, mille kvanteeritavatega need võrdsustati,
 kvanteeritavate vahelised elementaarseosed jäävad samaks.).
\end_layout

\begin_layout Enumerate

\color red
Kui mingi vormis on vähem kui K kvanteeritavate paari, mille elemendid on
 omavahel võrdsutatud, ja see on ÜV, siis on ÜV ka vorm kus samade kvanteeritava
te paarid omavahel võrdsustatud, kuid kokku on K paari.
 Seega piisab K asja vaja korraga 
\begin_inset Quotes eld
\end_inset

asendada
\begin_inset Quotes erd
\end_inset

.
 Seega kontrollida saab järjendite kaupa, kus on K p1'e ja K p2'e.
 või kahe järjendite 
\begin_inset ERT
status open

\begin_layout Plain Layout

$J_e$
\end_layout

\end_inset

 ja 
\begin_inset ERT
status open

\begin_layout Plain Layout

$J_u$
\end_layout

\end_inset

, millest mõlemas on K elementi järjetatud paaride kaupa.
\begin_inset Newline newline
\end_inset

Seega 
\series bold
lõpprida ei ole üheselt vale parajasti siis kui kõikide hulkade, kuhu kuuluvad
 platod millest igaüks on teisele kas eelaseks või järglaseks, mis sisaldavad
 platot tasemega 0(lõpprida ise), ja kuhu pääseb ilma eitusi läbimata, iga
 elemendi (vähemalt) ühe haru kvanteeritava saab võrdsustada, mistahes teise
 plato p1, kuhu pääseb ilma eitusi läbimata, kvanteeritavaga(nii, et platode,
 mille kvanteeritavatega need võrdsustati, kvanteeritavate vahelised elementaars
eosed jäävad samaks.).
\begin_inset Newline newline
\end_inset


\series default
Seega vaja kontrollida K kaupa kõigis järjekordades.
 VIGANE
\end_layout

\begin_layout Enumerate

\color red
_.._ ,sest nii saab mistahes suunatud ahelaid(P2'esid) kontrollida ja kui
 mingi plato(P2(i)), mille puhul ma kontrollin, et kas selle mingi haru
 kvanteeritava saab mingi muu kvanteeritavaga võrdsustada, eelase teine
 haru on millegagi võrdsustatud saab seda eraldi kontrollida(teise P1'ega),
 sest see pole samas suunatud ahelas.
 
\begin_inset Newline newline
\end_inset

Seega lõpprida ei ole üheselt vale parajasti siis kui mistahes K plato kvanteeri
tavad saab mistahes järjekorras võrdsustada mingite teiste platodega, millest
 igaüks on teisele kas eelaseks või järglaseks kvanteeritavatega nii, et
 esimene neist on mistahes plato haru.
\begin_inset Newline newline
\end_inset

ehk
\begin_inset Newline newline
\end_inset


\series bold
lõpprida ei ole üheselt vale parajasti siis kui mistahes platode vahelised
 elementaarseosed ja predikaatväited ühiste eelastega on samad kui mistahes
 plato (px) mingite järglaste, millest üks on selle plato otsene järglane,
 ühe tase on K ja millest igaüks on igale teisele ka eelaseks või järglaseks,
 vahelised elementaarseosed
\series default
.
\begin_inset Newline newline
\end_inset

ehk
\begin_inset ERT
status open

\begin_layout Plain Layout

$UV(LR)=
\backslash
forall_{px}(
\backslash
forall_{P1}(
\backslash
exists_{P2}(
\backslash
exists_i(k(P2(i))=K) 
\backslash
land "vastavate
\backslash
 elementide
\backslash
 vahelised
\backslash
 seosed
\backslash
 on
\backslash
 samad
\backslash
 voi
\backslash
 on
\backslash
 uhel
\backslash
 neist
\backslash
 tapsustamata
\backslash
 ja
\backslash
 eelnevatega
\backslash
 seosed
\backslash
 samad"(P1,P2) 
\backslash
land 
\backslash
forall_i("on
\backslash
 haru"(P2(i),P2(i+1))
\backslash
land "paaseb
\backslash
 ilma eitus labimata"(P1(i)))))$
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

kui px kasutamise asemel nõuda, et kui esimesed P1'ed on alates õppreast
 taseme järjekorras peavad vastavad P2 nende P1'edega võrduma, siis on tingimus
 järgnev 
\begin_inset ERT
status open

\begin_layout Plain Layout

$UV(LR)=
\backslash
forall_{P1}(
\backslash
forall_i("paaseb
\backslash
 ilma eitus labimata"(P1(i)))
\backslash
to 
\backslash
exists_{P2}(
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{p0}(
\backslash
forall_i(i<p0 
\backslash
to k(P1(i))=i)
\backslash
to 
\backslash
forall_i(P1(i)=P2(i))) 
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

len(P1)=K
\backslash
land len(P2)=K 
\backslash
land "vastavate
\backslash
 elementide
\backslash
 vahelised
\backslash
 seosed
\backslash
 on
\backslash
 samad
\backslash
 voi
\backslash
 on
\backslash
 uhel
\backslash
 neist
\backslash
 tapsustamata"(P1,P2) 
\backslash
land 
\backslash
forall_i("on
\backslash
 haru"(P2(i),P2(i+1)))))$
\end_layout

\end_inset

VIGANE
\end_layout

\begin_layout Enumerate

\color red
Piisab kui valida ainult 3 tüüpi P1'esid:
\begin_inset Newline newline
\end_inset

valik1: mis algavad platost px eelasest, on tasemejärjekorras ja millest
 igaüks on teistele kas eelaseks või järglasteks
\begin_inset Newline newline
\end_inset

valik2: mis algavad plato px järglasest, on tasemejärjekorras ja millest
 igaüks on teistele kas eelaseks või järglasteks
\begin_inset Newline newline
\end_inset

valik3: Mis algavad platost px, on suvalises järjekorras ja millest igaüks
 on teistele kas eelaseks või järglasteksm
\begin_inset Newline newline
\end_inset

Kui nende P1 vailkutega ei saa ÜV'd, ei saa ühegi teise valikua ÜV'd, sest:
\begin_inset Newline newline
\end_inset

olulised on ainult K-k(px) esimest P1'e elementi;
\begin_inset Newline newline
\end_inset

kuna valik2 ei anna ÜV saab iga p1'e, mi
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

sest kui mingi plato pa harusid ei saa taseme järjekorras teise plato pb
 harudega võrdsustada, siis saab ka nende asendustega üv kui valida platode
 ,mis jäävad pa ning pb ja pb kõrgeima ühise eelase vahele asendus 1 ja
 platode, mis jäävad plaode pb ning pb ja pb kõrgeima ühise eelase vahele
 asendus 2.
 Kui selline kontroll ei andnud ÜV'd, siis on platos px kõik vüimalikud
 p2'ed tasemejärjekorras olemas.
 Seega tehes P1 valiku3 saab kontrollida, et kõik P1'ed saab kõigis järjekordade
s sinna asendada.
 Pole üõhjendust juhukohta kui P1'ed pole samas lihtahelas, aga kehtib ka
 siis.
\begin_inset Newline newline
\end_inset

Samuti on ÜV'd need platod, mille üks aatatud harudest on üheselt vale.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Ilma px'ita variandis on eed tingimused järgnevad:
\begin_inset Newline newline
\end_inset

valik1:
\begin_inset Newline newline
\end_inset

valik2: tasemejärjekooras ahel(pikkusega k), mille esimene element on tasemel
 0 + taseme tasemejärjekooras ahel(pikkusega K-k), mille esimene element
 on tasemel eelmise lüli eelviimase elemendi aru.
\begin_inset Newline newline
\end_inset

valik3: p1'ed on suunatud lihtahel P1, aga ei pruugi olla tasemeärjekorras.
 Sama platod võib mitu korda olla P1'es.
\end_layout

\begin_layout Enumerate

\color red
Seda kas valik P1 valik1 või valik2 annavad vatuseks ÜV saab kontrollida:
\begin_inset Newline newline
\end_inset

Võitades kokku px järglase need harud, mis erinevad ainult selle poolest,
 et millised on predikaatide väärtused, kui üheks nende argumendiks on järglase
 kvanteeritav (x_{k+1}).
 Ehk eemaldab järglase harudest(rekusiivselt) predikatide väärtused kui
 predikaatide argumendiks on ka x_{k+1} harud, mis sisaldavad x_k'd, saab
 sama tulemuse kui võitades kokku kõik need x_k harud, mis erinevad ainult
 K-1 taseme haru märkide poolest(ehk eemaldades x_k'st kõrgeima taseme harud.)
\end_layout

\begin_layout Enumerate
valiku3 kotrollimiseks üpiisab kontrollid, et igad px'i järglased(tasemejärjekor
ras) saab igas järjekorras px'i tagasi asendada.
 Sest kui seda kõigepealt ktrollida ja o1'ega kõik vastavad vahesamud kpntrollid
a saab kontrollitud ka, et vajalikud harud olemas oleks.
 _..._ POLE KINDEL ET ÕIGE
\end_layout

\begin_layout Enumerate

\color red
seda kas valik3 annab ÜV saab kontrollida kontrollides et kas kõigile jnumbritel
, mis on px'ist alates tasemejärjekorras platodel eelneva harunumbriks,
 leiduvad ka numbrid , mis on samuti tasemejärjekorras harunumbriks px'ist
 alates, aga elementaarseoste järjekord on ära vahetatud.
\end_layout

\begin_layout Enumerate
mõlemad tingimused koos on: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg UV(LR,0) 
\backslash
land
\backslash
forall_n(
\backslash
forall_k(
\backslash
neg UV(n,k) 
\backslash
leftrightarrow
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

(
\backslash
forall_i(hm(n,i)
\backslash
to (r_{meemalda sisemised}(n)
\backslash
leftrightarrow r_{eemalda viimane kvaneritav}(i)
\backslash
land 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
neg UV(i,k+1)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash

\backslash
%o2 nuud
\end_layout

\begin_layout Plain Layout


\backslash
forall_{j1}(j1[0]=n 
\backslash
land 
\backslash
forall_i(harumark(j1[i],j1[i+1],k))
\backslash
to 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{w_{jarjekord}}(w_{jarjekord}<
\backslash
Gamma(K-k-i) 
\backslash
to
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
exists_{j2}(j2[0]=n 
\backslash
land 
\backslash
forall_i(harumark(j2[i],j2[i+1],k)
\backslash
land "h-osa
\backslash
 nagu
\backslash
 j1el
\backslash
 aga
\backslash
 teies jarjekorras"(j2[i],j1,i,w_{jarjekord})))))))$
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\color red
eeldab punkti 11!
\end_layout

\begin_layout Enumerate
Asendan funktsiooni harumärk(
\begin_inset ERT
status open

\begin_layout Plain Layout

$harumark(n_1,n_2)=(
\backslash
lfloor n_1*2^{-n_2} 
\backslash
rfloor 
\backslash
%2=1)$
\end_layout

\end_inset

=
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(x_1
\backslash
in N 
\backslash
land 
\backslash
exists_{x_2}(x_2
\backslash
in N 
\backslash
land x_2<2^{n_2}
\backslash
land n_1=x_1*2^{n_2+1}+2^{n_2}+x_2))$
\end_layout

\end_inset

) tingimusse
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_n(
\backslash
forall_k(
\backslash
neg UV(n,k) 
\backslash
leftrightarrow
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

(
\backslash
forall_i(hm(n,i)
\backslash
to (r_{eemalda
\backslash
 sisemised}(n)
\backslash
leftrightarrow r_{eemalda
\backslash
 viimane
\backslash
 kvaneritav}(i)
\backslash
land 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
neg UV(i,k+1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash

\backslash
%edasi o2
\end_layout

\begin_layout Plain Layout


\backslash
forall_{j1}(j1[0]=n 
\backslash
land 
\backslash
forall_i(i  
\backslash
in N 
\backslash
land i<K-k 
\backslash
to j1[i]<veerge(k+i-1) 
\backslash
land 
\backslash
exists_{x_1}(x_1
\backslash
in N 
\backslash
land 
\backslash
exists_{x_2}(x_2
\backslash
in N 
\backslash
land x_2<2^{j1[i+1]}
\backslash
land j1[i]=x_1*2^{j1[i+1]+1}+2^{j1[i+1]}+x_2)))
\backslash
to 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{w_{jarjekord}}(w_{jarjekord}<
\backslash
Gamma(K-k-i) 
\backslash
to
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
exists_{j2}(j2[0]=n 
\backslash
land 
\backslash
forall_i(i  
\backslash
in N 
\backslash
land i<K-k 
\backslash
to j1[i]<veerge(k+i-1) 
\backslash
land 
\backslash
exists_{x_1}(x_1
\backslash
in N 
\backslash
land 
\backslash
exists_{x_2}(x_2
\backslash
in N 
\backslash
land x_2<2^{j2[i+1]}
\backslash
land j2[i]=x_1*2^{j2[i+1]+1}+2^{j2[i+1]}+x_2))
\backslash
land "h-osa
\backslash
 nagu
\backslash
 j1el
\backslash
 aga
\backslash
 teies jarjekorras"(j2[i],j1,i,w_{jarjekord})))))))$
\end_layout

\end_inset


\color red

\begin_inset Newline newline
\end_inset

eeldab punkti 11!
\end_layout

\begin_layout Enumerate
panen 
\begin_inset ERT
status open

\begin_layout Plain Layout

$r_{eemalda
\backslash
 sisemised}(n)
\backslash
leftrightarrow r_{eemalda viimane kvaneritav}(i)$
\end_layout

\end_inset

 asemele tingimuse mis seda kontrollib.
 Tingimus on siis:
\begin_inset Newline newline
\end_inset


\color red
 
\color inherit

\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_n(
\backslash
forall_k(
\backslash
neg UV(n,k) 
\backslash
leftrightarrow
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

(
\backslash
forall_i(hm(n,i)
\backslash
to (samavaarseedharud(n,i,k)
\backslash
land 
\backslash
neg UV(i,k+1))
\backslash
land
\backslash

\backslash
%o2 edasi
\end_layout

\begin_layout Plain Layout


\backslash
forall_{j1}(j1[0]=n 
\backslash
land 
\backslash
forall_i(i  
\backslash
in N 
\backslash
land i<K-k 
\backslash
to j1[i]<veerge(k+i-1) 
\backslash
land 
\backslash
exists_{x_1}(x_1
\backslash
in N 
\backslash
land 
\backslash
exists_{x_2}(x_2
\backslash
in N 
\backslash
land x_2<2^{j1[i+1]}
\backslash
land j1[i]=x_1*2^{j1[i+1]+1}+2^{j1[i+1]}+x_2)))
\backslash
to 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{w_{jarjekord}}(w_{jarjekord}<
\backslash
Gamma(K-k-i) 
\backslash
to
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
exists_{j2}(j2[0]=n 
\backslash
land 
\backslash
forall_i(i  
\backslash
in N 
\backslash
land i<K-k 
\backslash
to j1[i]<veerge(k+i-1) 
\backslash
land 
\backslash
exists_{x_1}(x_1
\backslash
in N 
\backslash
land 
\backslash
exists_{x_2}(x_2
\backslash
in N 
\backslash
land x_2<2^{j2[i+1]}
\backslash
land j2[i]=x_1*2^{j2[i+1]+1}+2^{j2[i+1]}+x_2))
\backslash
land "h-osa
\backslash
 nagu
\backslash
 j1el
\backslash
 aga
\backslash
 teies jarjekorras"(j2[i],j1,i,w_{jarjekord})))))))
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
land 
\backslash
forall_{n_1}(
\backslash
forall_{n_2}(
\backslash
forall_k(samavaarseedharud(n,i,k)
\backslash
leftrightarrow 
\backslash
forall_{i_1}(
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

i_1
\backslash
in N
\backslash
land i_1<veerge(k)
\backslash
land k<K-1
\backslash
land hm(n_1,i_1)
\backslash
to
\end_layout

\begin_layout Plain Layout


\backslash
exists_{i_2}(hm(n_2,i_2)
\backslash
land(f(h(i_2)=h(i_1)))
\backslash
land samavaarsed(i_1,i_2,k+1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

i_1
\backslash
in N
\backslash
land i_1<veerge(k+1)
\backslash
land 
\backslash
land hm(n_2,i_1)
\backslash
to
\end_layout

\begin_layout Plain Layout


\backslash
exists_{i_2}(hm(n_2,i_2)
\backslash
land(f(h(i_1)=h(i_2)))
\backslash
land samavaarsed(i_2,i_1,k+1))))))$
\end_layout

\end_inset


\color red

\begin_inset Newline newline
\end_inset

ehk 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg UV(LR)=
\backslash
forall_{P1}(
\backslash
forall_{p1}(p1 
\backslash
in P1 
\backslash
to "paaseb
\backslash
 ilma
\backslash
 eitusi
\backslash
 labimata"(p1))
\backslash
to 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
exists_{I2}(I2(0)=LR 
\backslash
land 
\backslash
forall_i(i 
\backslash
in N 
\backslash
land i 
\backslash
leq K-1 
\backslash
to (f(P1,I2(i+1))
\backslash
land 
\backslash
exists_{x_1}(x_1
\backslash
in N 
\backslash
land 
\backslash
exists_{x_2}(x_2
\backslash
in N 
\backslash
land (x_2
\backslash
leq 2^{I2(i+1)}-1)
\backslash
land I2(i)=x_1*2^{I2(i+1)+1}+2^{I2(i+1)}+x_2))))))$
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

VIGANE
\end_layout

\begin_layout Enumerate

\color red
sama mis järgmise punktis()järgmine kustutada.
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_n(
\backslash
forall_k(
\backslash
neg UV(n,k) 
\backslash
leftrightarrow
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{j1}
\backslash
color{blue}(
\backslash
color{black}j1[0]=n 
\backslash
land 
\backslash
forall_i(i  
\backslash
in N 
\backslash
land i<K-k 
\backslash
to j1[i]<veerge(k+i-1) 
\backslash
land 
\backslash
exists_{x_1}(x_1
\backslash
in N 
\backslash
land 
\backslash
exists_{x_2}(x_2
\backslash
in N 
\backslash
land x_2<2^{j1[i+1]}
\backslash
land j1[i]=x_1*2^{j1[i+1]+1}+2^{j1[i+1]}+x_2)))
\backslash
to 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{w_{jarjekord}}(w_{jarjekord}<
\backslash
Gamma(K-k-i) 
\backslash
to
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
exists_{j2}
\backslash
color{red}(
\backslash
color{black}j2[0]=n 
\backslash
land 
\backslash
forall_i(i  
\backslash
in N 
\backslash
land i<K-k 
\backslash
to j1[i]<veerge(k+i-1) 
\backslash
land 
\end_layout

\begin_layout Plain Layout


\backslash
exists_{x_h}("h-osa
\backslash
 nagu
\backslash
 j1el
\backslash
 aga
\backslash
 teies jarjekorras"(j1,w,i,x_h) 
\backslash
land 
\backslash
exists_{x_1}(x_1
\backslash
in N 
\backslash
land x1<2^{veerge(i)-j2(i+1)-1} 
\backslash
land 
\backslash
exists_{x_2}(x_2
\backslash
in N 
\backslash
land (x_2
\backslash
leq 2^{j2(i+1)}-1)
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

j2(i)=x_h*2^{veerge(i)}+x_1*2^{j2(i+1)+1}+2^{j2(i+1)}+x_2))))
\backslash
color{red})
\backslash
color{black})
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

r_{eemalda
\backslash
 sisemised}(n)
\backslash
leftrightarrow r_{eemalda viimane kvaneritav}(j1[1])
\backslash
land
\backslash
neg UV(j1[1],k+1)
\backslash
color{blue})
\backslash
color{black}))$
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

VIGANE
\end_layout

\begin_layout Enumerate

\color red
Kuna on teada, et igal tasemel (k) on 
\begin_inset ERT
status open

\begin_layout Plain Layout

$veerge(k)$
\end_layout

\end_inset

 veergu ja selle taseme kvanteeritava predikaatväited eelmiste tasemete
 kvanteeritavatega on kirjeldatud bittidega, mis tulevad peale selle taseme
 haru märke (more significant), siis saan eelnevat tingimust lihtsudtada
 pannes 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1$
\end_layout

\end_inset

'e max värtuseks 
\begin_inset ERT
status open

\begin_layout Plain Layout

$2^{veerge(i)-I2(i+1)-1}$
\end_layout

\end_inset

 ja lisades uue kvanteeritava, mis kirjeldab vastava p2'e elementaarseoseid
 madalama taseme p2'edega.
 Seega:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg UV(LR)=
\backslash
forall_{P1}(
\backslash
forall_{p1}(p1 
\backslash
in P1 
\backslash
to "paaseb
\backslash
 ilma
\backslash
 eitusi
\backslash
 labimata"(p1))
\backslash
to 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
exists_{I2}(postulaat 
\backslash
land I2(0)=LR 
\backslash
land 
\backslash
forall_i(i 
\backslash
in N 
\backslash
land i 
\backslash
leq K-1 
\backslash
to (
\backslash
exists_{x_3}(f(I(i+1)(voi x_3),P1,i) 
\backslash
land
\backslash
exists_{x_1}(x_1
\backslash
in N 
\backslash
land x1<2^{veerge(i)-I2(i+1)-1} 
\backslash
land 
\backslash
exists_{x_2}(x_2
\backslash
in N 
\backslash
land (x_2
\backslash
leq 2^{I2(i+1)}-1)
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

I2(i)=x_3*2^{veerge(i)}+x_1*2^{I2(i+1)+1}+2^{I2(i+1)}+x_2))))))$
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

$x_3<2^{H(i)}$
\end_layout

\end_inset

 kas f tingimus x_3'el või I(i+1)'el?
\end_layout

\begin_layout Enumerate

\color red
Kasutades tähelepanekut, et kui otsitav plato peab jaatama ühte mitmetest
 harudest, siis topelt sobivuse vältmiseks saab otsida platosid, mis jaatab
 neist harudest ühte h_1 ja ei jaata ühtegi nendest harudest, mille indeks
 on selle indeksist väiksem.
\end_layout

\begin_layout Enumerate

\color red
Kuna P1 määrab iga P2 elemendi vaelised nõutud elementeerseosed selle P2
 elemendi eelastega, siis saab kasutada P1, ega bijektiivses seoses olevat
 järjendit I1, mille iga element määrab, et tingimused P2, et elementide
 h osale.
 Seega võib
\begin_inset ERT
status open

\begin_layout Plain Layout

$f(P1,i,I2(i))$
\end_layout

\end_inset

 asemel kasutada 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f(I1(i),I2(i))$
\end_layout

\end_inset

.
 Kui kõik P1 elemendid on ülejäänudele kas eelaseks või järglaseks, siis
 on iga P2 alemendi h osa kindlalt määratud.
 Selliste P1'ede puhul võib 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f(P1,i,I2(i))$
\end_layout

\end_inset

 asemele panna 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lfloor I2(i)*2^{-veerge(i)}
\backslash
rfloor=I1(i)$
\end_layout

\end_inset

.
 (EI TOIMI, sest ka platode, mis on p2'e järglased elementaarseosed peavad
 samad olema kui p1'ega).
 Kuigi VÕIBOLLA saab valida alati kõrvalharu niie et p1'e ja p2'el pole
 ühiseid järglasi.
\end_layout

\begin_layout Enumerate

\color red
Algoritm, mis kontrollib selle tingimuse põhjal üheselt valesust võib alustada
 P2'e platode numbrite (i'de väärtuste) proovimist nii kõrgeima taseme harudest
 kui madalaima taseme platodest.
 tundub, et kasulikum on alutada kõrgeimast tasemest.
\begin_inset Newline newline
\end_inset

Algoritm, mis kontrollib selle tingimuse põhjal üheselt valesust võib proovida
 järjest P2 patode võimalike haru numbreid või salvestadajörjest iga taseme
 võimalikud harue numbrid.
\end_layout

\begin_layout Enumerate

\color red
Iga valitud 
\begin_inset Quotes eld
\end_inset

asendatav
\begin_inset Quotes erd
\end_inset

 plato määrab ise ühe kindla haru kuhu see sobib ja isegi kui sobib mitmesse,
 siis piisab ainult selle kotrollimisest, kuhu see sobib.
 ehk et p2'e saab kontrolli käigus kindalt määrata.
 Kontrollitakse, et kas p1'ed võivad vähemalt ühe p2'e haruga võrdsed olla.
\begin_inset Newline newline
\end_inset

Ehk kui mingi on kontrollitud et mingi plato p2 kvanteeritav mingi teise
 plato p1 mingi haru p_h kvanteeritavaga võrdne olla ei saa isegi ilma p_h
 järglasi võrdustamata(sest p_h kvanteeritaval on enda eelastega nõutud
 teistsugused seosefunktsioonide väärtused kui p2'el nendega on), siis pole
 mõtet platot kontrollida, et plato p_h ega selle järglaste vähemalt üks
 haru mingi kvanteeritavaga võrdsustav on, sest _.._.
\begin_inset Newline newline
\end_inset

ehk kuidas valida nii, et jääks p1'ed jääksid samasse harusid on piiratud
 ja võimaldab optimeerimist.
 (HOOPIS SIIN VIGA)
\end_layout

\begin_layout Enumerate

\color red
Osad harud saab välistada teades ainult p1'e numbrit, p1'e taset, p2'e numbrit
 ja p2'e taset, selle põhjal, et iga p1'e haru peab saama asendada p2'e
 ja iga p2'e haru peab saama asendada p1'e ja p'el ja p2'el peavad eelatega
 samad elementaarseosed olema.
 Tähistan funktsiooni kas, mis kontrollib, et mingi haru sobib selle tingimusega
 o'ga.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$o(n_1,n_2,k_1,k_2)$
\end_layout

\end_inset

 on tõene siis kui plato numbriga n2 ja tasemega k2 harud saab korraga asendada
 taseme järjekorras plato numbriga n1 tasemega k1 mistahes harudega.
 
\begin_inset Newline newline
\end_inset

Ainult platode p1 ja p2 taset ja numbrit teades saab kontrollida, et kas
 p2'e saab võrdsustada p1'ega ja p1'e kõik järgalsed(samas järjekorras!)
 p2'e järglastega.
 Kuna võrdsustusi peab saama teha iga P1'e korral, siis juhul kui p2'e ei
 saa võrdsustada sellise haruga, kuhu saab ka p1'e kõik järglased asendada,
 siis on see LR ÜV.
 Seega võib nende harude kontrollimise ära jätta.
 See on tarvilik tingimus haru numbritele, mitte piisav tingimus.
 
\end_layout

\begin_layout Enumerate

\color red
Kui P2(i-1)'el leidub haru, mille puhul 
\begin_inset ERT
status open

\begin_layout Plain Layout

$o(n_2,n_1,k_2,k_1)$
\end_layout

\end_inset

 pole rahuldatud, siis on LR ÜV, sest selle haru kvanteeritavat ei saaks
 võrdsustada _.._ .Siis järeldub o'st ka, et kui P2(i) on P1(i+1) eelane, siis
 P2(i+1)=P1(i+1), mida on 8.
 punktis vaja.
\end_layout

\begin_layout Subsubsection
väidete, mida saab madalama K'ga kirjeldada tuvastamine
\end_layout

\begin_layout Standard
Kui kõik võitused sisse viia, siis peab leiduma vähemalt 1 järjend, millesse
 kuuluvad platod, millest iga üks on eelemisele eelaseks ja milles kvanteeritava
te seoste graaf on sidus.
 kvanteeritavate seoste graav on graaf, kus kvanteeritavate vahel leidub
 serv kui vähemalt 1 nende vahelise predikaadi väärtus on teada.
\end_layout

\begin_layout Subsubsection
väidete, mis osade predikaatide kohta midagi ei väida tuvastamine
\end_layout

\begin_layout Paragraph
funktsioonist o
\end_layout

\begin_layout Standard
O funktsiooni on võimalik ka teisisiti seletada nii, et pisab kui ainult
 p_k otsestest jäglastest eemaldatakse predikaatide väärtusi.
 Loob igast platost ja selle eelasest o-grupid ja kontrollib, et kas need
 on võrdsed.
\end_layout

\begin_layout Subparagraph
platost p_k tasemega k o-grupide loomine
\end_layout

\begin_layout Standard
Võitab kokku need harud, mis erinevad ainult selle poolest, et millised
 on predikaatide väärtused, kui üheks nende argumendiks on x_k.
 Ehk eemaldab harudest(rekusiivselt) predikatide väärtused kui predikaatide
 argumendiks on ka x_k harud, mis sisaldavad x_k'd.
\end_layout

\begin_layout Subparagraph
selle plato eelsest o-gruppide loomine
\end_layout

\begin_layout Standard
võitab kokku kõik need harud, mis erinevad ainult K taseme haru märkide
 poolest.
 Ehk eemaldab harudest kõrgeima taseme harud.
\end_layout

\begin_layout Paragraph
funktsioonist o2
\end_layout

\begin_layout Standard
kõigis tasemtes on seosefunktsioonide väärtused kõrgemad kui madalamates(POLE
 NII LIHTNE)?
\end_layout

\begin_layout Paragraph
funktsioon o3
\end_layout

\begin_layout Standard
pole vaja, P2'ed on universaalsus kvantorites.
\end_layout

\begin_layout Subsection
tüübi a F, mille ridade üheselt valesust on lihtne kontrollida
\end_layout

\begin_layout Standard
eemaldab, sosed, mis: saab madalama K'ga irjeldada, on mitu sama tähendusega
 lõppveergu(sest osad lõppreadon üheselt valed), või osade predikaatide
 kohta pole midagi öeldud.
 
\end_layout

\begin_layout Standard
a tüüpi, funktsioon, kus 
\begin_inset ERT
status open

\begin_layout Plain Layout

$harummark(x,k)=[n_s*2^{t}]
\backslash
%(2^(-H_{max}(k)-t)$
\end_layout

\end_inset

 ja 
\begin_inset ERT
status open

\begin_layout Plain Layout

$ saa h(x)=
\backslash
lfloor x 
\backslash
rfloor$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
saa_h ja saa_haru_märk on valitud nii, et ridade üheselt valesust oleks
 kerge kontrollida.
\end_layout

\begin_layout Standard
harumärk peaks olema midagi foriee pöörde laadset, kus iga element määrab,
 et kas lisadaperioodiline ,ärkide vaheldumine.
 Negatiivsete (või keskmisest väiksemate) indeksitega bitid määravad negatiivset
est märkidest alavad võnkumised.
 Võnkumiste peroood on võrdne biti indeksi absoluutvärtusega.
 Haru märkide määramiseks lainete väärtused kas liidetakse ja siis määratkse
 märk või lainete äärtustega tehakse vastavas järjekorras võituseid ja jaatuseid.
\end_layout

\begin_layout Standard
Või mingi polünoomi laadne, kus polünoomi nullkohad tähistavad 0-bitti.
\end_layout

\begin_layout Standard
vahet pole, et kas i sagedus muudab iga i'indat või i kaupa.
\end_layout

\begin_layout Standard
lainevärgi valikud:
\end_layout

\begin_layout Itemize
viimane kirjutab oma märgiga üle(sama mis tavaline hm)
\end_layout

\begin_layout Itemize
või kõik flipivad bitte kui oma märk on 1
\end_layout

\begin_layout Itemize
või kõik kirjutavad üle 1'ega kui oma märk on 1.
\end_layout

\begin_layout Standard
ja
\end_layout

\begin_layout Itemize
sagedusbiti indeks määrab ka, et kas algab poolperioodist
\end_layout

\begin_layout Itemize
või mitte
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsubsection
harumärk nii, et kõigis platodes oleksid alati funktsioon o täidetud
\end_layout

\begin_layout Standard
hm näitab iga ja ainult selliste harude hulkade, mis sobivad mingite ühe
 võrra madalma taseme harude hulkadega kokku (kas neil hulkadel ühiseid
 elemente ei ole?), et milliste selle taseme kvanteeritava seosefunktsiooniväärt
ustega(vähemalt ühega) on nende hulkade elemendid (selle taseme harud) jaatatud.
 Kui on , siis peab see seda küigi tasemejärjekoraes korraga olema.
\end_layout

\begin_layout Standard
hm ja h on nii valitud, etkõigi platode puhul, mis on jaatatud on täidetud
 tingimus 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_n(
\backslash
forall_i(hm(n,i)
\backslash
to (r_{meemalda sisemised}(n)
\backslash
leftrightarrow r_{eemalda viimane kvaneritav}(i))))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{j1}(j1[0]=px 
\backslash
land 
\backslash
forall_i(harumark(j1[i],j1[i+1]))
\backslash
to 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
exists_{j2}(j2[0]=px 
\backslash
land 
\backslash
forall_i(harumark(j2[i],j2[i+1])
\backslash
land "h-osa nagu j1el aga teies jarjekorras"(j2[i],j1,i)))))$
\end_layout

\end_inset

.
 Oluline, et ükski plato ei jaataks harusid, mis seda tingimust ei täida.
\end_layout

\begin_layout Subsubsection
harumärk nii, et kõigis platodes oleks funktsioon o2 täidetud
\end_layout

\begin_layout Paragraph
definitsioon:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$F(S)=$
\end_layout

\end_inset

pole valmis
\end_layout

\begin_layout Paragraph
pöördfunktsioon:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$f(n_S)=$
\end_layout

\end_inset

pole valmis
\end_layout

\begin_layout Paragraph
omadused:
\end_layout

\begin_layout Paragraph
Lühikirjeldus:
\end_layout

\begin_layout Standard
ilmselt mingi fourie pöörde sarnane asi.
 iga bait ei näita enam, et kas vastava indeksiga lõpprida on eitatud.
\end_layout

\begin_layout Section
uus idee CNFiga
\end_layout

\begin_layout Standard
Muidu sama, aga eksistentsaalsus kvantorid tuleb asendada universaalsuskvantorit
ega; väide viia lõpuks CNF vormi ja võitused välja tuua kvantoritest.
\end_layout

\begin_layout Section
grupeeritud veeergudega
\end_layout

\begin_layout Standard
Jaotada iga taseme harud gruppidesse.
 Lisaks DNFlõppveerule n_S ka seda, et millised veerud on IGAS tasemes kokku
 pandud ja, et kas grupp on kokku võitatud või jaatatud.
 Gruppi kirjeldab madalamas tasemes 1 bitt.
 Kui grupp on kokku võitatud, siis kirjeldab 1 bitt, et kas nad kõik on
 ei ole eitatud(1) või on(0).
 Kui grupp on kokku jaatatud, siis kirjeldab 1 bitt madalamas tasemes, et
 kas nad kõik on ei ole jaatatud(1) või on mitte(0).
 Võitusi saab viia kvatoritest välja, kui nii tekiks rohkem bitte(kombinatsioone
) madalamasse tasemesse.
 See on ka a tüüpi funktsioon, kus lihtsalt saa_h ja saa_haru_märk on grupidest
 sõltuvad(?! (võitused)).
\end_layout

\begin_layout Standard
Teise ideena võiks gruppide asemel olla funktsioon harude märkidest.
 Iga tasemel iseloomustavad saa_harumärk ja saa_h, et milline 
\end_layout

\begin_layout Standard
Gruppide vahel DNF vorm.
\end_layout

\begin_layout Itemize
N_s pole bijektiivne, kuid kui nõuda, et kõik, mida saab kokku panna on
 kokku pandud, siis on n_S injektiivne.
\end_layout

\begin_layout Section
Hea mõte
\end_layout

\begin_layout Standard
funktsioonil c(h,harude_märgid,k) on nii palju võimalikke väärtusi kui väite
 kirjeldamiseks vaja.
 Millisele harumärkide kombinatsioonile milline funktsiooni c väärtus vastab
 on lõppveerust eraldi n_S'is kirjas.
 Igale harumärkide kombinatsioonile vastab mingi funktsiooni c väärtus.
 saa_haru_märk(plato) kirjeldab, et milliste c(h,harude_märgid,k+1) väärtustega
 harud selles platos on eitatud ja milliste c(h,harude_märgi,k+1) väärtustega
 harud on eitatud.
\end_layout

\begin_layout Standard
Mitu taset allpool on c väärtustele vastavad bitid kirjeldatud võibki olla
 pakituse parameetriks.
\end_layout

\begin_layout Section
ANF, mille osadeks parameetriteks on DNFi väärtus
\end_layout

\begin_layout Section
DNF, mille veerud, mida omavahel ainult jaatatud on, on kokku pandud
\end_layout

\begin_layout Standard
Lisaks DNFlõppveerule sisaldab väide ka seda, et millised veerud on IGAS
 tasemes kokku pandud.
 Kui on kokku pandud, siis kirjeldab 1 bitt, et kas nad kõik on jaatatud
 või, et ükski neist ei ole jaatatud.
\end_layout

\begin_layout Itemize
N_s pole bijektiivne, kuid kui nõuda, et kõik, mida saab kokku panna on
 kokku pandud, siis on n_S injektiivne.
\end_layout

\begin_layout Section
Tasemetega
\end_layout

\begin_layout Standard
Vaatab et eelmise taseme järgi ,et millised veerud on korras 
\begin_inset Quotes eld
\end_inset

mitte väite argumendst sõltumatult vale olemise
\begin_inset Quotes erd
\end_inset

 reegli järgi.
\end_layout

\begin_layout Standard
eraldi biitidega(mitte harumärgi funktsiooniga) on kirjeldatud, et millisel
 platol on millised harud võimalikest.
 Biti indeks määrab haru omadused.
 iga plato p harude omadused on kirjeldatud näidates ,et: milline on plato
 p variplatode haru on milliste selle taseme seosefunktsioonide puhul rahuldatud.
\end_layout

\begin_layout Section
CNF mille need veerud ,mida on väites ainult võitatud, on kokku pandud
\end_layout

\begin_layout Section
NNF
\end_layout

\begin_layout Section
prefixkuju
\end_layout

\begin_layout Standard
alguses olevad bitid nöitavad, et milline on univeersallsuskvantor ja milline
 on eksistentsiaalsukvantor.
\end_layout

\begin_layout Section
näitevorm
\end_layout

\begin_layout Part
standard libary
\end_layout

\begin_layout Standard
seal on igasugu kasulikke väiteid, mida kasutaja saab enda omadega jaatada,
 et enda omade tõesust kontrollida.
\end_layout

\begin_layout Paragraph
robinsoni aritmeetika
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_null(x_1) 
\backslash
neg 
\backslash
exists(S(x_1,x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall( x_1=x_2 
\backslash
land S(x_1,x_3)
\backslash
land S(x_2,x_4) 
\backslash
to x_3=x_4))))
\end_layout

\begin_layout Plain Layout

on
\backslash
_null(x_1)
\backslash
lor 
\backslash
exists(S(x_2,x_1))
\end_layout

\begin_layout Plain Layout

%edasi liitmise definitsioon
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2+x_1=x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1+S(x_2)=S(x_1+x_2)
\end_layout

\begin_layout Plain Layout

))%edasi korrutamise definitsioon
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2*x_1=x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1*S(x_2)=x_1+x_1*x_2
\end_layout

\begin_layout Plain Layout

))
\end_layout

\begin_layout Plain Layout

$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
astendamine
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2^{x_1}=S(x_1)))$
\end_layout

\end_inset

iga arv astmes 0 on 1.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1^{S(x_2)}=x_1^{x_2}*x_1
\end_layout

\begin_layout Plain Layout

))$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
lahutamine
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(
\backslash
forall(x_1-x_2=x_3 
\backslash
leftrightarrow x_2+x_3=x_1)))$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
jagamine
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(
\backslash
forall(x_1/x_2=x_3 
\backslash
leftrightarrow x_2*x_3=x_1)))$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
peano viimane naturaalarvude hulga võimsuse aksioom
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_null(x_1) 
\backslash
land x_1 
\backslash
in K)
\backslash
land 
\backslash
forall(
\backslash
forall(x_1 
\backslash
in K 
\backslash
land S(x_1,x_2) 
\backslash
to x_2 
\backslash
in K)) 
\backslash
to 
\backslash
forall(x_1 
\backslash
in K)$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
kõik naturaalarvud on reaalarvud
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_reaalarv(x_1)
\backslash
to on
\backslash
_naturaalarv(x_1))$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
reaalarvude võrdlemine
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(x_1>x_2 
\backslash
leftrightarrow 
\backslash
exists( on
\backslash
_naturaalarv(x_3) 
\backslash
land x_1*x_3>x_2*x_3)))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
reaalarvude pid
\end_layout

\begin_layout Paragraph
täisarvu definitsioon
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_täisarv(x_1)
\backslash
leftrightarrow 
\backslash
exists(on
\backslash
_naturaalarv(x_2)
\backslash
land on
\backslash
_naturaalarv(x_1+x_2)))$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
ratsionaalarvu definitsioon
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_ratsionaalarv(x_1)
\backslash
leftrightarrow 
\backslash
exists(on
\backslash
_naturaalarv(x_2)
\backslash
land on
\backslash
_täisarv(x_1*x_2)))$
\end_layout

\end_inset


\end_layout

\begin_layout Part
väite vastuolulisust kontolliva programmi kasutamine
\end_layout

\begin_layout Section
süntax
\end_layout

\begin_layout Subsection
pythoni moodulina
\end_layout

\begin_layout Standard
Predikaadid on vastava klassi objektid.
 On ka universaalsuskvantori objekt.
 Loogikatehted on ka objektid ja lisaks python ülelaaditavad operaatorid.
 On meetodid: __bool__ ja kas_min_nested.
\end_layout

\begin_layout Subsection
eraldi fail
\end_layout

\begin_layout Subsubsection
predikaadid
\end_layout

\begin_layout Standard
Predikaadid on tähistatud kas operaatori-syntaxis või funktsiooni-syntaxis.
\end_layout

\begin_layout Paragraph
operaatorisyntax
\end_layout

\begin_layout Standard
eraldi lõigud, mille vahel on sulgude sees argumendid.
 näiteks 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(aaa(x_1)(x_2)bbb(x_3)ccc)$
\end_layout

\end_inset

 tähendab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$aaa()()bbb()ccc(x_1,x_2,x_3)$
\end_layout

\end_inset

.
 näiteks 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(x_1<x_2)$
\end_layout

\end_inset

 tähendab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$()<()(x_1,x_2)$
\end_layout

\end_inset

.
 Funktsioonisyntaxis ei ole vaja predikaatide lõpus olevaid argumente tühjade
 sulgudega vaja tähistada.
 Näiteks: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$()<()(x_1,x_2)$
\end_layout

\end_inset

 asemel
\begin_inset ERT
status open

\begin_layout Plain Layout

$()<(x_1,x_2)$
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
funktsioonisyntax
\end_layout

\begin_layout Standard
kohtadesse kus operaatori syntaxis oli vahekoht argumendi jaoks on tühjad
 sulud.
 juhul kui see predikaat on jutumärkides on tühjade sulgude asemel argumendikoht
ades kahekordsd jutumärid.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Sama predikaat võib samas väite lähtekoodis nii operaatori kui funktsioonisyntax
is tähistatud olla.
 Kui predikaadi nimi sisaldab sulge peab see predikaat olema jutumärkide
 sees.
 jutumärgid predikaadi nime alguses lõpus või argumendi kohtade kõrval tähistada
 tagurpidi kaldkriipsuga(nagu pythoni syntaxis.).
\end_layout

\begin_layout Standard
Kõik mis pole loogikatehted, sulud ega kvantorid tõlgendada predikaatidena(2
 argumendilise puhul nagu operaatori syntax.).
 
\end_layout

\begin_layout Standard
Kõik 16(10) funktsiooni 2 booleanist ühte booleani sisseehitatud operaatoritena
 või olemas mingi funktsionaalselt täielik hulk neid ja kasutaja saab ise
 ülejäänud defineerida.
 Samuti oleks siis 1 kvantor a kasutaja ise saaaks teis defineerida.
\end_layout

\begin_layout Standard
peale iga võitust uus rida.
\end_layout

\begin_layout Standard
Peale iga kvantorit taane.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
kui predikaat sisaldab mingit sümbolit, millel on ka muu tähendus, siis
 on see kas keelatud või tuleb tagurpidi kaldkriipuga tähistada.
\end_layout

\begin_layout Standard
Küsimärkidel eraldi tähendus.
 Kahekordse kriipsuga järeldusmärkidlja ekvivalentsusmärkidel eraldi tähendus.
 {} optimeerimis tingimused.
\end_layout

\begin_layout Standard
Eraldi funktsooni sees saab sisestada käske.
\end_layout

\begin_layout Subsection
syntaxsugar
\end_layout

\begin_layout Standard
Eraldi võimalik märkida alad kus kehtib mingi syntaxsugar nt.
 
\backslash
sugar(
\begin_inset Quotes eld
\end_inset

boolean
\begin_inset Quotes erd
\end_inset

){},
\end_layout

\begin_layout Subsubsection
kvanteeritavate-nimede sugar
\begin_inset CommandInset label
LatexCommand label
name "subsec:kvanteeritavate-nimede-sugar"

\end_inset


\end_layout

\begin_layout Standard
Kui kvantori alaindeksiks pole kvanteeritava nime kirjutatud, siis eeldatakse,
 et selle kvantori kvanteeritava nimi on 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_{k+1}$
\end_layout

\end_inset

 kus 
\begin_inset ERT
status open

\begin_layout Plain Layout

$k$
\end_layout

\end_inset

 näitab, et mitme kvantori sees antud kvantor on.
 Et seda süntax-sugarit kasutavas notatsioonis kirjeldatud seost seda süntax-sug
arit mitte kasutavasse notatsiooni ümber kirjutatada tuleb kvantoritele
 kvanteeritavate nimed (alaindeksitena) juurde kirjutada.
\end_layout

\begin_layout Standard
Näiteks järgnevas valemis, kus pole kvanteeritavate nimesi kirjutatud:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
exists(
\backslash
exists(A(x_1,x_2,x_3,x_2))))
\backslash
land 
\backslash
exists(
\backslash
exists(
\backslash
forall(
\backslash
exists(A(x_1,x_2,x_3,x_4)) 
\backslash
to 
\backslash
exists( 
\backslash
neg A(x_1,x_1,x_3,x_4) ))))
\backslash
land 
\backslash
neg 
\backslash
forall(
\backslash
neg A(x_1,x_1,x_1,x_1))$
\end_layout

\end_inset

 eeldatakse need olema: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(
\backslash
exists_{x_2}(
\backslash
exists_{x_3}(A(x_1,x_2,x_3,x_2))))
\backslash
land 
\backslash
exists_{x_1}(
\backslash
exists_{x_2}(
\backslash
forall_{x_3}(
\backslash
exists_{x_4}(A(x_1,x_2,x_3,x_4)) 
\backslash
to 
\backslash
exists_{x_4}( 
\backslash
neg A(x_1,x_1,x_3,x_4) ))))
\backslash
land 
\backslash
neg 
\backslash
forall_{x_1}(
\backslash
neg A(x_1,x_1,x_1,x_1))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Võib küll tekkida mitmeid samanimelisi kvanteeritavaid(ehkmkvantori fiktiivmuutu
jaid), aga need ei saa mitte kunagi samas kohas valemis kasutusel olla.
 Juhul kui tahetakse vabaneda ka olukorrast, kus on mitu samanimelist kvanteerit
avat võib kõigi kvanteeritavate nimedele lisada punkti ja peale seda arvu,
 mis näitab, et mitu samanimelise kvanteeritavaga kvantorit sellest kvantorist
 vasakul pool asub.
 Näiteks toodud väite puhul:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_{1.0}}(
\backslash
exists_{x_{2.0}}(
\backslash
exists_{x_{3.0}}(A(x_{1.0},x_{2.0},x_{3.0},x_{2.0}))))
\backslash
land 
\backslash
exists_{x_{1.1}}(
\backslash
exists_{x_{2.1}}(
\backslash
forall_{x_{3.1}}(
\backslash
exists_{x_{4.0}}(A(x_{1.1},x_{2.1},x_{3.1},x_{4.0})) 
\backslash
to 
\backslash
exists_{x_{4.1}}( 
\backslash
neg A(x_{1.1},x_{1.1},x_{3.1},x_{4.0}) ))))
\backslash
land 
\backslash
neg 
\backslash
forall_{x_{1.2}}(
\backslash
neg A(x_{1.2},x_{1.2},x_{1.2},x_{1.2}))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sellises süntaks-sugariga saab kirjeldada kõiki väiteid, mida ilma selle
 sütax-sugaritagi saab kirjeldada.
 Et seda süntax-sugarit mitte kasutavas notatsioonis kirjeldatud seost seda
 süntax-sugarit kasutavasse notatsiooni ümber kirjutatada tuleb kõigepealt
 muuta kvanteeritavate nimed eespool kirjeldatudeks ja seejärel eemaldada
 kvanteeritavate nimed kvantorite juurest (alaindeksitena).
\end_layout

\begin_layout Standard
Näiteks järgnev valem:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_a(
\backslash
neg A(a,a) 
\backslash
land 
\backslash
exists_b(A(a,b) 
\backslash
land 
\backslash
neg A(b,a) 
\backslash
land 
\backslash
neg A(b,b) 
\backslash
land 
\backslash
exists_c(
\backslash
neg A(a,c) 
\backslash
land A(b,c) 
\backslash
land 
\backslash
neg A(c,a) 
\backslash
land 
\backslash
neg A(c,b) 
\backslash
land 
\backslash
neg A(c,c)) 
\backslash
land 
\backslash
exists_d(
\backslash
neg A(a, d) 
\backslash
land A(b,d) 
\backslash
land 
\backslash
neg A(d,a) 
\backslash
land 
\backslash
neg A(d,b) 
\backslash
land A(d,d)))) 
\backslash
land 
\backslash
neg 
\backslash
exists_e(
\backslash
neg A(e,e) 
\backslash
land 
\backslash
exists_f(
\backslash
neg A(e,f) 
\backslash
land A(f,e) 
\backslash
land 
\backslash
neg A(f,f) 
\backslash
land 
\backslash
exists_g(A(e, g) 
\backslash
land 
\backslash
neg A(f,g) 
\backslash
land 
\backslash
neg A(g,e) 
\backslash
land 
\backslash
neg A(g,f) 
\backslash
land 
\backslash
neg A(g,g)) 
\backslash
land 
\backslash
exists_h(A(e,h) 
\backslash
land 
\backslash
neg A(f,h) 
\backslash
land 
\backslash
neg A(h,e) 
\backslash
land 
\backslash
neg A(h,f) 
\backslash
land A(h,h))))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
selle syntax-sugariga kirjeldatuna on:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
neg A(x_1, x_1) 
\backslash
land 
\backslash
exists(A(x_1, x_2) 
\backslash
land 
\backslash
neg A(x_2, x_1) 
\backslash
land 
\backslash
neg A(x_2, x_2) 
\backslash
land 
\backslash
exists(
\backslash
neg A(x_1, x_3) 
\backslash
land A(x_2, x_3) 
\backslash
land 
\backslash
neg A(x_3, x_1) 
\backslash
land 
\backslash
neg A(x_3, x_2) 
\backslash
land 
\backslash
neg A(x_3, x_3)) 
\backslash
land 
\backslash
exists(
\backslash
neg A(x_1, x_3) 
\backslash
land A(x_2, x_3) 
\backslash
land 
\backslash
neg A(x_3, x_1) 
\backslash
land 
\backslash
neg A(x_3, x_2) 
\backslash
land A(x_3, x_3)))) 
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
neg A(x_1, x_1) 
\backslash
land 
\backslash
exists(
\backslash
neg A(x_1, x_2) 
\backslash
land A(x_2, x_1) 
\backslash
land 
\backslash
neg A(x_2, x_2) 
\backslash
land 
\backslash
exists(A(x_1, x_3) 
\backslash
land 
\backslash
neg A(x_2, x_3) 
\backslash
land 
\backslash
neg A(x_3, x_1) 
\backslash
land 
\backslash
neg A(x_3, x_2) 
\backslash
land 
\backslash
neg A(x_3, x_3)) 
\backslash
land 
\backslash
exists(A(x_1, x_3) 
\backslash
land 
\backslash
neg A(x_2, x_3) 
\backslash
land 
\backslash
neg A(x_3, x_1) 
\backslash
land 
\backslash
neg A(x_3, x_2) 
\backslash
land A(x_3, x_3))))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
või alternatiivselt:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
neg A(1, 1) 
\backslash
land 
\backslash
exists(A(1, 2) 
\backslash
land 
\backslash
neg A(2, 1) 
\backslash
land 
\backslash
neg A(2, 2) 
\backslash
land 
\backslash
exists(
\backslash
neg A(1, 3) 
\backslash
land A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land 
\backslash
neg A(3, 3)) 
\backslash
land 
\backslash
exists(
\backslash
neg A(1, 3) 
\backslash
land A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land A(3, 3)))) 
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
neg A(1, 1) 
\backslash
land 
\backslash
exists(
\backslash
neg A(1, 2) 
\backslash
land A(2, 1) 
\backslash
land 
\backslash
neg A(2, 2) 
\backslash
land 
\backslash
exists(A(1, 3) 
\backslash
land 
\backslash
neg A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land 
\backslash
neg A(3, 3)) 
\backslash
land 
\backslash
exists(A(1, 3) 
\backslash
land 
\backslash
neg A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land A(3, 3))))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
boolean sugar
\end_layout

\begin_layout Standard
väiteid saab panna predikaadi argumendiks.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$A(
\backslash
forall(...))$
\end_layout

\end_inset

 asemel 
\begin_inset ERT
status open

\begin_layout Plain Layout

$boolean(x)
\backslash
land (toene(x) 
\backslash
iff 
\backslash
forall(...)) 
\backslash
land A(x)$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
operaatorite (järjekorraga) sugar
\begin_inset CommandInset label
LatexCommand label
name "subsec:operaatorite-(järjekorraga)-sugar"

\end_inset


\end_layout

\begin_layout Enumerate
kuni valemis operaatoreid on:
\end_layout

\begin_layout Enumerate
: : paneb operaatoritega valemi ümber universaalsuskvantori nt.
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_{11}+x_{12}*x_{13}=x_{14}$
\end_layout

\end_inset

 peale seda sammu: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(x_{11}+x_{12}*x_{13}=x_{14})$
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
: : jaatab olemasolevale väite uus kvanteeritav on võrdne kõige esimesena
 tehtava operatsiooni tulemusega.
 näteks 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(x_{11}+x_{12}*x_{13}=x_{14})$
\end_layout

\end_inset

 peale seda sammu on: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(*(x_{12},x_{13},x_{15}) 
\backslash
land x_{11}+x_{12}*x_{13}=x_{14})$
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
: : asendab kõige esimesena tehtava operatsiooni uue kvanteeritavaga, et
 selle tehte tulemus on võrdne uue kvanteeritavaga.
 nt.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(*(x_{12},x_{13},x_{15}) 
\backslash
land x_{11}+x_{12}*x_{13}=x_{14})$
\end_layout

\end_inset

 peale seda sammu: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(*(x_{12},x_{13},x_{15}) 
\backslash
land x_{11}+x_{15}=x_{14})$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
näited:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$+(x_1,x_2,x_3)$
\end_layout

\end_inset

 tähendab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1+x_2=x_3$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$*(x_1,x_2,x_3)$
\end_layout

\end_inset

 tähendab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1*x_2=x_3$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$CALL(x_1,...,x_n)$
\end_layout

\end_inset

 tähendab, et funktsioon 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1$
\end_layout

\end_inset

 argumentidega ...
 tagastab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_n$
\end_layout

\end_inset

'i.
\end_layout

\begin_layout Standard
operaatorite järjekord: **,[*,/],[+,-]
\end_layout

\begin_layout Subparagraph
näide
\end_layout

\begin_layout Standard
näiteks teisendab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
exists(
\backslash
exists(x_1*x_2+x_3=f(x_3,x_2,x_1,x_2))))$
\end_layout

\end_inset

 järgenvaks:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$*(x_1,x_2,x_4) 
\backslash
land +(x_4,x_3,x_5) 
\backslash
land on
\backslash
_f(x_6) 
\backslash
land CALL(x_6,x_3,x_2,x_1,x_2,x_7)$
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
näide
\end_layout

\begin_layout Standard
näiteks teisendab valemi:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_null(x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(x_1=x_1)
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(x_1=x_2
\backslash
land x_2=x_3 
\backslash
to x_3=x_1)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(on
\backslash
_naturaalarv(x_1)
\backslash
land x_1=x_2 
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(on
\backslash
_naturaalarv(x_1)
\backslash
land S(x_1,x_2)
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(=(x_1,x_2) 
\backslash
land S(x_1,x_3) 
\backslash
land S(x_2,x_4) 
\backslash
leftrightarrow =(x_3,x_4))) 
\backslash
land 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
to 
\backslash
neg 
\backslash
exists( S(x_2,x_1)
\backslash
land on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
exists(on
\backslash
_null(x_1) 
\backslash
land x_1 
\backslash
in K)
\backslash
land 
\backslash
forall(
\backslash
forall(x_1 
\backslash
in K 
\backslash
land S(x_1,x_2) 
\backslash
to x_2 
\backslash
in K)) 
\backslash
to 
\backslash
forall(x_1 
\backslash
in K)%edasi liitmise definitsioon
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2+x_1=x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1+S(x_2)=S(x_1+x_2)
\end_layout

\begin_layout Plain Layout

))%edasi korrutamise definitsioon
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2*x_1=x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1*S(x_2)=x_1+x_1*x_2
\end_layout

\begin_layout Plain Layout

))
\end_layout

\begin_layout Plain Layout

$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
kujule:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_null(x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(=(x_1,x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(=(x_1,x_2)
\backslash
land =(x_2,x_3)
\backslash
to =(x_3,x_1))))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(on
\backslash
_naturaalarv(x_1)
\backslash
land =(x_1,x_2)
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(on
\backslash
_naturaalarv(x_1)
\backslash
land S(x_1,x_2)
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(x_1=x_2 
\backslash
leftrightarrow S(x_1)=S(x_2))) 
\backslash
land 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
to 
\backslash
neg 
\backslash
exists( S(x_2,x_1)
\backslash
land on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
exists(on
\backslash
_null(x_1) 
\backslash
land x_1 
\backslash
in K)
\backslash
land 
\backslash
forall(
\backslash
forall(x_1 
\backslash
in K 
\backslash
land S(x_1,x_2) 
\backslash
to x_2 
\backslash
in K)) 
\backslash
to 
\backslash
forall(x_1 
\backslash
in K)
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(+(x_2,x_1,x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

S(x_2,x_3) 
\backslash
land +(x_1,x_2,x_4) 
\backslash
land S(x_4,x_5) 
\backslash
land +(x_1,x_3,x_6) 
\backslash
leftrightarrow =(x_6,x_5)
\end_layout

\begin_layout Plain Layout

))))))
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(*(x_2,x_1,x_1)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

S(x_2,x_3) 
\backslash
land *(x_1,x_2,x_4) 
\backslash
land +(x_1,x_4,x_5) 
\backslash
land  
\backslash
leftrightarrow =(x_6,x_5)
\end_layout

\begin_layout Plain Layout

))))))
\end_layout

\begin_layout Plain Layout

$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
transistiivsete operaatorite sug ar
\end_layout

\begin_layout Standard
et
\begin_inset ERT
status open

\begin_layout Plain Layout

$a=b=c$
\end_layout

\end_inset

tähendab
\begin_inset ERT
status open

\begin_layout Plain Layout

$a=b 
\backslash
land b=c$
\end_layout

\end_inset

 nt.
 operaatorite rakendamise järjekord.
 syntax nt 
\backslash
enable_syntaxsugar(kommunitiivsed_võdusmärgid)
\end_layout

\begin_layout Standard
.
\end_layout

\begin_layout Subsubsection
kantsulgude sugar
\end_layout

\begin_layout Standard
Kantsulgudel sulgudel selline tähendus, et 
\begin_inset ERT
status open

\begin_layout Plain Layout

$[a OP1 b OP1 c OP1 d] OP2 e = (a OP2 e) OP1 (b OP2 e) OP1 (c OP2 e) OP1
 (d OP2 e)$
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
predikaatide overloading
\end_layout

\begin_layout Standard
võib olla mitu sama nime, aga erineva argumentide arvuga, predikaati.
 kui argumentide arv on erinev, aga siis on tegemist erinevate predikaatidega
 - sellel et nimi on sama pole mingit tähtsust.
\end_layout

\begin_layout Subsubsection
väited predikaatide argumentidena
\end_layout

\begin_layout Standard
Elementaarseoste argumentideks saavad olla väited kui eelenvalt on defineeritud
 True ja False.
 Et nende tähendus olks sama, mis intuitiivne tähendus peab lisama ka nendega
 seotud väited 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(("onTrue"(x_1)
\backslash
land "onTrue"(x_2)
\backslash
to "="(x_1,x_2)) 
\backslash
land ("onTrue"(x_1)
\backslash
land "onFalse"(x_2)
\backslash
to 
\backslash
neg "="(x_1,x_2))))$
\end_layout

\end_inset

.
 Elementeersesos(väide) tähendab: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(väide 
\backslash
to 
\backslash
exists("onTrue(x_1) 
\backslash
land "elementaatseos"(x_1)) 
\backslash
land (
\backslash
neg väide 
\backslash
to 
\backslash
exists("onFalse"(x_1) 
\backslash
land "elementaatseos"(x_1)))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
importimine
\end_layout

\begin_layout Standard

\backslash
uri
\begin_inset Quotes erd
\end_inset

...
\begin_inset Quotes erd
\end_inset

 on uril ...
 olev väide.
\end_layout

\begin_layout Standard

\backslash
standarlibari
\begin_inset Quotes erd
\end_inset

...
\begin_inset Quotes erd
\end_inset

 on stadardses kohas kus palju kasulikke väiteid on olev väide.
\end_layout

\begin_layout Standard
imporditud väidetel on võivad olla viimased sulud puudu, sest need ütleva,
 et midagi eksisteerib, aga lasevad kasutajal sama kvantori (mille lähtekood
 on teises failis) väiteid juurde kirjutada.
\begin_inset Newline newline
\end_inset

Moodulid on eelnevalt 
\begin_inset Quotes eld
\end_inset

kompileeritud
\begin_inset Quotes eld
\end_inset

.
 Imortimisel nende väitenumbrit muudetakse nii , et see sobiks kokku ülejäänud
 predikaatide ja K'ga.
 Nii on efektiivsus suurem.
 Moodulite lähtekood ei pea kõigi moodulite puhul avalik olema.
\end_layout

\begin_layout Section
lisa funktsioonid
\end_layout

\begin_layout Subsection
lähtekoodi värvimine
\end_layout

\begin_layout Itemize
sulud mustad ja vahelduvate suurustega või vahelduvate värvidega.
\end_layout

\begin_layout Itemize
loogikatehted tumesinised
\end_layout

\begin_layout Itemize
kvatorid helesinised
\end_layout

\begin_layout Itemize
predikaadid oranžid
\end_layout

\begin_layout Standard
Ebaolulised kohad, mis midagi ei mõjuta muudab lähtekoodis halliks.
 Kuvab igast predikaadist ainult nii mitu esimest sümbolit, et viimane sümbol
 pole sama mis mõnel teisel predikaadil.
\end_layout

\begin_layout Subsection
tagastab ka lähtekoodi latexis ja lähtekoodi latexi lähtekoodi ja sama lihtsusta
tud väite kohta
\end_layout

\begin_layout Subsection
kuvab puugraafina ka valitud plato
\end_layout

\begin_layout Standard
alguses ainult juure.
 Kui klikkida, siis kuvab plato, millele klikiti harud.
\end_layout

\begin_layout Section
Gödeli teoreemid
\end_layout

\begin_layout Standard
Antud süntaksis on Gödeli teoreemid ilmselged.
 Need on üsna mõtetud.
\end_layout

\begin_layout Standard
kui sain gödeli teoreemidest õieti aru, siis 
\end_layout

\begin_layout Paragraph

\series bold
esimene teoreem
\end_layout

\begin_layout Standard
väidab, et: Iga väite S1 jaoks leidub mingi teine väide S2, mille jaatamisel
 esimesega (S1'ga) ei saa ei üheselt vale ega üheselt õiget tulemust(ei
 ole lihtsustatav Trueks ega Falseks).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_{x_1}(
\backslash
exists_{x_2}(on
\backslash
_piisavalt
\backslash
 aritmeetikat(x_1)
\backslash
to ()))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Gödeli lause on kõige väiksema Kga ja väikseima numbriga väide, mille tõesus
 ega valesus antud väitest ei järeldu.
\end_layout

\begin_layout Standard
See originallsõnastuses, et need samas keeles peavad olema, tähendab minu
 süntaksis, et need peavad sisaldama samu predikaate.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Paragraph*
teine Gödeli teoreem
\end_layout

\begin_layout Subparagraph*
hüpotees1
\end_layout

\begin_layout Standard
originaal sõnastus on:
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

ühegist kooskõlalisest süsteemist,milles on piisavalt aritmeetikat, ei järeldu
 selle kooskõlalisus.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
antud süntaxis on sõnastus:
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

ühegi väite, mille mitte-üheseltvalesus(kooskõlisust) ei saa näidata lõpliku
 arvu näidete abil, mitte-üheseltvalesus ei saa tõestada.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Naturaalarvude aksioomide kooskõlalisust ei saa selle näiteväitega jaatamise
 abil näidata, sest iga igakord naturaalarvu kohta eitatud kvantorite mitterahud
amiseks luua uus näide(ja tüübiunktsiooniväärtus) ja sellele omakorda uus.
 Piisavalt aritmeetikat sisaldab süsteem siis kui see nõuab lõpmatult paljude
 asjade, millest ühegi pole teiste asjadega täpselt ientsed kuulumised.
 piisavalt palju aritmeetikat sisaaldab süsteem kui selle mitteüheseltvalesust
 ei saa tõetada selle jaatamisel näiteväitega.
\begin_inset Newline newline
\end_inset

Teine hüpotees on, et piisava aritmeetika peano aksioomiele toob hoopif
 f-aksioom.
\end_layout

\begin_layout Standard
Võimalik, et Gödeli II teoreem väidab ,et osade väidete mitteüheseltvalesust
 ei saagi tõestada.
 Kui saab tõestada et mingi väite mitteüheseltvalesust ei saa tõestada,
 siis tõestab ,see pole üheselt vale?
\end_layout

\begin_layout Subparagraph*
hüpotees2
\end_layout

\begin_layout Standard
Naturaalarvude aksioome ei saa selles sünaksis kirjeldada, sest ei saa väita,
 et mingi hulga võimsus võrdne või suurem naturaalarvude hulga alamhulkade
 võimsusest.
 Seda on vaja, et väites, et kui mingi 0 kuulub mingisse hulka ja sellest,
 et mingi naturaalarv mingisse hulka kuulub järeldub, et iga naturaalarv
 sellesse hulka kuulub kuuluvad kõik naturaalarvud sellesse hulka.
 Pole ju võimalik väita, et kõiki naturaalarvude alamhulgad üldse eksisteerivad.
\end_layout

\begin_layout Section
sünonüümidest
\end_layout

\begin_layout Standard
Kuna erinevates allikates kasutatakse samade asjade kohta erinevaid nimetusi,
 toon siin välja, et kuidas on mujal nimetatud asju, mida siin failis kasutan.
\end_layout

\begin_layout Standard

\series bold
väide
\series default
 ehk: formaalne süsteem, aksiomaatiline süsteem, valem, lause, seos.
\end_layout

\begin_layout Standard

\series bold
jaatus
\series default
 ehk: konjutsioon.
\end_layout

\begin_layout Standard

\series bold
võitus
\series default
 ehk: disjuktsioon.
\end_layout

\begin_layout Standard

\series bold
üheselt vale
\series default
 ehk: samaselt väär, vastuoluline, samaselt vale, mitte kehtestatav.
\end_layout

\begin_layout Standard

\series bold
üheselt tõene
\series default
 ehk: samaselt tõene.
\end_layout

\begin_layout Standard

\series bold
eksistentsaalsuskvantor
\series default
 ehk: olemasolukantor.
\end_layout

\begin_layout Standard

\series bold
universaalsuskvantor
\series default
 ehk: üldisuskvantor.
\end_layout

\begin_layout Standard

\series bold
elementaarseos
\series default
 ehk: notatsiooni poolt ette antud predikaat.
\end_layout

\begin_layout Standard

\series bold
element
\series default
 ehk: algasi, konstantsümbol.
\end_layout

\begin_layout Standard

\series bold
kvanteeritav
\series default
 ehk: kvantori fiktiivmuutuja
\end_layout

\begin_layout Standard

\series bold
haru
\series default
 ehk: veerg
\end_layout

\begin_layout Standard

\series bold
DNF-vorm
\series default
 ehk: disjuktiivne normaalkuju.
\end_layout

\begin_layout Standard

\series bold
CNF-vorm
\series default
 ehk: konjuktiivne normaalkuju.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Osades käsitlustes on ka kandjahulk, aga selle faili terminoloogias on selleks
 universaalne hulk (või seda pole) seega väited kehtivad kõigi asjade kohta.
 Kui tahad et väide kehtiks näiteks ainult naturaalarvude kohta, siis pane
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_x(f(x))$
\end_layout

\end_inset

 asemele 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_x(on
\backslash
_naturaalarv(x)
\backslash
to f(x))$
\end_layout

\end_inset


\end_layout

\begin_layout Section
LVd, mida saab madalama K'ga kirjeldada
\end_layout

\begin_layout Standard
Kui kui kõik bitid on nullid või ühed on väide vastavalt üheselt vale või
 üheselt tõene.
\end_layout

\begin_layout Standard
K=1 lõpprida saab madalama K'ga kirjeldada ainult siis kui kõik selle bitid
 on 1'ed või 0'id.
\end_layout

\begin_layout Standard
väidet ei saa madalama K'ga kirjeldada ainult siis kui see sisaldab K'd
 kvanteeritavat, millest moodustub ring.
 Ühendatuks loetakse kvanteeritavaid, mille vaheline elementaarseos on kirjeldat
ud.
\end_layout

\begin_layout Subsection
hüpotees: kui o1 lõppveerust on ÜV saab väidet kirjeldada väiksema K'ga.
\end_layout

\begin_layout Standard
Vale, sest _.._
\end_layout

\begin_layout Subsection
hüpotees: kui o2 lõppveerust on ÜV saab väidet kirjeldada väiksema K'ga.
\end_layout

\begin_layout Standard
Vale, sest _.._
\end_layout

\begin_layout Part
Sorteerimata
\end_layout

\begin_layout Standard
vahest saab väite ÜVsust ÜTsust kontrollida ilma lõppveergu leidmata.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
o1'e sarnast funktsiooni lõppreale rakendades saab võibolla kontrollida,
 et kas väide on minimaalse K ja predikaadidega kirjeldatud.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Need lõppveerud, mis ei tee osade predikaatide koha mingeid väiteid tuleb
 ka eemaldada nagu needgi, mida saab madalma K'ga esitada ja need, mis jaatavad
 ÜV LR'e.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
väite parssimisel: alustades kõige sisemisemast platost iga kvantori puhul
 määrata, et mis numbrid saavad olla tema platonumbrid.
 Selle arvestamiseks teha vastavad loogikatehted tema elementaarseostega
 eelastega ja tema sees olevate kvantorite võimalike platoniumbritega.
 See on võtuste välja viimeseks efektiivsem võimalus kui asja täis DNF vormi
 viimine.
 Et määrata kas väide on ÜV vaadata, et kas mõni lõppveerg rahuldab talle
 seatud tingimust.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Kui asendada kvantorid tõenäosus funktsiooniga(
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_x(f(x))$
\end_layout

\end_inset

 asendada 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_x(P(x))$
\end_layout

\end_inset

 ja 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_x(f(x))$
\end_layout

\end_inset

 asendada 
\begin_inset ERT
status open

\begin_layout Plain Layout

$1-
\backslash
forall_x(1-P(x))$
\end_layout

\end_inset

) ja võitamine liitmisega ja jaatamine korrutamisega(sest kõik harud sh.
 lõppread on omavahel sõltumatud.) siis saab tõenäosusi arvutada.
 Kui asendada need kompleksarvuliste lainefunktsioonidega saab kvantarvutusi
 teha?forall< Panna eelnevad 2 mõtet väitevormis kirja.
 Nii saabgi vist tõenäosuste kirjeldamiseks vajalikud aksioomid.
\begin_inset Newline newline
\end_inset

vähem üldises mõttes on univrsaalus kvantor(
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Pi(f(x))$
\end_layout

\end_inset

) jaatus ja eksistentsiaalsuskvantor võitus.
\begin_inset Newline newline
\end_inset

lõplik:
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lor$
\end_layout

\end_inset

;
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
land$
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

loenduv:
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
sum_{i=0}()$
\end_layout

\end_inset

;
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Pi_{i=0}()$
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

üldine:
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_x()$
\end_layout

\end_inset

;
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_x()$
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

:tõenäosus:
\begin_inset ERT
status open

\begin_layout Plain Layout

$1-P(
\backslash
neg )$
\end_layout

\end_inset

;
\begin_inset ERT
status open

\begin_layout Plain Layout

$P()$
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

kvant?:lainefunktsioon?
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
P1 ja P2 
\begin_inset Quotes eld
\end_inset

sümmeetrilised
\begin_inset Quotes erd
\end_inset

? Seeega mõlemad ahelas?
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Asenada plato p1 platosse p2.
 Ehk võrdsustada plato p1 kvanteeritav plato p2 kvanteeritavaga.
 Ehk võrdsustada plato kvanteeritava p1 elementaarseosed plato p2 kavnteeritava
 elementaarseostega?
\begin_inset Newline newline
\end_inset

Iga plato kvanteeritava elementaarseosed(ka need mis on selle plato järglastes
 kirjeldatud) mistahes teise plato kvanteeritavaga peavad olema samad kui
 mistahes teise plato vähemalt ühe haru kvanteeritava elementaarseosed?
\begin_inset Newline newline
\end_inset

Iga kvanteeritava elementaarseosed(ka need mis on selle plato järglastes
 kirjeldatud) mistahes teise kvanteeritavaga peavad olema samad kui mistahes
 teise plato vähemalt ühe haru kvanteeritava elementaarseosed?
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
plato p_i kirjeldab ka eelasi, aga plato harunumber n_i ei kirjelda, et
 mis on selle haru eelased.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
ks P2(i)'ga võrdsustatakse P1(i) või P2(i) haruga?
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Kui ÜV jaoks vaja ainult jaatatud harusid kontrollid, siis on vaja 
\begin_inset ERT
status open

\begin_layout Plain Layout

$2^K$
\end_layout

\end_inset

 korda vähem harusid kotrollida, sest keskmiselt on igal tasemel 2 korda
 vähem jaatatud harusid kui harusid kokku.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
onhulk(x) aseme panna eestikeelne_nimetus_on(UTFencoodingus(
\begin_inset Quotes eld
\end_inset

hulk
\begin_inset Quotes erd
\end_inset

),x) kui seda teisendada tavakeelde, siis lihtsalt need abipredikaadid vahele
 jätta.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Kui võtta konstantsed predikaadid ja defineerida kasutaja predikatide asemel
 booleantagastusega funktsioonid, siis saab piirata predikaatide arvu ja
 predikaatide argumentide arvu(vähemalt 3 on iga väite kirjeldamiseks vajalik),
 aga mitte K'd.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Vist on paremini sõnastud sama tähendusega lõik olemas, aga jätan ka selle
 lõigu siia: 
\begin_inset Quotes eld
\end_inset

piisab kui kontrollida et ükski vorm, kus igale platole p1, kuhu pääseb
 ilma eitusi läbimata, on kooskõlisuse kontrollimiseks pandud vastavusse(elemten
taarsetosed võrdsustatud), mistahes teine plato p2, kuhu pääseb ilma eitusi
 läbimata, ja kotrollitud, et see sobiks võiks täita selle haruga sama tingimust
, ei oleks üheselt vale.
 Samale p1'e võib asendada mitmele p2'ele vastavusse.
 p1 ja p2 on kooskülas kui need on kõigi asjadega samas elementaarseostes.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
panna minu AR(automated reasoning) algoritm kokku AI algoritmidega nii et
 AI leiab optimeerimiseks häid tingimusi ja hüpoteese mida AR saab kontrollida
 näiteks korrapärade tõttu kastaja sisendis.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Seoe mitte üheselt valesuse(kehtestavuse) tõestamiseks piisab kontollimises,
 et üks lubatud lõpprida ei ole pheselt vale.
 väite mitte üheselt tõesuse tõestamiseks piisab kontrollimisest, et väite
 eituse vähemalt üks lubatud lõpprida ei ole pheselt vale.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Et kontrolida kas väide on kirjeldatav väiksema K'g ei tule kontrolida mite
 lõppridu erldi vaid lõppveergu.
 Siis(kuid vist mitte ainult siis) kui väide on kirjeldatav väiksema K'ga
 kui kõrgeima taseme kvantori sisu ei sõltu osadest kvateeritavatest.
 Vahest üheselt valede ja madlama K'ga esitatavate koos kontrollimine on
 matemaatiliselt ilus.
\end_layout

\begin_layout Standard
Vahest on kasulikum jätta lõppridade asemel hoopis Lõõpveerge vahele, mis
 jaatavad üheselt valesid ridu?
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Gödeli teoreemide kohaselt ei saa tõestada, et peano aksioomid on kooskõlalised,
 aga ometi on selge, et need on kooskõlalised.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Huvitav on väide, et 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_x(False)$
\end_layout

\end_inset

, ehk 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg 
\backslash
exists_x(True)$
\end_layout

\end_inset

 ehk ei eksisteeri midagi.
 Ma pole kindel, et kas see on üheselt vale või mitte.
 Sellise võimaluse lubatust kirjeldab DNF vormis kõige viimane lõpprida.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
https://community.wolfram.com/groups/-/m/t/2416379 : Why does Wolfram|Alpha
 not return True for following inputs:
\end_layout

\begin_layout Standard
trueQ[!(Exists[x,Exists[y,A[x,y]]] && !Exists[x,Exists[y,A[y,x]]])] Simplify[!(E
xists[x,Exists[y,A[x,y]]] && !Exists[x,Exists[y,A[y,x]]])]
\end_layout

\begin_layout Subsection*
Lineaarne esitusviis.
\end_layout

\begin_layout Subsubsection*
predikaadid min tasemel
\end_layout

\begin_layout Standard
ei tööta vist in nt järgneva LRi korral:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg E(A(x_1)
\backslash
land 
\backslash
neg E(D(X_1,x_2)))
\backslash
land 
\backslash
neg E(B(x_1)
\backslash
land 
\backslash
neg E(D(x_2,x_1)))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
predikaadid max tasemel
\end_layout

\begin_layout Standard
kujul 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg E(
\backslash
neg E(
\backslash
neg E(
\backslash
neg E(
\backslash
neg E(
\backslash
neg E(
\backslash
neg E(
\backslash
neg E(BOOL(predikaatväited)))))))))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
võibolla selliste väidete lihtsustamist(sh.
 üheselt valede ridade otsimist) ei saagi algorimilselt teha ja see tekitab
 teadvust.
\end_layout

\begin_layout Standard
defineerida ka loogiliste tehete omavahelised väited nt
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_{x_1}(
\backslash
forall_{x_2}(VOI(x,y)
\backslash
iff 
\backslash
neg JA(
\backslash
neg x,
\backslash
neg y)))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rakendada mingit algoritmi, mis on mõeldud suvalise 
\begin_inset Quotes eld
\end_inset

madala entroopiaga
\begin_inset Quotes erd
\end_inset

 data kokku pakkimiseks.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kõigi hulkade kohta ei või väiteid teha
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kõigi hulkade kohta võib väiteid teha
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kvatorid kehtivad ka alghulkade kohta
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kvatorid ei kehti ka alghulkade kohta
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

$2^{N^2}
\backslash
cdot(2^{2^N}-1)^{2^{N+1}}$
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

$2^{2^{2
\backslash
cdot N+1}+N^2}$
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$F_Q=
\backslash
sum^{2^{2
\backslash
cdot N+1}-1}_{n_v=0}(
\backslash
sum^{N-1}_{i_x=0}((
\backslash
left 
\backslash
lfloor 
\backslash
frac{Q}{2^{N^2-1-i_x
\backslash
cdot N-i_x}}
\backslash
right 
\backslash
rfloor mod_2 
\backslash
not
\backslash
leftrightarrow 
\backslash
left 
\backslash
lfloor 
\backslash
frac{n_v}{2^{2*N}}
\backslash
right 
\backslash
rfloor mod_2)
\backslash
wedge(n_v mod_{2^N} =~(Q 
\backslash
cdot 2^{N*(1+i_x-N)})mod_{2^N})
\backslash
wedge 
\backslash
Pi^{N-1}_{j=0}(
\backslash
left 
\backslash
lfloor 
\backslash
frac{Q}{2^{N^2-1-j*N-i_x}}
\backslash
right 
\backslash
rfloor mod_2 
\backslash
not
\backslash
leftrightarrow 
\backslash
left 
\backslash
lfloor 
\backslash
frac{n_v}{2^{2*N-1-j}}
\backslash
right 
\backslash
rfloor mod_2)))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kõigi hulkade kohta ei või väiteid teha
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kõigi hulkade kohta võib väiteid teha
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kvatorid kehtivad ka alghulkade kohta
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kvatorid ei kehti ka alghulkade kohta
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<$2^{2^{K(K+N
\backslash
cdot2)}+N^2}$
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
KOGU_INFO on väide, mis sisaldab kogu tõest infot kige kohta.
 Loomulikult seda KOGU_INFOT ei ole mul kuhugi salvestatud.
 See on lihtsalt abstraktne mõiste.
\end_layout

\begin_layout Subsubsection*
vastuolulisuse valesususe erinevus
\end_layout

\begin_layout Paragraph*
vastuolulisus(ehk üheselt valesus)
\end_layout

\begin_layout Standard
Mingi väide V on ÜV kui väide, mis saadakse lisades väite ette eksistentsiaalsus
kvantorid, nende sisse et need kvanteeritavad on booleanfinktsioonid ja
 asendades predikaadid V's nende kvantorite kvanteeritavatega.
\end_layout

\begin_layout Standard
näiteks väide 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
exists(A(1,2)
\backslash
land 
\backslash
exists(A(2,3))))
\backslash
land 
\backslash
neg 
\backslash
exists(A(1,1) 
\backslash
lor 
\backslash
exists(A(1,2)
\backslash
land A(2,1)))$
\end_layout

\end_inset

 ei ole vastuoluline, sest väide 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_booleanfunktsioon(x_1) 
\backslash
land ( 
\backslash
exists(
\backslash
exists(x_1(1,2)
\backslash
land 
\backslash
exists(x_1(2,3))))
\backslash
land 
\backslash
neg 
\backslash
exists(x_1(1,1) 
\backslash
lor 
\backslash
exists(x_1(1,2)
\backslash
land x_1(2,1))))$
\end_layout

\end_inset

 ei ole vale.
\end_layout

\begin_layout Standard
näiteks väide 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
exists(A(x_1,x_2)
\backslash
land 
\backslash
exists(A(x_2,x_3)
\backslash
land A(x_2,x_2))))
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
exists(
\backslash
exists( A(x_2,x_1)
\backslash
land A(x_1,x_3)
\backslash
land A(x_1,x_1))))$
\end_layout

\end_inset

 on vastuoluline, sest väide 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_booleanfunktsioon(x_1) 
\backslash
land 
\backslash
exists(
\backslash
exists(x_1(x_2,x_3)
\backslash
land 
\backslash
exists(x_1(x_3,x_4)
\backslash
land x_1(x_3,x_3))))
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
exists(
\backslash
exists(x_1(x_3,x_2)
\backslash
land x_1(x_2,x_4)
\backslash
land x_1(x_2,x_2)))))$
\end_layout

\end_inset

 on vale.
\end_layout

\begin_layout Paragraph*
valesus
\end_layout

\begin_layout Standard
Väide on vale kui selle jaatus 
\begin_inset ERT
status open

\begin_layout Plain Layout

$KOGU
\backslash
_INFO$
\end_layout

\end_inset

'ga on vastuoluline.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$VALE(VÄIDE) 
\backslash
leftrightarrow ÜV(VÄIDE 
\backslash
land KOGU
\backslash
_INFO)$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
üheselt tõesus
\end_layout

\begin_layout Standard
Mingi väide V on ÜT kui väide, mis saadakse lisades väite ette univrsaalsuskvant
orid, nende sisse et need kvanteeritavad on booleanfinktsioonid ja asendades
 predikaadid V's nende kvantorite kvanteeritavatega.
\end_layout

\begin_layout Standard
näiteks väide 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
exists(A(1,2)
\backslash
land 
\backslash
exists(A(2,3))))
\backslash
land 
\backslash
neg 
\backslash
exists(A(1,1) 
\backslash
lor 
\backslash
exists(A(1,2)
\backslash
land A(2,1)))$
\end_layout

\end_inset

 ei ole vastuoluline, sest väide 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_booleanfunktsioon(x_1) 
\backslash
land ( 
\backslash
exists(
\backslash
exists(x_1(1,2)
\backslash
land 
\backslash
exists(x_1(2,3))))
\backslash
land 
\backslash
neg 
\backslash
exists(x_1(1,1) 
\backslash
lor 
\backslash
exists(x_1(1,2)
\backslash
land x_1(2,1))))$
\end_layout

\end_inset

 ei ole vale.
\end_layout

\begin_layout Standard
näiteks väide 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
exists(A(x_1,x_2)
\backslash
land 
\backslash
exists(A(x_2,x_3)
\backslash
land A(x_2,x_2))))
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
exists(
\backslash
exists( A(x_2,x_1)
\backslash
land A(x_1,x_3)
\backslash
land A(x_1,x_1))))$
\end_layout

\end_inset

 on vastuoluline, sest väide 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_booleanfunktsioon(x_1) 
\backslash
land 
\backslash
exists(
\backslash
exists(x_1(x_2,x_3)
\backslash
land 
\backslash
exists(x_1(x_3,x_4)
\backslash
land x_1(x_3,x_3))))
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
exists(
\backslash
exists(x_1(x_3,x_2)
\backslash
land x_1(x_2,x_4)
\backslash
land x_1(x_2,x_2)))))$
\end_layout

\end_inset

 on vale.
\end_layout

\begin_layout Paragraph*
tõesus
\end_layout

\begin_layout Standard
Väide on tõene kui selle jaatus 
\begin_inset ERT
status open

\begin_layout Plain Layout

$KOGU
\backslash
_INFO$
\end_layout

\end_inset

'ga ei ole vastuoluline.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$TÕENE(VÄIDE) 
\backslash
leftrightarrow 
\backslash
neg ÜV(VÄIDE 
\backslash
land KOGU
\backslash
_INFO)$
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
teisest failist
\end_layout

\begin_layout Standard
Uue praktilise töö eesmärgid
\end_layout

\begin_layout Standard
Sissejuhatus Käesoleva praktilise töö eesmärk on luua programm, mis suudab
 etteantud loogikalause põhjal kasutaja küsimustele vastata, loogikalauseid
 minimaalse vabadusastmega kirja panna, väite keerukust hinnata, loogikalauseid
 inimkeeles kirja panna, loogikalauseid, mis sisaldavad füüsikalisi algmõisteid
 illustreerida (nt.
 Punktmassi koordinaatide sõltuvusest ajast graafiku joonistadades) ja loogikali
si lauseid elemetaartehete(elementaartehteid omakorda LaTeXi või mõne programmer
imiskeele sütnaksi) abil estada kui see võimalik on.
 Programmil on ka kasutaja liides tuntumate „asjade” (füüsikaliste mudelite)
 omadusi kirjeldavate lausete parameetrite abil moodustamiseks.
\end_layout

\begin_layout Standard
Eesmärgid:
\end_layout

\begin_layout Itemize
Füüsikaline seos on seos füüsikaliste mõistete vahel.
\end_layout

\begin_layout Itemize
Juhul kui ühest kujust teise teisendamine ei eelda ühegi füüsikalise suuruse
 vahelise seose teadmist on tegu tähistuse küsimusega.
\end_layout

\begin_layout Itemize
Päris-mõiste on mõiste, mis tähistab midagi, mis on päriselt olemas ja omab
 füüsikalist tähendust ega sõltu mudelist ega tähistusest, milles seda kirjeldat
akse.
\end_layout

\begin_layout Itemize
Lause keerukus on seda kirjeldava loogikalise lause eelmainitud viisil kirjapand
ud värgi suurus (juhul kui see on naturaalarvuna kirja pandud).
\end_layout

\begin_layout Itemize
Füüsikalise väite(mudeli) kasulikkus on seda suurem, mida täpsemalt see
 katseandmetega klapib ja mida lihtsam see on(mida väiksem on selle keerukus).
 Lihtsus on ilmselt õige hinnata kui füüsikalised suurused on kirjapandud
 minimaalsel vabadusastmel ja ja võimalikult sümmeetriliselt(ruumiline ja
 ajaline sümmeetria näiteks).
\end_layout

\begin_layout Itemize
Kasutajale esitatakse väited ja loogikalaused matemaatiliste mõistee abil
 (nt.
 Liitmine, korrutsamine, universaalsuskvantor, loogikalisted tehted(nt.
 XOR, AND, OR, NAND, NOR)).
\end_layout

\begin_layout Itemize
Ka matemaatilisised mõisted tuleb igas väites ja loogikalauses matemaatiliste
 algmõistete abil defineerida.
\end_layout

\begin_layout Itemize
Luua kasutaja liides erinevaid spetsiifilisi olukordi kirjeldavate väidete
 (Nt.
 N-keha probleemi põhivõrrandite erinevates lähendustes) mugavaks kirja
 panemiseks.
 • Luua programm, mis teisendab sisestatud väiteid erinevate algmõistete
 vahel.
\end_layout

\begin_layout Itemize
Luua programm, mis teisendab väite esitust nii, et sama väide oleks alati
 samal kujul kirja pandud.
\end_layout

\begin_layout Itemize
Eristada selgelt matemaatilised algmõisted (funktsioon, võrdsus, hulk, implikats
ioon jne.(siin näitena toodud mõisted ei moodusta minimaalset funktsionaalselt
 täielikku hulka)) ja füüsikalised algmõisted (ruum, aeg, elektromagnetväli,
 elektrimagnetväli, gravitomagnetväli, gravitimagnetväli, aegruum).
 Võtta kasutusele ka füüsikalised mõisted, mis ei ole algmõisted (nt.
 konkreetsed ained, tahke, vedel, gaasiline, aatom).
\end_layout

\begin_layout Itemize
Defineerida kõik mõisted (sh.
 Arvud (sh.
 Naturaalarvud)) algmõistetes.
\end_layout

\begin_layout Itemize
Luua programm, mis teisendab väite esituse, kasutaja valitud algmõistetele.
 Kui valitud algmõisted ei moodusta funktsionaalselt täielikku rühma, siis
 annab programm veateate.
 Kui valitud algmõisted moodustavad funktsionaalselt täieliku, kuid mitte
 minimaalse, siis teisendab programm väite esitust niimoodi, et saadud esitus
 oleks võimalikult lihtne.
\end_layout

\begin_layout Itemize
Ükski tõestamatu väide ei tohi omada füüsikalist tähendust (näiteks ei oma
 koordinaatide alguspunkti valik füüsikalist tähendust.).
 Ükski füüsikalise tähenduseta väide ei tohi olla tõestatav.
 • Defineerdiaa ainult vastava füüsikalise seose kirjapanemiseks vajalik
 algebra.
\end_layout

\begin_layout Itemize
Füüsikalise mudeli, mis sisaldab suuruseid(nt.
 Aeg, kordinaat ja väljatugevus) , mida iseelommustakse reaalarvuga, kirjeldamis
eks tuleb deineerida vastavad aritmeetilised tehted reaalarvudele.
 Kas alati tuleb defineerida ka jagamine, et saaks väita nt.
 ,et üks suurus on teisest 3 korda suurem?
\end_layout

\begin_layout Itemize
Ainuke asi, mida me otseselt tajuda suudame on meie enese teadvus.
 Füüsikalist mõtet omavad mõisted (ehk on füüsikalised mõisted), mis kuidagi
 mõjutavad teadvust.
 Kuna ei ole olemas piisavalt head füüsikateooriat teadvuse kirjeldamiseks(selle
 teiste füüsikaliste suurustega „sidumiseks”), siis tuleb füüsikaliste süsteemid
e kirjeldamiseks kasutada mõisteid, mis ilmselgelt kaudselt(meeleelundite
 kaudu jõuab info ajju, mis mõjutab teadvust) meie teadvust mõjutavad.
 Mõistlik on selliseid suurusi, millest ainult intuitiivselt võib aru saada(füüs
ikalised algmõisted),võimalikult vähe(valida minaalne funktsionaalselt täielik
 algmõistete hulk) kausutada ja teised mõisted (füüsikalised mitte-alg mõisted)
 nende kaudu defineerida.
\end_layout

\begin_layout Itemize
Gödeli teoreem ütleb, et iga piisava artmeetikaga seoses on vähemalt 1 väide,
 mida ei saa tõestada, ümberlükata ega tõestada, et seda ei saa tõestada.
 Kas siis kui teha mingi pikkusega üritus tõestada üritamiseks saab öelda,
 et mingi tõenäosusega seda tõestada ei saa? Kas kui pikkus on piisav, siis
 peaaegu kindlasti ei saa seda tõestada? • Kui füüsikalise suuruse(näiteks
 asukoht) väärtus võib olla null, siis on ka null algmõiste.(vist)
\end_layout

\begin_layout Itemize
Korrutamise (ja tesite matemaatiliste mõistete) intuitiivsed omadused tulevad
 välja alles arvude füüsikaliste algmõistetega(näiteks geomeetriliste(nt.
 Pikkuse või nurga)) seostamisel.
 Matemaatika aksioomid peavad looma ainult seoseid matemaatiliste mõistete
 vahel.
 Ei pea muretsema selle üle, et matemaatilistest aksioomidest ei järeldu,
 et arvteljed ei ole „välja venitatud”.
\end_layout

\begin_layout Itemize
Sulud on selle genereeritud „tavakeele” süntaksis sees.
 „(„ hääldatakse SU ja „)” hääldatakse US.
\end_layout

\begin_layout Itemize
eelliide(prefix) näitab, et kas sõna on kasutatud ranges või vabas(analoogiana
 või naljana) tähenduses.
 
\end_layout

\begin_layout Itemize
Veergude omavahel jaatamisega(konjukteerimisega) ja neile valikuliselt eituse
 ja jaatuse ette panemisega peab saama ühe viisisl moodustada kõik read.
 • Read on väited, mille vabalt valitud elementide omavahel võitamisega(disjukte
erimisega) peab saama ühel viisil moodustada mistahes väite, mida antud
 N’i(alghulkade arvu) ja K(kvantorite arvu) puhul saab moodustada.
\end_layout

\begin_layout Itemize
Rida: [alghulkade vahelised seosed]JA KVANTOR([mis alghulkadesse kvanteeritav
 kuulub] TO [millistesse alghulkadesse kuulub])JA MITTE KVANTOR([mis alghulkades
se kvanteeritav kuulub] TO [millistesse alghulkadesse kuulub])
\end_layout

\begin_layout Itemize
Tuleb eeldada, et kõik hulgad, mida saab defineerida on olemas, sest muidu
 ei saa ühegi hulga puhul kindel olla, et kas see on olemas (kui mingis
 teoorias mingite omadustega hulki ei ole, siis teha eraldi hulk hulkadest,
 mis selles teoorias olemas on.).
 PF! Programm peaks selliseid väiteid siiski lugeda oskama, et kasutajale
 veateade väljastada.
 • Peaaegu kunagi ei ole K=1 korral veergude arv täisarv.
 K=0 puhul on alati veerge täisarv.
\end_layout

\begin_layout Itemize
Ridasid on vist alati täisarv.
 Seega on kõik bittide kombinatsiooonid „sisus” lubatud.
 Ehk kõi võimalused veergude bittididega täitmiseks lubatud.
\end_layout

\begin_layout Itemize
K näitab, et kui „sügaval” kvantorite ,sees kõige „sisemine” seos on.
 O
\end_layout

\begin_layout Itemize
N näitab, et kui palju alghulki on.
\end_layout

\begin_layout Itemize
NP probleem panna kirajakvantoritega kujul.
 See seab kvanteeritavale tingimuse, et kas see kuulub (õigete) vastuste
 hulka.
 ∀x(TINGIMUS(x) TO x∈VASTUSED).
 Iga probleem on niimoodi kirjeldatav.
 Teha uus seos, mis kirjeldab pakutavat.
 Jaatada probleemi kirjeldavat seost ja pakkumist kirjeldatavat seost.
 NB.
 See ainult kontrollib pakutud vasuse tõesust!
\end_layout

\begin_layout Itemize
Loenduva hulga puhul saab booleansumma asendada universaalsuskvantoriga
 ja korrutise eksistentsiaal kvanotriga.
 (symbolitega seletada)
\end_layout

\begin_layout Itemize
NP probleemi paremaks sõnastamiseks tuleks kirja panna, et millistele tingimuste
le peab (protsessor) ühe sammuga tehtavad operatsioonid vastama, alles siis
 uurida ,et kas sammude arv on polünoomilises seoses sisendi pikkusega.
 Need tingumused võiks olla näiteks: 1.
 võimalikke operante kindel (lõplik) arv (seega on võimalik iga võimaliku
 operandi mingis kindlas vahemikus olevatele naturaalarvudele bijekteerida.).
 2.
 operatsiooni operande kindel (lõplik) arv.
\end_layout

\begin_layout Itemize
Kas K’l on piir? Kas näiteks mingi funktsioon (näiteks ∀f(f∈F↔∀x(f(x))))
 ei saa asendada kvantoreid?
\end_layout

\begin_layout Itemize
Ka arvutiprogramme saab sellisel viisil kirja panna, iga lähtekoodi real
 on lihtsalt ühe võrra suurem”käsu numbri argument”.
 See kirjeldaks programmi sisendi ja väljundi vahelist seost.
 • Kui kirja panna võimalikud „elementaarkäsud”(ja nende täitmiseks kuluva
 protsessori taktide arvu) saab kirjeldada seose, milles on otsitavaks programm
 kõige optimiseeritumal kujul.
\end_layout

\begin_layout Itemize
Sisendi optimeerimismeetodiks võib kaaluda masinõppe algoritmide kasutamist.
\end_layout

\begin_layout Itemize
Kui tõestuses järeldub mingist sammust ka eelmine samm, siis teha kahepoolse
 noole üks ots halliks.
 Halliks tagasi suund.
 
\end_layout

\begin_layout Subsubsection*
Näited:
\end_layout

\begin_layout Standard
Siin on mõned näited füüsikalistest süsteemidest ja tähistusviisidest.
\end_layout

\begin_layout Itemize
Füüsikaline mudel, mis ütleb, et kui on soe, siis ei ole külm; kui on külm
 siis ei ole soe; kui on suur, siis ei ole väike; kui on väike, siis ei
 ole suur.
 Matemaatilised algmõisted: NAND, sulud Füüsikalised algmõisted: soe; külm;
 suur; väike Seos: ((soe NAND külm) NAND (suur NAND väike)) NAND ((soe NAND
 külm) NAND (suur NAND väike))
\end_layout

\begin_layout Enumerate
Füüsikaline süsteem, milles on 2 punktkeha, mille omavaheline kaugus on
 1 meeter: Matemaatilised algmõisted: Füüsikalised algmõisted: meeter, ruumipunk
t, punktkeha
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
begin{cases}
\end_layout

\begin_layout Plain Layout


\backslash
forall(a;
\backslash
forall(b;
\backslash
forall(c;f(a;b;c)=f(a;b-1;f(a;b;c-1)))))
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(a;
\backslash
forall(b;f(a;b;2)=f(a;b-1;a)))
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(a;
\backslash
forall(c;f(a;0;c)=(a=c)+c+1))
\end_layout

\begin_layout Plain Layout


\backslash
end{cases}
\backslash

\backslash
$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$
\backslash
begin{cases}
\end_layout

\begin_layout Plain Layout


\backslash
forall (o;N(o)=0)=0
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

N(a)=N(S(a))
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

N(a) 
\backslash
wedge N(b) 
\backslash
wedge (F(c)=F(S(c))) = F(b)
\end_layout

\begin_layout Plain Layout


\backslash
end{cases}$%matemaatilised almoisted: võrdsus[=];funktsioon[f];universaalsus
 kvantor[
\backslash
forall];tõde[1];vale[0] %
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Seose standard vorm:
\end_layout

\begin_layout Standard
Seose lahendite leidmiseks tuleb leida „sobivuse” lokaalsed maksimumid.
 B_1(n_1,;n_2) on bijektiivne funktsioon, millel on 2 argumenti.
 Need argumendid on naturaalarvud.
 See võrdub mistahes argumentide korral naturaalarvuga.
 B_2(q) on bijektiivne funktsioon, mille argumendiks on ratsionaalarvud.
 See võrdub mistahes argumendi korral naturaalarvuga.
 B_3 on bijektiivne funktsioon, mille argumendiks on füüsikaliste suuruste
 väärtused.
 See võrdub mistahes argumendi korral naturaalarvuga.
 R on seose standardformi funktsioon.
 See võrdub 1 kui R(B_1(B_3(S_1);B_3(S_2))) S_1 sobib paremini mudeliga
 kui S_2 .
 See võrdub 0 kui R(B_1(B_3(S_1);B_3(S_2))) S_2 sobib paremini mudeliga
 kui S_1 .
\end_layout

\begin_layout Paragraph*
Alternatiivslt:
\end_layout

\begin_layout Standard
R on seose standardformi funktsioon.
 See võrdub 1 kui R(B_1(B_3(S_1);B_3(S_2))) S_1 sobib paremini mudeliga
 kui S_2 ja B_3(S1)>B_3(S2) .
 See võrdub 0 kui R(B_1(B_3(S_1);B_3(S_2))) S_1 sobib paremini mudeliga
 kui S_2 ja B_3(S1)<B_3(S2).
 See võrdub 0 kui R(B_1(B_3(S_1);B_3(S_2))) S_2 sobib paremini mudeliga
 kui S_1 ja B_3(S1)>B_3(S2) .
 See võrdub 1 kui R(B_1(B_3(S_1);B_3(S_2))) S_1 sobib paremini mudeliga
 kui S_2 ja B_3(S1)>B_3(S2) .
\end_layout

\begin_layout Standard
Variant 2 (SEOS AND X)=seos on (SEOS TO X) seosest järeldub X
\end_layout

\begin_layout Standard
ilm on ilus: ILM 
\backslash
in ILUSAD asukohas (0;0) on väljatugevus 0: X 
\backslash
in PUNKTID 
\backslash
and X 
\backslash
in NULISEXGAD 
\backslash
and X 
\backslash
in NULLISEYIKAD 
\backslash
to 
\backslash
any_x(0 
\backslash
in X 
\backslash
to X 
\backslash
in X)
\end_layout

\begin_layout Standard
Defineerida tehted naturaalarvudele robinsoni aritmeetika või millegi analoogseg
a ja aksiomeerida, et tehted on lõputult diferentseeritavad.
 Defineerida tehted naturaalarvudele robinsoni aritmeetika või millegi analoogse
ga ja panna tehted füüsikaliste suurustega kirja justkui need oleksid naturaalar
vud (kuigi ei ole).
 Valida bijektiivne funktsioon ratsioonalarvudest naturaalarvudesse ja defineeri
da tehted ratsionaalarvudele neile selle funktsiooni abil vastavate naturaalarvu
de kaudu.
 Defineerida tehted selle kaudu, et milline füüsikaline olukord oleks sama
 kui füüsikaline olukord, mille üks parameetritest on saadud tehte tulemusena.
 Kahes pakkumises bijektiivse funktsiooni abil mappida kõik ratsionaalarvud(või
 muu pidev hulk) natuaalarvudeks ja anda „seosele” sisendiks.
 Mappitud ratsionaalarvude järjekord määrab, et milline neist millist füüsikalis
t suurust tähistab.
 Seos tagastab, et kumb pakkumine oli parem.
\end_layout

\begin_layout Standard
q1*q2=q3 on sama mis f(B(q1);B(q2))=B(q3)
\end_layout

\begin_layout Standard
Nii saab ainult reaalarvulisi suuruseid kirjeldavaid seoseid kasutada.
\end_layout

\begin_layout Standard
K1Seose kirjeldamine K1seos on seos hulkade vahel, mille, kirjeldamiseks
 (kvantorite, kuulumisväidete ja booleanide vaheliste tehete abil) ei ole
 kvantorite sees kvantoreid (näiteks ∀x(x∈A)↮∀x(x∈B) on K1seos, aga ∀x(x∈A→∀y(y∈
x→y∈y)) ei ole K1 seos).
 K1 on seos, mille nestedness on 1.
 K1seose üheseks kirjeldamiseks peab kirjeldama kõigi erineva sisuga kvantorite
 ja alghulkade omavaheliste kuulumiste vahelisi seoseid.
 Selle seose kirjeldamiseks läheb vaja _..._ bitti.
 Kui neid bitte tõlgnedada kahendsüsteemis arvuna saab saab seda seost üheselt
 kirjeldada naturaalarvuga (valem) ,mis on väiksem kui (2**(valjalike bittide
 arv)).
 Kuna erinevate sisudega kvantorid on omavahel sõltuvad, siis piisab kui
 kirjeldada selliste sisudega kvantorite ja alghulkade kuulumiste vahelist
 seost, millest saab järeldada mistahes teiste sisudega kvantorite ja alghulkade
 kuulumiste mistahes booleakombinatsiooni, mis pole sõltumatult kirjeldatavast
 K1seosest vale.
 Ükskõik milliste sisudega kvantorid selleks valida, on osad booleankombinatsioo
nid neist sõltumatult kirjeldatavast K1seosest valed.
 See järeldub sellest, et nende booleankombinatsioonide arv, mis ei ole
 kindla väärtusega, ei ole esitatav kujul 2 astmes mingi naturaalarv.
 Osade sisudega kvantoritest(aga mitte nende eitustest) järeldub ka väiteid
 alghulkade omavaheliste kuulumiste kohta(näiteks ∀x(x∈A)⇒A∈A), aga alghulkade
 omavahelistest kuulumistest ei järeldu väiteid kvantorite kohta.
 Kui mingist kvantorite ja alghulkade vaheliste seoste booleankombinatsioonist
 järeldub, mingi väide alghulkade kohta ja on samas eitatud, siis on see
 booleakombinatsioon sõltumatult kirjeldatavast K1seosest vale.
 Seos ei tohi teha väiteid kõikide hulkade kohta(sest _.._).
 Teisisõnu ei tohi sellest järelduda, et mingite elementidega hulki ei ole
 olemas.
 Kui mingite sisudega kvantorite booleankombinatsioon seda teeb, siis on
 see booleakombinatsiooni sõltumatult kirjeldatavast K1seosest vale.
 Näiteks väitest ∀x(A∈x) järelduks, et sellist hulka, mis ei sisalda A’d(näiteks
 tühi hulk) ei ole olemas, seega on see väide vale.
\end_layout

\begin_layout Standard
Hea viis seose K1esitamiseks on luua üksühene vastavus võimalike seoste
 ja naturaalarvude vahele.
 Hea on kui sellisel kujul estitatud seoste vahel saab rakendada operaatoreid(AN
D OR NOR) rakendades neid vastavatele arvule bit kaupa.
 Hea on kui tavalises notatsioonis lühidalt kirjapandav seos on kaväikese
 või lihtsasti kirjeldatava naturaalarvuga vastavusse pandud.
 Konkreetsem näide Üks võimalus K1seose kirjledamiseks on teha DNF tabel(see
 pole suurema algmõistete arvuga seoste puhul mõistlik, sest võtab palju
 mälu, aga selle eeliseks on see, et siis saab sama algmõistete arvuga K1seoste
 vahelisi operatsioone teha lõppveeru vastavaid bittide(booleanide) vahel
 sama operandi rakendades), mille veergudeks on erineva sisuga kvantorid.
 Aga kuna erineva sisuga kvantorid on omavahel sõltuvad, siis piisab kui
 tabeli veergudeks võtta (ükskõik kas eitatud või eitamata) kvantorid sisuga,
 et P(x) pole mingi kindla väärtusega.
 Ja väited alghulkade omavahelise kuuluvuse kohta.(täpsemat kirjledust vaja
 sh.
 Veergude järjekorra kohta,) • ∀x(¬P(x)=n) ehk ¬∃(P(x)=n) või • ¬∀x(¬P(x)=n)
 ehk ∃(P(x)=n) Isegi sellise veergude valiku korral on need DNF tabeli read,
 mis väidavad et kõigil hulkadel on mingi omadus, (näiteks ∀x(x∈x), ∀x(A∈x),
 või ∀x(x∈x∨A∈x)) kindlalt False väärtusega! P on funktsioon, mis loob bijektiiv
se seose, argumendiks oleva hulga alghulkade sisaldavuse ja alghulkades
 sisaldumise, ning 2N*2+1 väiksemaid naturaalarve sisaldava hulga vahele.
 Üks võimalus P defineerimiseks on teha DNF tabel, mille veergudeks on (ükskõik
 kas eitatud või eitamata) väited(veergude järjekord on oluline), et kvanteerita
v kuulub mingisse alghulka, et kvanteeritav on iseenda element ja, et mingi
 alghulk kuulub kvanteeritavasse.(täpsemat kirjeldust vaja sh.
 veergude järjekorra kohta,) • P=∑_i=0N^2 (2**i*(Hi∈)+) või • P=∑_i=0N^2
 (2**i*¬())
\end_layout

\begin_layout Standard
(veerust tehtav järeldus(vihikus olemas)) (lõppreast tehtav järeldus(vihikus
 olemas)) (seosest, mis on on esitatav arvuna tehtav järeldus) Selliselgi
 juhul on osad lõppread sõltumata kirjeldatavast K1seosest kindlalt valed(vastav
 boolean peab olema False).
 Üks võimalus saada minimaalsel vabadusastmel kirjeldus on teha uus numeratsioon
 lõppridadele, mis jätab need read, mis on sõltumata kirjeldatavast K1seosest
 valed, vahele.
 Üheselt valed on need read, mis teevad väiteid kõigi hulkade kohta või
 on vastuolulised, sest kvantoritega veergudest järeldub alghulkade kohta
 midagi, mis on vastuolus alghulkade omavahelisi kuulumise kirjeldavate
 veergudega.
 Lõppreast tehtav järeldus alghulkade kohta on järmine: (lõppreast tehtav
 järeldus alghulkade kohta(vihikus olemas)) Kui see on vastuoluline, siis
 tuleb tuleb vastav lõpprida uues numeratsioonis vahel jätta, sest kvantoritega
 veergudest järeldub alghulkade kohta midagi, mis on vastuolus alghulkade
 omavahelisi kuulumise kirjeldavate veergudega..
 Järgnev seos näitab, et millised read on vastuolulised: (funktsioon ,mis
 võtab argumendiks täisarvu (lõpprea numbri) ja tagastab booleani(,et kas
 see on vastuoluline, sest kvantoritega veergudest järeldub alghulkade kohta
 midagi, mis on vastuolus alghulkade omavahelisi kuulumise kirjeldavate
 veergudega.))
\end_layout

\begin_layout Standard
(funktsioon ,mis võtab argumendiks täisarvu (lõpprea numbri) ja tagastab
 booleani(,et kas see on vastuoluline, sest teeb kõigi hulkade kohta väite.)(vihi
kus olemas))
\end_layout

\begin_layout Standard
(funktsioon ,mis võtab argumendiks täisarvu (lõpprea numbri) ja tagastab
 booleani(,et kas see on vastuoluline))
\end_layout

\begin_layout Standard
(seosest, mis on on esitatud naturaalarvuna tehtav järeldus, kus on eeldatud
 uut lõppveergude numeratsiooni.)
\end_layout

\begin_layout Section*
Sisemisest funktsioonist
\end_layout

\begin_layout Subsection*
mõte1
\end_layout

\begin_layout Paragraph*
mõte: 
\color yellow
Tundub edukas JÄTKATA
\end_layout

\begin_layout Standard
1.
 kirjeldada meetod kuidas reabooleanid sisendist määratakse
\end_layout

\begin_layout Standard
2.
 Millised read on sellest järelduvalt väite argumendst sõltumatult valed.
\end_layout

\begin_layout Paragraph*
teostus:
\end_layout

\begin_layout Standard
1.
 kvantorite sisud alates kõige sisemisest seosfunktsioonide väärtuste vahelistek
s booleanfunktsioonideks.
\end_layout

\begin_layout Standard
2.rekusiivselt (alates kõige sisemisest kvantorist) asendab kõik kvantorid
 veergude vahelise booleanfunktsiooniga.
 Selleks asendatakse kvantori sisusse veerule vastavad kvanteeritavate vaheliste
 väidete väärtused, et määrata tingimus, mil antud veerg on jaatatud/eitatud.
 iga veeru jaoks asendatakse kvantori sisusse veerus olevad väited kõigis
 erinevates järjekordades.(st.
 kõik võimalused kus sisu kvanteeritavate asemele pannakse veerus olevad
 kvanteeritavad.
 Ühte veeru kvanteeritavat võib ka mitme asja asemele panna.).
\end_layout

\begin_layout Standard
3.
 Kui mingi välimiste kvanteeritavate väärtuste puhul teeb kvantor madalama
 taseme väite, siis...
\end_layout

\begin_layout Subsection*
mõte2
\end_layout

\begin_layout Paragraph*
mõte:
\end_layout

\begin_layout Standard
Millised täpselt on veergude vahelised seosed tasemetga variandis?
\end_layout

\begin_layout Paragraph*
teostus:
\end_layout

\begin_layout Standard
veerg on väite argumendst sõltumatult vale kui see sisaldab seos-funktsioonide
 väärtuste booleankombinatsiooni, mis on eelmises tasemes keelatud.
\end_layout

\begin_layout Section
algoritm
\end_layout

\begin_layout Standard
algoritmi pseudokoodis.
\end_layout

\begin_layout Subsection
versioon2:
\end_layout

\begin_layout Enumerate
leiab millisei predikaate on väites kasutatud ja nummerdab need.
\end_layout

\begin_layout Enumerate
leiab kui mitme kvantori see on kõige rohkemate kvantorite sees olev väide
 (maksimaalne K väärtus).
\end_layout

\begin_layout Enumerate
rekusiivselt: asendab iga eksistentsiaalkvantori funktsiooniga f, mis iga
 arvu puhul tagastab, et kas see arv võib olla plato numbriks.
 f(n) parajasti siis kui n võib olla plato number.
 Funktsioooni f loob programm kasutades kvantori kvanteeritava elementaarseoste
 madalama taseme kvanteeritavatega(tingimus plato numbri h osale) ja kvantori
 sees olevate platode(tingimus harumärkidele) vahelist booleanfunktsiooni.
 Kui kasutada on ainult NAND ja eksistensiaalkvantor (universaalsuskvantori
 ja teised loogikatehted on predikaatidena esitatud) võib funktsiooni f
 leidmise algritm üsna lihtne olla.
\begin_inset Newline newline
\end_inset

Osad lihtsustused(ÜV plato numbrite leidmine, mitte loogika lihtsustused)
 võib juba funktsiooni f leidmisel teha.
\end_layout

\begin_layout Enumerate
lõpuks saadud funktsioon f lõpprea kohta võimaldabki lõppveeru määrata.
\end_layout

\begin_layout Enumerate
Muutes funktsioone h ja harumärk konvertida väide kujule, milles ühegi numbriga
 lõpprida ei jaata ühselt valesid lõppridu, ükski väide ei ole esitatav
 malama K'ga ja pole ühtki predikaati, mille kohta ei ole mingeid väiteid
 tehtud.
\end_layout

\begin_layout Subsection
versioon5:
\end_layout

\begin_layout Enumerate
asendab 
\series bold
sisend
\series default
is kõik universaalsuskvantorid eksistentsiaalsuskvantoritega kasutades seost:
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall_x(f(x))=
\backslash
neg 
\backslash
exists_x(
\backslash
neg A(x))$
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
loob puugraafi lõppveerg-tüüpi tipu 
\series bold
LV.
\end_layout

\begin_layout Enumerate
parsib 
\series bold
sisend
\series default
'it rekusiivselt funktsiooniga 
\series bold
moodusta_puu
\series default
.
 Selle tagastatud puugraafi tippude järjendi iga elemendi tipu 
\series bold
LV
\series default
 haruks.
 ehk 
\series bold
LV
\series default
.harud:=
\series bold
moodusta_puu
\series default
(
\series bold
sisend
\series default
).
\end_layout

\begin_layout Enumerate
iga 
\series bold
LV
\series default
 haru 
\series bold
LR
\series default
 korral:
\end_layout

\begin_layout Enumerate
: iga 
\series bold
LR
\series default
ile rekusiivselt (ei pruugi otseselt alluda) alluva tipu 
\series bold
tipp
\series default
 korral:
\end_layout

\begin_layout Enumerate
: : iga funktsioonikutse 
\series bold
laiendatud_EKd
\series default
(
\series bold
tipp
\series default
) poolt tagastatud järjendis oleva 
\series bold
tipp
\series default
'u laiendatud alluva 
\series bold
laiendatud_EK
\series default
 korral:
\end_layout

\begin_layout Enumerate

\color red
kui laiendatud_EKsse tuleb eitatud kvantor poolikult(kõrgemad oksad puudu),
 siis see tugvendab eitatud_EKd, ja muudab algoritmi valeks.
\end_layout

\begin_layout Enumerate
: : : iga 
\series bold
tipp
\series default
'u eitatud haru 
\series bold
eitatud_EK
\series default
 korral:
\end_layout

\begin_layout Enumerate
: : : :kui funktsioonikutse 
\series bold
sisu_täpsem_kui
\series default
(
\series bold
laiendatud_EK
\series default
, 
\series bold
eitatud_EK
\series default
) tagastab, et 
\series bold
laiendatud_EK
\series default
 sisu on täpsem kui 
\series bold
eitatud_EK
\series default
 sisu (ja need on kooskõlas) ehk, et 
\series bold
laiendatud_EK
\series default
 sisust järeldub 
\series bold
eitatud_EK
\series default
 sisu ehk kui:
\end_layout

\begin_layout Enumerate
: : : : :kustutab 
\series bold
LV
\series default
st 
\series bold
LR
\series default
i.
\end_layout

\begin_layout Enumerate
: : : : :läheb punkti 4 ja võtab uue 
\series bold
LR
\series default
i.
\end_layout

\begin_layout Enumerate
: : : :kui funktsioonikutse 
\series bold
sisud_kooskõlas
\series default
(
\series bold
laiendatud_EK
\series default
, 
\series bold
eitatud_EK
\series default
) tagastab, et 
\series bold
laiendatud_EK
\series default
 sisu ja 
\series bold
eitatud_EK
\series default
 sisu on kooskõlas: 
\color red
(seda punkti pole vaja kui hiljem nagunii hiljem nagunii need LRid, millest
 täpsem variant olemas on, kustutatakse.
 Jääb ainult alles ainult see uus LR, millesse lisati see 
\series bold
eitatud_EK_omadus
\series default
, mis seal juba olemas oli)
\color inherit

\begin_inset Newline newline
\end_inset

: : : : :(sel juhul on kindlasti 
\series bold
eitatud_EK
\series default
 sisu täpsem kui 
\series bold
laiendatud_EK
\series default
 sisu või 
\series bold
eitatud_EK
\series default
 sisu on täpsuselt võrreldamatu 
\series bold
laiendatud_EK
\series default
 sisuga)
\end_layout

\begin_layout Enumerate
: : : : :lisab 
\series bold
tipp
\series default
u 
\series bold
laiendatud_EK
\end_layout

\begin_layout Enumerate
: : : : :iga 
\series bold
eitatud_EK
\series default
 haru ja predikaatväite 
\series bold
eitatud_EK_omadus
\series default
 kohta:
\end_layout

\begin_layout Enumerate
: : : : : :teeb 
\series bold
LR
\series default
ist koopia 
\series bold
uus_LR
\series default
.
\end_layout

\begin_layout Enumerate
: : : : : :lisab 
\series bold
uus_LR
\series default
is 
\series bold
laiendatud_EK
\series default
'sse 
\series bold
eitatud_EK_omadus
\series default
'e, aga vastasmärgiga kui see 
\series bold
eitatud_EK
\series default
's oli.
 Peale seda enam 
\series bold
laiendatud_EK
\series default
 ja 
\series bold
eitatud_EK
\series default
 sisud kooskõlas ei ole.
\end_layout

\begin_layout Enumerate
: : : : : :kui 
\series bold
tipp
\series default
us pole 
\series bold
laiendatud_EK
\series default
st täpsema sisuga jaatatud haru:
\end_layout

\begin_layout Enumerate
: : : : : : :lisab 
\series bold
uus_LR
\series default
i 
\series bold
LV
\series default
sse.
\end_layout

\begin_layout Enumerate
: kui 
\series bold
LR
\series default
i ühegi 
\series bold
tipp
\series default
u ühegi 
\series bold
laiendatud_EK
\series default
 sisu ei olnud ühegi 
\series bold
eitatud_EK
\series default
 sisuga kooskõlas:
\end_layout

\begin_layout Enumerate
: : siis tagastab, et 
\series bold
sisend
\series default
 ei ole ÜV.
\end_layout

\begin_layout Enumerate
: kustutab 
\series bold
LV
\series default
st 
\series bold
LR
\series default
i.
\end_layout

\begin_layout Enumerate
kui 
\series bold
LV
\series default
s enam ühtegi haru ei ole, siis tagastab, et 
\series bold
sisend on
\series default
 ÜV.
\end_layout

\begin_layout Subsubsection
funktsioon 
\series bold
moodusta_puu
\series default
:
\end_layout

\begin_layout Enumerate
kui kutsutakse välja funktsioon 
\series bold
moodusta_puu
\series default
 argumendiga 
\series bold
sisend
\series default
, ehk 
\series bold
moodusta_puu
\series default
(
\series bold
sisend
\series default
), siis:
\begin_inset Newline newline
\end_inset

Loob puugraafi tipu 
\series bold
tipp
\series default
.
\end_layout

\begin_layout Enumerate
viib argumendiks oleva väite 
\series bold
sisend
\series default
 mitte-täielikku DNF-vormi 
\series bold
DNF_vorm
\series default
.
 Näiteks 
\series bold
sisend
\series default
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$sisend=(( 
\backslash
neg R_1 
\backslash
lor R_2)NOR(R_1 
\backslash
land R_3)) XOR (R_2 
\backslash
lor R_4)$
\end_layout

\end_inset

 puhul peale seda sammu 
\begin_inset ERT
status open

\begin_layout Plain Layout

$sisend=R_2 
\backslash
lor (R_3 
\backslash
land R_4) 
\backslash
lor (R_4 
\backslash
land 
\backslash
neg R_1) 
\backslash
lor (R_1 
\backslash
land 
\backslash
neg R_3 
\backslash
land 
\backslash
neg R_4)$
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
muudab 
\series bold
DNF_vorm
\series default
'i järjendiks eraldades selles omavahel võitatud olevad asjad.
 Näiteks 
\series bold
DNF_vorm
\series default
'i 
\begin_inset ERT
status open

\begin_layout Plain Layout

$DNF
\backslash
_vorm=E(A(x_4,x_1)
\backslash
land E(A(x_5,x_1)) 
\backslash
lor 
\backslash
neg E(A(x_2,x_5))
\backslash
land A(x_4,x_3)
\backslash
lor 
\backslash
neg E(B(x_1,x_2,x_5))
\backslash
land 
\backslash
neg E(A(x_4,x_5)) 
\backslash
land 
\backslash
neg A(x_4,x_2))$
\end_layout

\end_inset

 puhul peale seda sammu 
\begin_inset ERT
status open

\begin_layout Plain Layout

$DNF
\backslash
_vorm=[A(x_4,x_1)
\backslash
land E(A(x_5,x_1)),
\backslash
neg E(A(x_2,x_5))
\backslash
land A(x_4,x_3),
\backslash
neg E(B(x_1,x_2,x_5))
\backslash
land 
\backslash
neg E(A(x_4,x_5)) 
\backslash
land 
\backslash
neg A(x_4,x_2))]$
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Iga järjendis 
\series bold
DNF_vorm
\series default
 oleva elemendi 
\series bold
võitatud_asi
\series default
 korral:
\end_layout

\begin_layout Enumerate
: muudab 
\series bold
võitatud_asi
\series default
 järjendiks eraldades selles omavahel jaatatud olevad asjad.
 Näiteks 
\series bold
võitatud_asi
\series default
'i 
\begin_inset ERT
status open

\begin_layout Plain Layout

$voitatud
\backslash
_asi=A(x_4,x_1)
\backslash
land E(A(x_5,x_1)) 
\backslash
land 
\backslash
neg E(B(x_1,x_2,x_5))
\backslash
land 
\backslash
neg E(A(x_4,x_5)) 
\backslash
land 
\backslash
neg A(x_4,x_2))$
\end_layout

\end_inset

 puhul peale seda sammu 
\begin_inset ERT
status open

\begin_layout Plain Layout

$voitatud
\backslash
_asi=[A(x_4,x_1),E(A(x_5,x_1)),
\backslash
neg E(B(x_1,x_2,x_5)),
\backslash
neg E(A(x_4,x_5)),
\backslash
neg A(x_4,x_2))]$
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
: iga 
\series bold
võitatud_asi
\series default
's oleva asja 
\series bold
jaatatud_asi
\series default
 korral:
\end_layout

\begin_layout Enumerate
: : kui 
\series bold
jaatatud_asi
\series default
 on eitamata eksistentsiaalsuskvantor:
\end_layout

\begin_layout Enumerate
: : : muudab 
\series bold
jaatatud_asi
\series default
'i selleks järjendiks, mille 
\series bold
moodusta_puu
\series default
 tagastab, kui selle argumendiks anda 
\series bold
jaatatud_asi
\series default
 sisu(eksistentsiaalsuskvantori sees olev väide), ehk 
\series bold
jaatatud_asi
\series default
:=
\series bold
moodusta_puu
\series default
(
\series bold
jaatatud_asi
\series default
.sisu).
\end_layout

\begin_layout Enumerate
: : : iga 
\series bold
jaatatud_asi
\series default
 sees oleva 
\series bold
jupp
\series default
'i korral:
\end_layout

\begin_layout Enumerate
: : : : paneb 
\series bold
jupp
\series default
i ümber eksistentsiaalsuskvantori.
\end_layout

\begin_layout Enumerate
: : kui 
\series bold
jaatatud_asi
\series default
 on eitatud eksistentsiaalsuskvantor(eksistentsiaalsuskvantor, mille ees
 on eitus):
\end_layout

\begin_layout Enumerate
: : : muudab 
\series bold
jaatatud_asi2
\series default
'i selleks järjendiks, mille 
\series bold
moodusta_puu
\series default
 tagastab, kui selle argumendiks anda 
\series bold
jaatatud_asi
\series default
 sisu(eksistentsiaalsuskvantori sees olev väide), ehk 
\series bold
jaatatud_asi
\series default
:=
\series bold
moodusta_puu
\series default
(
\series bold
jaatatud_asi
\series default
.sisu).
\end_layout

\begin_layout Enumerate
: : : muudab 
\series bold
jaatatud_asi
\series default
 üheselt tõeseks väiteks.
\end_layout

\begin_layout Enumerate
: : : iga 
\series bold
jaatatud_asi2
\series default
 sees oleva 
\series bold
jupp
\series default
'i korral:
\end_layout

\begin_layout Enumerate
: : : : paneb 
\series bold
jupp
\series default
i ümber eksistentsiaalsuskvantori ehk 
\series bold
jupp
\series default
:=E(
\series bold
jupp
\series default
)
\end_layout

\begin_layout Enumerate
: : : : muudab 
\series bold
jaatatud_asi
\series default
'i jaatades sellega 
\series bold
jupp
\series default
i ehk 
\series bold
jaatatud_asi
\series default
&=~
\series bold
jupp
\end_layout

\begin_layout Enumerate
: : : muudab 
\series bold
jaatatud_asi
\series default
'i järjendiks, mis sisaldab ainult seda, mis ta selle sammu alguses on.
\end_layout

\begin_layout Enumerate
: lisab 
\series bold
tipp
\series default
ule aluuvateks kõikvõimalikud erinevad väited, mille saab moodustada kui
 jaatada kokku üks suvaline element igast 
\series bold
võitatud_asi
\series default
 elemendi elemendist.
 Näiteks 
\series bold
võitatud_asi
\series default
'i 
\begin_inset ERT
status open

\begin_layout Plain Layout

$voitatud
\backslash
_asi=[[[R_1,R_2],[R_3],[R_4,R_5,R_6]]$
\end_layout

\end_inset

 puhul peale seda sammu on 
\series bold
tipp
\series default
'ule lisatud järgnevad alluvad:
\begin_inset ERT
status open

\begin_layout Plain Layout

$lisatud alluvad=[R_1 
\backslash
land R_3 
\backslash
land R_4,R_1 
\backslash
land R_3 
\backslash
land R_5,R_1 
\backslash
land R_3 
\backslash
land R_6,R_2 
\backslash
land R_3 
\backslash
land R_4,R_2 
\backslash
land R_3 
\backslash
land R_5,R_2 
\backslash
land R_3 
\backslash
land R_6]$
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
tagastatakse 
\series bold
tipp
\series default
.
\end_layout

\begin_layout Subsubsection
seletus2 funktsioon 
\series bold
moodusta_puu
\series default
:
\end_layout

\begin_layout Enumerate
viib kõige sisemiste kvantorite sisud DNF vormi (igas jaatuses on kõik p(k)
 elemendid kas võiatud või jaatatud.).
\end_layout

\begin_layout Enumerate
viib kõige sisemiste kvantorite sisust seosefunktsioonide väited kõige välimiste
 võimalike kvantorite sisse.
 Ehk võimalikest madalamiale tasemele.
\end_layout

\begin_layout Enumerate
nüüd sisaldavad tasemel k olevad kvantorid ainult p(k) elemente.
\end_layout

\begin_layout Enumerate
toob kõige sisemiste kvantorite sisesed võitused kvantorite seest välja.
 Kasutades reeglit 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(f_1(x)
\backslash
lor f_2(x))=
\backslash
exists(f_1(x))
\backslash
lor 
\backslash
exists(f_1(x))$
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
läheb tagasi punkti 1.
\end_layout

\begin_layout Standard
Pilt väite 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
neg A(1, 1) 
\backslash
land 
\backslash
exists(A(1, 2) 
\backslash
land 
\backslash
neg A(2, 1) 
\backslash
land 
\backslash
neg A(2, 2) 
\backslash
land 
\backslash
exists(
\backslash
neg A(1, 3) 
\backslash
land A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land 
\backslash
neg A(3, 3)) 
\backslash
land 
\backslash
exists(
\backslash
neg A(1, 3) 
\backslash
land A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land A(3, 3)))) 
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
neg A(1, 1) 
\backslash
land 
\backslash
exists(
\backslash
neg A(1, 2) 
\backslash
land A(2, 1) 
\backslash
land 
\backslash
neg A(2, 2) 
\backslash
land 
\backslash
exists(A(1, 3) 
\backslash
land 
\backslash
neg A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land 
\backslash
neg A(3, 3)) 
\backslash
land 
\backslash
exists(A(1, 3) 
\backslash
land 
\backslash
neg A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land A(3, 3))))$
\end_layout

\end_inset

 põhjal koostatud puust:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pildid PDFi/puu koostamise näited/puu väitest, mis o-kontolliga vale tulemuse annab.png
	lyxscale 40
	scale 55
	BoundingBox 0bp 0bp 1366bp 726bp

\end_inset


\end_layout

\begin_layout Standard
pilt väite [kõigil, kes Marile meeldivad,[ei ole kedagi kes Marile meeldiks,
 aga temale mitte ja kellele meeldiks Mari] või [ei ole kedagi, kes nii
 talle kui Marile meeldiks] või [on keegi, kes neile meeldib ja kes iseendale
 meeldib]] ja ja leidub keegi, kes meeldib marile, nii, et eksisteerib [keegi,
 kes meeldib nii marile kui talle] ja [keegi, kes meeldib marile, kellele
 mari meeldib ja kelle ei meeldi talle] ja ei leidu kedagi, kes nii iseendale
 kui ka talle ta meeldiks või [on keegi(x_1) kes endale meeldib, aga [kellel
 pole kedagi kes nii talle kui iseendale meeldiks ja kellele meeldiks tema(x_1)]
] ehk (operaatori süntaksis):
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists((1
\backslash
 on
\backslash
 mari) 
\backslash
land  
\backslash
neg 
\backslash
exists((1le
\backslash
 meeldib
\backslash
 2) 
\backslash
land  
\backslash
exists((1le
\backslash
 meeldib
\backslash
 3) 
\backslash
land 
\backslash
neg (2le
\backslash
 meeldib
\backslash
 3) 
\backslash
land (3le
\backslash
 meeldib
\backslash
 1)) 
\backslash
land 
\backslash
exists((1le
\backslash
 meeldib
\backslash
 3) 
\backslash
land (2le
\backslash
 meeldib
\backslash
 3)) 
\backslash
land 
\backslash
neg 
\backslash
exists((2le
\backslash
 meeldib
\backslash
 3) 
\backslash
land (3le
\backslash
 meeldib
\backslash
 3))))
\backslash
land            
\backslash
exists(
\backslash
exists((2
\backslash
 on
\backslash
 mari)
\backslash
land (2le
\backslash
 meeldib
\backslash
 1)
\backslash
land 
\backslash
exists((1le
\backslash
 meeldib
\backslash
 2) 
\backslash
land (2le
\backslash
 meeldib
\backslash
 3))
\backslash
land 
\backslash
exists((2le
\backslash
 meeldib
\backslash
 3)
\backslash
land (3le
\backslash
 meeldib
\backslash
 2)
\backslash
land 
\backslash
neg (1le
\backslash
 meeldib
\backslash
 3)))
\backslash
land 
\backslash
neg 
\backslash
exists((2le
\backslash
 meeldib
\backslash
 1)
\backslash
land (2le
\backslash
 meeldib
\backslash
 2)))            | 
\backslash
exists((1le
\backslash
 meeldib
\backslash
 1)
\backslash
land 
\backslash
neg 
\backslash
exists((1le
\backslash
 meeldib
\backslash
 2)
\backslash
land (2le
\backslash
 meeldib
\backslash
 2)
\backslash
land (2le
\backslash
 meeldib
\backslash
 1)))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
põhjal koostatud puust:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pildid PDFi/puu koostamise näited/Mari puu.png
	lyxscale 30
	scale 38

\end_inset


\end_layout

\begin_layout Standard
pilt väite 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg 
\backslash
exists (
\backslash
exists (
\backslash
exists (A(1,2,3)))
\backslash
land A(1,1,1)
\backslash
lor 
\backslash
exists (
\backslash
neg A(2,2,1)
\backslash
lor 
\backslash
neg A(1,1,2)
\backslash
land 
\backslash
neg 
\backslash
exists (A(3,3,3)
\backslash
land A(3,2,1)))
\backslash
lor 
\backslash
exists (A(2,2,2)
\backslash
land 
\backslash
neg A(2,1,2)
\backslash
land A(2,2,1))
\backslash
land 
\backslash
exists (A(2,1,2)
\backslash
land A(2,2,1)
\backslash
lor 
\backslash
neg A(2,2,2)
\backslash
land A(2,1,1)
\backslash
lor 
\backslash
exists (A(3,2,3)
\backslash
land A(3,1,3))))$
\end_layout

\end_inset

 põhjal koostatud puust:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pildid PDFi/puu koostamise näited/puu 3.png
	lyxscale 40
	scale 50

\end_inset


\end_layout

\begin_layout Subsubsection
funktsioon 
\series bold
laiendatud_EKd
\series default
:
\end_layout

\begin_layout Enumerate
kui kutsutakse välja funktsioon 
\series bold
laiendatud_EKd
\series default
 argumentidega 
\series bold
tipp
\series default
 ja 
\series bold
kõrgus
\series default
, ehk 
\series bold
laiendatud_EKd
\series default
(
\series bold
tipp
\series default
,
\series bold
kõrgus
\series default
), siis
\begin_inset Newline newline
\end_inset

loob tipud 
\series bold
pseudo_LR1
\series default
, 
\series bold
pseudo_LR2
\end_layout

\begin_layout Enumerate
iga võimaliku ainult 
\series bold
tipp
\series default
'u alluvaid sisaldava järjendi, milles on 
\series bold
kõrgus
\series default
 elementi, 
\series bold
P1
\series default
 korral:
\end_layout

\begin_layout Enumerate
: lisab 
\series bold
P1
\series default
 algusesse elemendi 
\series bold
pseudo_LR1
\end_layout

\begin_layout Enumerate
: eemaldab 
\series bold
P1
\series default
'est kõik tippudest, mis puus on oma ülemuse sees olnud eitatud, suuremal
 indeksitel olevad tipud.
\end_layout

\begin_layout Enumerate
: loob uue järjendi nimega 
\series bold
laiendatud
\end_layout

\begin_layout Enumerate
: märgib iga järjendi 
\series bold
laiendatud
\series default
 elementide vahelistks predikaatväideteks olema samad predikaatväited, mis
 on samade indeksitega 
\series bold
P1
\series default
 elementide vahel.
 Predikaatväidete indeksid võivad teistsugused olla kui P1'es olevates tippudes,
 sest nagu tippude kõrgusedki on 
\series bold
P1
\series default
'es tippude kvanteeritavate nimed teistsugused kui sisendiks antud 
\series bold
P1
\series default
'es.
 Kui 
\series bold
P1
\series default
'es ei ole mingid 2 
\series bold
tipp
\series default
'ust kumbki teisele alluvaks, siis puus ei ole nende vahelisi predikaatväiteid
 ja neid ei saa olla ka 
\series bold
P1
\series default
'es ega järjendis 
\series bold
laiendatud
\series default
.
\end_layout

\begin_layout Enumerate
: mergeb 
\series bold
laiendatud
\series default
'e esimese elemendi ja 
\series bold
pseudo_LR2
\series default
'e kokku moodustades neist puu.
 ehk 
\series bold
pseudo_LR2
\series default
:=merge(
\series bold
P1
\series default
,
\series bold
pseudo_LR2
\series default
)
\end_layout

\begin_layout Enumerate
iga võimaliku ainult 
\series bold
tipp
\series default
'u alluvaid sisaldava järjendi mille viimane element on puus eitatud ja,
 milles on vähem kui 
\series bold
kõrgus
\series default
 elementi, 
\series bold
P1
\series default
 korral:
\series bold
LR1
\end_layout

\begin_layout Standard
pilt väite 
\begin_inset ERT
status open

\begin_layout Plain Layout

$E(
\backslash
neg A(1, 1) 
\backslash
land E(A(1, 2) 
\backslash
land 
\backslash
neg A(2, 1) 
\backslash
land 
\backslash
neg A(2, 2))) 
\backslash
land 
\backslash
neg E(E(
\backslash
neg A(2,1))
\backslash
land
\backslash
neg A(1, 1) 
\backslash
land E(
\backslash
neg A(1, 2) 
\backslash
land A(2, 1) 
\backslash
land 
\backslash
neg A(2, 2)
\backslash
land E(A(1, 3) 
\backslash
land 
\backslash
neg A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land A(3, 3))))$
\end_layout

\end_inset

 põhjal koostatud puus, kuhu on lisatud laiendatud harud(sinist värvi):
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pildid PDFi/laiendatud harude näited/laiendatud harude näide.png
	lyxscale 28
	scale 41

\end_inset


\end_layout

\begin_layout Standard
pilt väite, mis on ÜV (P1=[1,3]),
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg 
\backslash
exists(
\backslash
neg A(1,1)
\backslash
land 
\backslash
exists(
\backslash
neg A(2,2)
\backslash
land A(1,2)
\backslash
land A(2,1)))
\backslash
land 
\backslash
neg 
\backslash
exists(A(1,1)
\backslash
land 
\backslash
exists(A(2,2)
\backslash
land A(1,2)
\backslash
land 
\backslash
neg A(2,1)))
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
neg A(1,1)
\backslash
land 
\backslash
exists(
\backslash
neg A(2,2)
\backslash
land 
\backslash
neg A(1,2)
\backslash
land 
\backslash
neg A(2,1)))
\backslash
land 
\backslash
exists(
\backslash
exists(
\backslash
neg A(2,2)
\backslash
land A(1,2)
\backslash
land A(2,1))
\backslash
land 
\backslash
exists(A(2,2)
\backslash
land 
\backslash
neg A(1,2)
\backslash
land 
\backslash
exists(A(3,3)
\backslash
land 
\backslash
neg A(3,2)
\backslash
land 
\backslash
neg A(2,3)
\backslash
land A(1,3)
\backslash
land A(3,1))
\backslash
land 
\backslash
exists(
\backslash
neg A(3,3)
\backslash
land A(3,2)
\backslash
land A(2,3)
\backslash
land 
\backslash
neg A(1,3)
\backslash
land 
\backslash
neg A(3,1)
\backslash
land 
\backslash
exists(A(4,4)
\backslash
land A(2,4)
\backslash
land 
\backslash
neg A(4,2)
\backslash
land 
\backslash
neg A(1,4)
\backslash
land A(4,1)))))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
põhjal koostatud puus, kuhu on lisatud laiendatud harud(sinist värvi):
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pildid PDFi/laiendatud harude näited/lainedatult harude näide 2.png
	lyxscale 40
	scale 55

\end_inset


\end_layout

\begin_layout Standard
pilt väite 
\begin_inset ERT
status open

\begin_layout Plain Layout

$E(
\backslash
neg A(1, 1) 
\backslash
land 
\backslash
exists(A(1, 2) 
\backslash
land 
\backslash
neg A(2, 1) 
\backslash
land 
\backslash
neg A(2, 2) 
\backslash
land 
\backslash
exists(
\backslash
neg A(1, 3) 
\backslash
land A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land 
\backslash
neg A(3, 3)) 
\backslash
land 
\backslash
exists(
\backslash
neg A(1, 3) 
\backslash
land A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land A(3, 3)))) 
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
neg A(1, 1) 
\backslash
land 
\backslash
exists(
\backslash
neg A(1, 2) 
\backslash
land A(2, 1) 
\backslash
land 
\backslash
neg A(2, 2) 
\backslash
land 
\backslash
exists(A(1, 3) 
\backslash
land 
\backslash
neg A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land 
\backslash
neg A(3, 3)) 
\backslash
land 
\backslash
exists(A(1, 3) 
\backslash
land 
\backslash
neg A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land A(3, 3))))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
põhjal koostatud puus, kuhu on lisatud laiendatud harud(sinist värvi):
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pildid PDFi/laiendatud harude näited/puu väitest, mis o-kontolliga vale tulemuse annab lainedatult.png
	lyxscale 40
	scale 55

\end_inset


\end_layout

\begin_layout Standard
pilt väite(mis on ÜV) 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
neg A(1,1)
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
exists(
\backslash
neg A(3,2)
\backslash
land 
\backslash
neg A(1,3))
\backslash
land 
\backslash
neg A(2, 2)
\backslash
land A(2,1)
\backslash
land 
\backslash
exists(
\backslash
neg A(2,3) 
\backslash
land  A(3,2)
\backslash
land 
\backslash
neg A(3,3)
\backslash
land 
\backslash
exists(A(1,4)
\backslash
land A(2,4)
\backslash
land 
\backslash
neg A(3,4)
\backslash
land 
\backslash
neg A(4,2)
\backslash
land 
\backslash
neg A(4,3)
\backslash
land A(4,4))))
\backslash
land 
\backslash
exists(
\backslash
neg A(2,2)
\backslash
land A(2,1)
\backslash
land 
\backslash
exists(
\backslash
neg A(3,3)
\backslash
land A(3,1)
\backslash
land A(2,3)
\backslash
land 
\backslash
neg A(3,2)
\backslash
land 
\backslash
exists(
\backslash
neg A(4,3)
\backslash
land 
\backslash
neg A(1,4)
\backslash
land A(2,4))
\backslash
land 
\backslash
exists(A(4,4)
\backslash
land 
\backslash
neg A(4,2)
\backslash
land 
\backslash
neg A(2,4)
\backslash
land 
\backslash
neg A(4,3)
\backslash
land A(3,4)
\backslash
land 
\backslash
neg A(2,4)
\backslash
land A(1,4)
\backslash
land 
\backslash
neg A(4,1)))))$
\end_layout

\end_inset

põhjal koostatud puus, kuhu on lisatud laiendatud harud(sinist värvi):
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pildid PDFi/laiendatud harude näited/harudega ÜV puu.png
	lyxscale 40
	scale 53

\end_inset


\end_layout

\begin_layout Subsubsection

\series bold
funktsioon sisu_täpsem_kui
\end_layout

\begin_layout Standard
tagastab, et kas 1.
 argumendiks oleva tipu sisust järeldub 2.
 argumendiks oleva tipu sisu.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$tipp1.sisu 
\backslash
to tipp2.sisu$
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
kui kutsutakse välja funktsioon 
\series bold
sisu_täpsem_kui
\series default
 argumentidega 
\series bold
tipp1
\series default
 ja 
\series bold
tipp2
\series default
, ehk 
\series bold
sisu_täpsem_kui
\series default
(
\series bold
tipp1
\series default
,
\series bold
tipp2
\series default
), siis:
\end_layout

\begin_layout Enumerate
iga 
\series bold
tipp2
\series default
 sees oleva omaduse 
\series bold
omadus2
\series default
 kohta:
\end_layout

\begin_layout Enumerate
: kui 
\series bold
omadus2
\series default
 on predikaatväide:
\end_layout

\begin_layout Enumerate
: : iga 
\series bold
tipp1
\series default
 sees oleva omaduse 
\series bold
omadus1
\series default
 kohta:
\end_layout

\begin_layout Enumerate
: : : kui (
\series bold
omadus1
\series default
 on predikaatväide) ja 
\series bold
omadus1
\series default
==
\series bold
omadus2:
\end_layout

\begin_layout Enumerate
: : : : läheb punkti 3 ja võtab uue 
\series bold
omadus2
\series default
'e
\end_layout

\begin_layout Enumerate
: : tagastab False ehk, et 1.
 argumendiks oleva tipu 
\series bold
tipp1
\series default
 sisust ei järeldu 2.
 argumendiks oleva tipu 
\series bold
tipp2
\series default
 sisu
\end_layout

\begin_layout Enumerate
: kui 
\series bold
omadus2
\series default
 on eitatud eksistentsiaalsuskvantor:
\end_layout

\begin_layout Enumerate
: : iga 
\series bold
tipp1
\series default
 sees oleva omaduse 
\series bold
omadus1
\series default
 kohta:
\end_layout

\begin_layout Enumerate
: : : kui (
\series bold
omadus1
\series default
 on eitatud kvantor) ja 
\series bold
sisu_täpsem_kui
\series default
(
\series bold
omadus2
\series default
,
\series bold
omadus1
\series default
)
\series bold
:
\end_layout

\begin_layout Enumerate
: : : : läheb punkti 3 ja võtab uue 
\series bold
omadus2
\series default
'e
\end_layout

\begin_layout Enumerate
: : tagastab False ehk, et 1.
 argumendiks oleva tipu 
\series bold
tipp1
\series default
 sisust ei järeldu 2.
 argumendiks oleva tipu 
\series bold
tipp2
\series default
 sisu
\end_layout

\begin_layout Enumerate
: kui 
\series bold
omadus2
\series default
 on eitamata eksistentsiaalsuskvantor:
\end_layout

\begin_layout Enumerate
: : iga 
\series bold
laiendatud_EKd
\series default
(
\series bold
tipp1
\series default
) sees oleva omaduse 
\series bold
omadus1
\series default
 kohta:
\end_layout

\begin_layout Enumerate
: : : kui (
\series bold
omadus1
\series default
 on eitamata kvantor) ja 
\series bold
sisu_täpsem_kui
\series default
(
\series bold
omadus1
\series default
,
\series bold
omadus2
\series default
)
\series bold
:
\end_layout

\begin_layout Enumerate
: : : : läheb punkti 3 ja võtab uue 
\series bold
omadus2
\series default
'e
\end_layout

\begin_layout Enumerate
: : tagastab False ehk, et 1.
 argumendiks oleva tipu 
\series bold
tipp1
\series default
 sisust ei järeldu 2.
 argumendiks oleva tipu 
\series bold
tipp2
\series default
 sisu
\end_layout

\begin_layout Subsubsection

\series bold
funktsioon sisud_kooskõlas
\end_layout

\begin_layout Subsubsection
funktsioon lihtsusta_puud
\end_layout

\begin_layout Enumerate
kui kutsutakse välja funktsioon 
\series bold
lihtsusta_puud
\series default
 argumendiga 
\series bold
LV
\series default
, ehk 
\series bold
lihtsusta_puud
\series default
(
\series bold
LV
\series default
), siis:
\begin_inset Newline newline
\end_inset

lisab kõigile 
\series bold
LV
\series default
ga kaudselt ühenduses olevatele tippude, mille kvanteeritavate vahel on
 mingi predikaatväide kirjas, suunata servad(eelnavad servad olid suunatud
 juurtipust 
\series bold
LV
\series default
 eemale.).
\end_layout

\begin_layout Enumerate
tagastab 
\series bold
lihtsusta_tipp
\series default
(
\series bold
LV
\series default
)
\end_layout

\begin_layout Subsubsection
funktsioon lihtsusta_tipp
\end_layout

\begin_layout Enumerate
kui kutsutakse välja funktsioon 
\series bold
lihtsusta_tipp
\series default
 argumendiga 
\series bold
tipp1
\series default
, ehk 
\series bold
lihtsusta_tipp
\series default
(
\series bold
tipp1
\series default
), siis:
\begin_inset Newline newline
\end_inset

iga 
\series bold
tipp1
\series default
e haru 
\series bold
tipp2
\series default
 puhul:
\end_layout

\begin_layout Enumerate
: koostab 
\series bold
tipp1
\series default
e põhjal 
\series bold
abi_tipp1
\series default
e, kus ,mis on muidu nagu 
\series bold
tipp1
\series default
, aga on lisatud servad kõikide tippude vahele, mille kvanteeritavate vahel
 on mingi predikaatväide kirjas.
\end_layout

\begin_layout Enumerate
: võtab uue tipu 
\series bold
uus_tipp1
\end_layout

\begin_layout Enumerate
: lisab 
\series bold
uus_tipp1
\series default
 harudeks kõik 
\series bold
abi_LR
\series default
 sidususkomponendid
\end_layout

\begin_layout Enumerate
: leiab funktsiooni kutse 
\series bold
lühimapikimateegatipp
\series default
(
\series bold
abi_LR
\series default
) abil tipu 
\series bold
tipp
\end_layout

\begin_layout Enumerate
: teeb 
\series bold
tipp
\series default
u uue puugraafi 
\series bold
uusLR
\series default
 juurtipuks.
\end_layout

\begin_layout Enumerate
: eemaldab tippu 
\series bold
abi_LR
\series default
ist
\end_layout

\end_body
\end_document
