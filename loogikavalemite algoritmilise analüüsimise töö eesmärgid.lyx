#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
väidete algoritmilise analüüsimise töö eesmärgid
\end_layout

\begin_layout Author
Olger Männik
\end_layout

\begin_layout Part
Sissejuhatus
\end_layout

\begin_layout Paragraph
DEFINITSIOON:
\end_layout

\begin_layout Standard
Selles failis on kirjeldatud ainult töö eesmärgid.
 Mul on teine pikem fail, kus on eesmärkide saavutamist alustatud ja sellega
 üsna kaugele jõutud.
\end_layout

\begin_layout Standard

\color yellow
(võibolla on ka üldisem definitsioon kus kvantorid asendatakse, millegagi,
 mis tagsatavad midagi muud kui booleane)
\end_layout

\begin_layout Standard
Sõna väide on siin töös tavalakeelses tähenduses, ehk see on miski, mille
 tõele vastamisest järeldub mingi tõsiasi.
 Siin töös kasutan ühte kindlaid syntaxeid väidete kirja panemiseks.
 Selles syntaxis tohivad väited sisaldada booleanalgebra, kvantoreid ja
 predikaate(või elementaarseoseid või algasju predikaatide asemel).
\end_layout

\begin_layout Paragraph
eesmärgid
\end_layout

\begin_layout Standard
Töö eesmärk on koostada algoritm ja implementeerida see arvutiprogrammina,
 mille abil saaks väiteid minimaalsel vabadusastmel salvestada.
 Minimaalsel vabadusastmel salvestatud väiteid saaks kergesti analüüsida.
 Kui minimaalsel vabadusastmel salvaestamine on liiga raskesti implementeeritav,
 liiga keerukas või liiga palju mälu nõudev, siis võib selle asemel teha
 algoritmi, mis väiteid analüüsib ilma neid minimaalsel vabadusastmel salvestama
ta.
 Kasutaja sisestaks väited kergesti loetavas syntaxis.
 Seda saaks kasutada näiteks kõige üldisemate matemaatiliste probeemide
 (mis võivad olla võrranditena esitatud) lihtsustamiseks, lahendamiseks
 ja lahendite kontrollimiseks.
\end_layout

\begin_layout Standard
Kuna iga väide on salvestatud minimaalsel vabadusastmel, siis saab lihtsasti
 kontrollida, et kas see on üheselt vale, üheselt tõene või mitte kumbagi,
 sest kõigile üheselt valedele ja üheselt tõestele väidetele vastab sama
 arv.
 Tõenäoliselt ongi praktilisel kasutamisel kõige olulisem küsimus, et kas
 väide vormis 
\begin_inset ERT
status open

\begin_layout Plain Layout

$aksioomid 
\backslash
to väide$
\end_layout

\end_inset

 on üheselt vale üheselt õige või mitte kumbagi (
\begin_inset ERT
status open

\begin_layout Plain Layout

$programm(aksioomid 
\backslash
to väide)$
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Kui sellise programmi tegemine pole Gödeli teoreemi kohaselt võimalik, siis
 teha programm mis seni kuni kasutaja stopp paneb kontrollimist jätkab ja
 järjest täpsemaks läheb.
 arv 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

 peab siis sisaldama infot, et kui palju on selle poolt kirjeldatud väidet
 lihtsustatud.
 Võimalik et ei saa ka kunagi kindel olla kas antud väide on üheselt vale,
 üheselt tõene või mitte kumbagi.
 Kuigi Gödeli teoreemi kohaselt pole võimalik kogu täisarvude matemaatika
 aksiomaatiliselt kirjeldada(???) saab arvutile etteantavasse väideesse
 alati uusi aksioome juurde lisada ja tõestada, et teatud arvust 
\begin_inset ERT
status open

\begin_layout Plain Layout

$K_{max}$
\end_layout

\end_inset

 väiksemate K parameetritega väidete abil kirjeldatavad aksioomid on lisatud.
 Kasutaja ei peaks iga kord uuesti kõiki (näiteks reaalarvude kohta käivaid)
 aksioome sisestama, vaid saaks need moodulina 
\begin_inset Quotes eld
\end_inset

importida
\begin_inset Quotes erd
\end_inset

(
\begin_inset Quotes eld
\end_inset

includida
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
Hea oleks käsitleda minimaalsel vabadusastmel kirjeldatud väiteid naturaalarvude
na.
 Tähistame naturaalarvu, mis kirjeldab väidet 
\begin_inset ERT
status open

\begin_layout Plain Layout

$S$
\end_layout

\end_inset

 tähisega 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

.
 Selleks tuleb defineerida injektiivne vastavus võimalike väidete(võimalik
 vist ainult kindlas notatsioonis olevate väidete korral) ja naturaalarvude
 vahele.
 On võimalik defineerida mitmeid sarnaseid vastavusi.
 Tähistame funktsiooni, mis seab väite 
\begin_inset ERT
status open

\begin_layout Plain Layout

$S$
\end_layout

\end_inset

 vastavusse naturaalarvuga 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

 F'iga.
 Seega 
\begin_inset ERT
status open

\begin_layout Plain Layout

$F(S)=n_S$
\end_layout

\end_inset

.
 Selle pöördfunktsiooni tähistan f'iga.
 Seega 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f(n_S)=S$
\end_layout

\end_inset

.
 Järgnevalt loetlen omadusi, mis vastavusel (ja funktsioonil F) võiks olla,
 et sellisel kujul olevat väidet praktikas mugav kasutada oleks:
\end_layout

\begin_layout Itemize
Hea on kui sellisel kujul estitatud väidete vahel saab rakendada sagedasti
 kasututatavaid operaatoreid(näiteks AND, NAND, OR, NOR ja XOR) rakendades
 neile vastavaid lihtsasti arvutatavaid funktsioone väidet kirjeldavale
 arvule 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Hea on kui tavalises notatsioonis lühidalt kirjapandav väide on ka väikese
 või lihtsasti kirjeldatava naturaalarvuga vastavusse pandud.
\end_layout

\begin_layout Itemize
Hea on kui võimalikud jäävad väärtused 0 ja mingi arvu vahele(mis muide
 on 
\begin_inset ERT
status open

\begin_layout Plain Layout

(max $n_S$ väärtus)
\end_layout

\end_inset

)(kui K pole määratud, siis ei ole 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

 ülmist piiri) nii, et igale nende vahel olevale naturaalarvule vastab erinev
 väide.
 Seega on funktsioon F bijektiivne.
\end_layout

\begin_layout Itemize
Hea on kui Falsele(kõigile üheselt valedele väidetele) vastab 0.
\end_layout

\begin_layout Itemize
Hea on kui Truele(kõigile üheselt tõestele väidetele) vastab 1.
\end_layout

\begin_layout Section
Näited progemmi kasutamisest
\end_layout

\begin_layout Subsection
lihtsamad näited
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide on üheselt vale (lühendatult
 ÜV): 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(A(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1}(A(x_1))$
\end_layout

\end_inset

, sest on väidetud et miski, mis rahuldab predikaati A eksisteerib ning
 samuti on väidetud, et seda ei eksisteeri.
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide pole üheselt vale: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(A(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1}(A(x_1)
\backslash
land B(x_1))$
\end_layout

\end_inset

, sest on väidetud et eksisteerib miski, mis rahuldab predikaati A aga,
 ei eksisteeri midagi, mis rahuldaks nii predikaate A kui B.
 Vastuolu ei ole.
 Sellest on lihtsam aru saada kui panna predikaatidele mingit intuitiivselt
 lihtsamini mõistetavamad nimed.
 nt.: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(on
\backslash
_loom(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1}(on
\backslash
_loom(x_1)
\backslash
land on
\backslash
_auto(x_1))$
\end_layout

\end_inset

.
 Ehk on väidetud, et eksisteerib mingi asi, mis on loom(eksisteerib mingi
 loom), aga ei eksisteeri midagi, mis oleks nii loom kui auto.
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide on üheselt vale: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(A(x_1)
\backslash
land B(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1}(A(x_1))$
\end_layout

\end_inset

, sest on väidetud, et eksisteerib miski, mis rahuldab nii predikaati A
 kui ka predikaati B, aga ei eksisteeri midagi, mis rahuldaks predikaati
 A.
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide on üheselt vale: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(
\backslash
exists_{x_2}(A(x_1,x_2)
\backslash
land 
\backslash
exists_{x_3}(A(x_2,x_3)
\backslash
land A(x_2,x_2))))
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1}(
\backslash
exists_{x_2}(
\backslash
exists_{x_3}( A(x_2,x_1)
\backslash
land A(x_1,x_3)
\backslash
land A(x_1,x_1))))$
\end_layout

\end_inset

,sest on väidetud, et eksisteerib miski (
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_2$
\end_layout

\end_inset

), mis rahuldab millegagi predikaati A olles ise 2.
 argument, rahuldab millegi muuga predikaati A, olles ise 1.
 argument ja rahuldab predikaati A olles selle mõlemaks argumendiks ning
 väite teises osas on väidetud, et selliste omadustega asja just ei eksisteeri.
\end_layout

\begin_layout Standard
Eelnevalt näiteks toodud väidete vastuolulisust on kerge intuitiivselt(ilma
 algoritmita) ilma arvuti abita kontrollida, aga pikkade ja keerukate väidete
 vastuolulisust on niimoodi väga raske kontrollida.
 Siis ongi mu programm kasulik.
 Järgnevalt toon mõned näited keerukamatest väidetest, mille vastuolulisust
 on raske kontrollida:
\end_layout

\begin_layout Itemize
järgneva väite korral programm tagastab, et väide ei ole üheselt vale: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(on
\backslash
_mari(x_1) 
\backslash
land  
\backslash
neg
\backslash
exists_{x_2}(M(x_1, x_2) 
\backslash
land  
\backslash
exists_{x_3}(M(x_1, x_3) 
\backslash
land  
\backslash
neg M(x_2, x_3) 
\backslash
land  M(x_3, x_1)) 
\backslash
land  
\backslash
exists_{x_3}(M(x_1, x_3) 
\backslash
land  M(x_2, x_3)) 
\backslash
land  
\backslash
neg 
\backslash
exists_{x_3}(M(x_2, x_3) 
\backslash
land  M(x_3, x_3))))
\backslash
land             
\backslash
exists_{x_1}(
\backslash
exists_{x_2}(on
\backslash
_mari(x_2)
\backslash
land M(x_2,x_1)
\backslash
land 
\backslash
exists_{x_3}(M(x_1,x_3)
\backslash
land M(x_2,x_3))
\backslash
land 
\backslash
exists_{x_3}(M(x_2,x_3)
\backslash
land M(x_3,x_2)
\backslash
land 
\backslash
neg M(x_1,x_3)))
\backslash
land 
\backslash
neg 
\backslash
exists_{x_2}(M(x_2,x_1)
\backslash
land M(x_2,x_2)))
\backslash
lor
\backslash
exists_{x_1}(M(x_1,x_1)
\backslash
land 
\backslash
neg 
\backslash
exists_{x_2}(M(x_1,x_2)
\backslash
land M(x_2,x_2)
\backslash
land M(x_2,x_1)))$
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Sellest, et vastuolu pole, on lihtsam aru saada kui panna predikaatidele
 intuitiivselt lihtsamini mõistetavamad nimed.
 nt.:predikaat M on 
\begin_inset Quotes eld
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1$
\end_layout

\end_inset

'le meeldib 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_2$
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, ehk kui 
\begin_inset ERT
status open

\begin_layout Plain Layout

$M(x_1,x_2)$
\end_layout

\end_inset

, siis 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1$
\end_layout

\end_inset

 meeldib 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_2$
\end_layout

\end_inset

'le.
 Siis on väidetud , et: [kõigil, kes Marile meeldivad,[ei ole kedagi kes
 Marile meeldiks, aga temale mitte ja kellele meeldiks Mari] või [ei ole
 kedagi, kes nii talle kui Marile meeldiks] või [on keegi, kes neile meeldib
 ja kes iseendale meeldib]] ja ja leidub keegi, kes meeldib marile, nii,
 et eksisteerib [keegi, kes meeldib nii marile kui talle] ja [keegi, kes
 meeldib marile, kellele mari meeldib ja kelle ei meeldi talle] ja ei leidu
 kedagi, kes nii iseendale kui ka talle ta meeldiks või [on keegi(x_1) kes
 endale meeldib, aga [kellel pole kedagi kes nii talle kui iseendale meeldiks
 ja kellele meeldiks tema(x_1)]].
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide on üheselt vale:
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(A(x_1,x_1)
\backslash
land 
\backslash
exists_{x_2}(A(x_2,x_2) 
\backslash
land A(x_2,x_1) 
\backslash
land A(x_1,x_2)) 
\backslash
land 
\backslash
exists_{x_2}(
\backslash
neg A(x_2,x_2) 
\backslash
land 
\backslash
neg A(x_1,x_2) 
\backslash
land A(x_2,x_1) 
\backslash
land 
\backslash
neg 
\backslash
exists_{x_3}(
\backslash
neg A(x_3,x_3) 
\backslash
land 
\backslash
neg A(x_3,x_2) 
\backslash
land A(x_3,x_1) 
\backslash
land A(x_2,x_3) 
\backslash
land A(x_1,x_3))))
\backslash
land
\end_layout

\begin_layout Plain Layout


\backslash
neg 
\backslash
exists_{x_1}(
\backslash
exists_{x_2}(
\backslash
exists_{x_3}(
\backslash
neg A(x_1,x_1)
\backslash
land 
\backslash
neg A(x_1,x_2)
\backslash
land 
\backslash
neg A(x_2,x_1)
\backslash
land 
\backslash
neg A(x_2,x_2)
\backslash
land 
\backslash
neg A(x_3,x_1)
\backslash
land 
\backslash
neg A(x_3,x_2)
\backslash
land 
\backslash
neg A(x_3,x_3)
\backslash
land 
\backslash
neg A(x_1,x_3)
\backslash
land 
\backslash
neg A(x_2,x_3)))
\backslash
lor A(x_1,x_1) 
\backslash
land 
\backslash
exists_{x_2}(A(x_2,x_2) 
\backslash
land 
\backslash
neg A(x_2,x_1) 
\backslash
land A(x_1,x_2) 
\backslash
neg 
\backslash
exists_{x_3}(
\backslash
neg A(x_3,x_3) 
\backslash
land A(x_3,x_2) 
\backslash
neg 
\backslash
land A(x_3,x_1) 
\backslash
land A(x_2,x_3) 
\backslash
land A(x_1,x_3)) ))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Siin on toodud mõned väited, mille üheselt valesust saaks minu programmiga
 kontrollida, aga mille vastuolulisuse kontrollimiseks on vaja kasutada
 matemaatiliste tehte märkide tähendusi kirjeldavaid väiteid ja arvude kohta
 käivaid aksioome.
 Programmi kasutaja ei peaks neid käsitsi sisestama vaid saaks need standard
 libarist võtta.
 Standard libariks olevat väidet tähistan siinkohal nimega STANDARD.
 Samuti on selleks vaja kasutada mõndasid syntax-sugareid.
\end_layout

\begin_layout Standard
mitte ÜV: 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists_{x_1}(x_1+3=7 
\backslash
land on
\backslash
_reaalarv(x_1))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1}(0*x_1=3 
\backslash
land on
\backslash
_reaalarv(x_1))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1}((on
\backslash
_naturaalarv(x_1) 
\backslash
to x_1>x_1) 
\backslash
lor x_1=x_1+1)$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists_{x_1}(on
\backslash
_reaalarv(x_1)
\backslash
land 
\backslash
exists_{x_2}(x_1+x_2=23
\backslash
land x_1+2*x_2=37 
\backslash
land x_1<53 
\backslash
land x_1*x_2<200 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1} (
\backslash
neg 
\backslash
exists_{x_2} (x_1>x_2 
\backslash
land on
\backslash
_reaalarv(x_1) 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

 ei leidu arvu, millest suuremat ei leiduks.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1} (
\backslash
exists_{x_2} (x_1>x_2
\backslash
land x_1<x_2 
\backslash
land on
\backslash
_reaalarv(x_1)  
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

ei leidu kahte arvu nii, et mõlemad oleksid teisest suuremad.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists_{x_1} (
\backslash
neg 
\backslash
exists_{x_2} (x_1*x_2 
\backslash
not = 0 
\backslash
land on
\backslash
_reaalarv(x_1) 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

Leidub arv(0), nii et ei leiduks arvu, millega seda korrutades ei saaks
 vastuseks nulli.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists_{x_1} (
\backslash
exists_{x_2} (x_1+x_2=9
\backslash
land x_1*x_2=20
\backslash
land x_1>x_2 
\backslash
land on
\backslash
_reaalarv(x_1) 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

 Need arvud on 5 ja 4.
\end_layout

\begin_layout Standard
ÜV:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists_{x_1}(
\backslash
exists_{x_2}(x_1^3-4*x_1^2+6*x_1-24-x_2^4+3*x_2=0 
\backslash
land x_2>1))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists_{x_1}(on
\backslash
_reaalarv(x_1)
\backslash
land 
\backslash
neg 
\backslash
exists_{x_2}(x_1<x_2 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

, sest see väide ütleb, et eksiseerib selline reaalarv, nii et ei leidu
 ühtegi teist reaalarvu, mis sellest suurem oleks.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists(on
\backslash
_kompleksarv(x_1)
\backslash
land 
\backslash
exists(x_1<x_2 
\backslash
land on
\backslash
_kompleksarv(x_2) 
\backslash
land x_1^2=x_2^2))$
\end_layout

\end_inset

 ei leidu kahte kompleksarvu, mille ruut oleks sama ja millest esimene oleks
 teisest suurem.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists(on
\backslash
_kompleksarv(x_1)
\backslash
land 
\backslash
exists(on
\backslash
_kompleksarv(x_2) 
\backslash
land 
\backslash
exists(on
\backslash
_kompleksarv(x_3) 
\backslash
land x_1^5=x_2^5 
\backslash
land x_2^5=x_3^5 
\backslash
land x_1 
\backslash
neq x_2 
\backslash
land x_2 
\backslash
neq x_3 
\backslash
land x_1 
\backslash
neq x_3)))$
\end_layout

\end_inset

 ei leidu 3e erinevat kompleksarvu, mille 5 aste oleks sama.
\end_layout

\begin_layout Standard
Saaks kontrollida ka, et kas mingi hüpotees(teoreem) järeldub aksioomidest(ehk
 standard libarist).
 Kui standard libaris on piisavalt palju infot, siis järgneva seose korral
 programm tagastab, et see seos on ÜV, ehk et see hüpotees oli tõene.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg (STANDARD 
\backslash
to 
\backslash
neg 
\backslash
exists_{x_1}(on
\backslash
_naturaalarv(x_1) 
\backslash
land 
\backslash
exists_{x_2}(on
\backslash
_naturaalarv(x_2) 
\backslash
land 
\backslash
exists_{x_3}( on
\backslash
_naturaalarv(x_3) 
\backslash
land 
\backslash
exists_{x_4}(x_1^{x_4}+x_2^{x_4}=x_3^{x_4} 
\backslash
land x_4>2 
\backslash
land on
\backslash
_naturaalarv(x_4))))))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Matemaatiliste mõistete vahelise väite kirjeldamine.
\end_layout

\begin_layout Subsection
algoritmi või arvutiprogrammi analüüsimiseks
\end_layout

\begin_layout Standard
igal pool asendada käsk x:=y väitega 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x(t+1)=y(t)$
\end_layout

\end_inset

, kus t on prgrammi samm.
\end_layout

\begin_layout Subsection
Füüsikalise mudeli kirjeldamiseks
\end_layout

\begin_layout Standard
Oluline on ka näidaya, et milliste erinevate väärtuste korral on süsteemid
 füüsikaliselt identsed.
 Näiteks ei ole oluline potentsiaali 0-nivoo ja koordinaatide alguspunkt.
\end_layout

\begin_layout Standard
Oluliseks pointiks nii tõenäosuste kui gemeetrilise ruumi(intuitiivsetst
 vektoritest) on, et intuitiivse tähendusega aja korrutis arvuga on samuti
 intuitiivne.
 See on vist kuidagi taustsüsteemiga seotud.
 taust spsteemi, mille algus on kohas 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
vec{a}$
\end_layout

\end_inset

 olev vektor 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
vec{b}$
\end_layout

\end_inset

 asub kohas 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
vec{a}+
\backslash
vec{b}$
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
predikaadid
\end_layout

\begin_layout Standard
Predikaadid on tähistatud kas operaatori-syntaxis või funktsiooni-syntaxis.
\end_layout

\begin_layout Paragraph
operaatorisyntax
\end_layout

\begin_layout Standard
eraldi lõigud, mille vahel on sulgude sees argumendid.
 näiteks 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(aaa(x_1)(x_2)bbb(x_3)ccc)$
\end_layout

\end_inset

 tähendab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$aaa()()bbb()ccc(x_1,x_2,x_3)$
\end_layout

\end_inset

.
 näiteks 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(x_1<x_2)$
\end_layout

\end_inset

 tähendab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$()<()(x_1,x_2)$
\end_layout

\end_inset

.
 Funktsioonisyntaxis ei ole vaja predikaatide lõpus olevaid argumente tühjade
 sulgudega vaja tähistada.
 Näiteks: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$()<()(x_1,x_2)$
\end_layout

\end_inset

 asemel
\begin_inset ERT
status open

\begin_layout Plain Layout

$()<(x_1,x_2)$
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
funktsioonisyntax
\end_layout

\begin_layout Standard
kohtadesse kus operaatori syntaxis oli vahekoht argumendi jaoks on tühjad
 sulud.
 juhul kui see predikaat on jutumärkides on tühjade sulgude asemel argumendikoht
ades kahekordsd jutumärid.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Sama predikaat võib samas väite lähtekoodis nii operaatori kui funktsioonisyntax
is tähistatud olla.
 Kui predikaadi nimi sisaldab sulge peab see predikaat olema jutumärkide
 sees.
 jutumärgid predikaadi nime alguses lõpus või argumendi kohtade kõrval tähistada
 tagurpidi kaldkriipsuga(nagu pythoni syntaxis.).
\end_layout

\begin_layout Standard
Kõik mis pole loogikatehted, sulud ega kvantorid tõlgendada predikaatidena(2
 argumendilise puhul nagu operaatori syntax.).
 
\end_layout

\begin_layout Standard
Kõik 16(10) funktsiooni 2 booleanist ühte booleani sisseehitatud operaatoritena
 või olemas mingi funktsionaalselt täielik hulk neid ja kasutaja saab ise
 ülejäänud defineerida.
 Samuti oleks siis 1 kvantor a kasutaja ise saaaks teis defineerida.
\end_layout

\begin_layout Standard
peale iga võitust uus rida.
\end_layout

\begin_layout Standard
Peale iga kvantorit taane.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
kui predikaat sisaldab mingit sümbolit, millel on ka muu tähendus, siis
 on see kas keelatud või tuleb tagurpidi kaldkriipuga tähistada.
\end_layout

\begin_layout Standard
Küsimärkidel eraldi tähendus.
 Kahekordse kriipsuga järeldusmärkidlja ekvivalentsusmärkidel eraldi tähendus.
 {} optimeerimis tingimused.
\end_layout

\begin_layout Standard
Eraldi funktsooni sees saab sisestada käske.
\end_layout

\begin_layout Subsection
syntaxsugar
\end_layout

\begin_layout Standard
Eraldi võimalik märkida alad kus kehtib mingi syntaxsugar nt.
 
\backslash
sugar(
\begin_inset Quotes eld
\end_inset

boolean
\begin_inset Quotes erd
\end_inset

){},
\end_layout

\begin_layout Subsubsection
kvanteeritavate-nimede sugar
\begin_inset CommandInset label
LatexCommand label
name "subsec:kvanteeritavate-nimede-sugar"

\end_inset


\end_layout

\begin_layout Standard
Kui kvantori alaindeksiks pole kvanteeritava nime kirjutatud, siis eeldatakse,
 et selle kvantori kvanteeritava nimi on 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_{k+1}$
\end_layout

\end_inset

 kus 
\begin_inset ERT
status open

\begin_layout Plain Layout

$k$
\end_layout

\end_inset

 näitab, et mitme kvantori sees antud kvantor on.
 Et seda süntax-sugarit kasutavas notatsioonis kirjeldatud seost seda süntax-sug
arit mitte kasutavasse notatsiooni ümber kirjutatada tuleb kvantoritele
 kvanteeritavate nimed (alaindeksitena) juurde kirjutada.
\end_layout

\begin_layout Standard
Näiteks järgnevas valemis, kus pole kvanteeritavate nimesi kirjutatud:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
exists(
\backslash
exists(A(x_1,x_2,x_3,x_2))))
\backslash
land 
\backslash
exists(
\backslash
exists(
\backslash
forall(
\backslash
exists(A(x_1,x_2,x_3,x_4)) 
\backslash
to 
\backslash
exists( 
\backslash
neg A(x_1,x_1,x_3,x_4) ))))
\backslash
land 
\backslash
neg 
\backslash
forall(
\backslash
neg A(x_1,x_1,x_1,x_1))$
\end_layout

\end_inset

 eeldatakse need olema: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(
\backslash
exists_{x_2}(
\backslash
exists_{x_3}(A(x_1,x_2,x_3,x_2))))
\backslash
land 
\backslash
exists_{x_1}(
\backslash
exists_{x_2}(
\backslash
forall_{x_3}(
\backslash
exists_{x_4}(A(x_1,x_2,x_3,x_4)) 
\backslash
to 
\backslash
exists_{x_4}( 
\backslash
neg A(x_1,x_1,x_3,x_4) ))))
\backslash
land 
\backslash
neg 
\backslash
forall_{x_1}(
\backslash
neg A(x_1,x_1,x_1,x_1))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Võib küll tekkida mitmeid samanimelisi kvanteeritavaid(ehkmkvantori fiktiivmuutu
jaid), aga need ei saa mitte kunagi samas kohas valemis kasutusel olla.
 Juhul kui tahetakse vabaneda ka olukorrast, kus on mitu samanimelist kvanteerit
avat võib kõigi kvanteeritavate nimedele lisada punkti ja peale seda arvu,
 mis näitab, et mitu samanimelise kvanteeritavaga kvantorit sellest kvantorist
 vasakul pool asub.
 Näiteks toodud väite puhul:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_{1.0}}(
\backslash
exists_{x_{2.0}}(
\backslash
exists_{x_{3.0}}(A(x_{1.0},x_{2.0},x_{3.0},x_{2.0}))))
\backslash
land 
\backslash
exists_{x_{1.1}}(
\backslash
exists_{x_{2.1}}(
\backslash
forall_{x_{3.1}}(
\backslash
exists_{x_{4.0}}(A(x_{1.1},x_{2.1},x_{3.1},x_{4.0})) 
\backslash
to 
\backslash
exists_{x_{4.1}}( 
\backslash
neg A(x_{1.1},x_{1.1},x_{3.1},x_{4.0}) ))))
\backslash
land 
\backslash
neg 
\backslash
forall_{x_{1.2}}(
\backslash
neg A(x_{1.2},x_{1.2},x_{1.2},x_{1.2}))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sellises süntaks-sugariga saab kirjeldada kõiki väiteid, mida ilma selle
 sütax-sugaritagi saab kirjeldada.
 Et seda süntax-sugarit mitte kasutavas notatsioonis kirjeldatud seost seda
 süntax-sugarit kasutavasse notatsiooni ümber kirjutatada tuleb kõigepealt
 muuta kvanteeritavate nimed eespool kirjeldatudeks ja seejärel eemaldada
 kvanteeritavate nimed kvantorite juurest (alaindeksitena).
\end_layout

\begin_layout Standard
Näiteks järgnev valem:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_a(
\backslash
neg A(a,a) 
\backslash
land 
\backslash
exists_b(A(a,b) 
\backslash
land 
\backslash
neg A(b,a) 
\backslash
land 
\backslash
neg A(b,b) 
\backslash
land 
\backslash
exists_c(
\backslash
neg A(a,c) 
\backslash
land A(b,c) 
\backslash
land 
\backslash
neg A(c,a) 
\backslash
land 
\backslash
neg A(c,b) 
\backslash
land 
\backslash
neg A(c,c)) 
\backslash
land 
\backslash
exists_d(
\backslash
neg A(a, d) 
\backslash
land A(b,d) 
\backslash
land 
\backslash
neg A(d,a) 
\backslash
land 
\backslash
neg A(d,b) 
\backslash
land A(d,d)))) 
\backslash
land 
\backslash
neg 
\backslash
exists_e(
\backslash
neg A(e,e) 
\backslash
land 
\backslash
exists_f(
\backslash
neg A(e,f) 
\backslash
land A(f,e) 
\backslash
land 
\backslash
neg A(f,f) 
\backslash
land 
\backslash
exists_g(A(e, g) 
\backslash
land 
\backslash
neg A(f,g) 
\backslash
land 
\backslash
neg A(g,e) 
\backslash
land 
\backslash
neg A(g,f) 
\backslash
land 
\backslash
neg A(g,g)) 
\backslash
land 
\backslash
exists_h(A(e,h) 
\backslash
land 
\backslash
neg A(f,h) 
\backslash
land 
\backslash
neg A(h,e) 
\backslash
land 
\backslash
neg A(h,f) 
\backslash
land A(h,h))))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
selle syntax-sugariga kirjeldatuna on:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
neg A(x_1, x_1) 
\backslash
land 
\backslash
exists(A(x_1, x_2) 
\backslash
land 
\backslash
neg A(x_2, x_1) 
\backslash
land 
\backslash
neg A(x_2, x_2) 
\backslash
land 
\backslash
exists(
\backslash
neg A(x_1, x_3) 
\backslash
land A(x_2, x_3) 
\backslash
land 
\backslash
neg A(x_3, x_1) 
\backslash
land 
\backslash
neg A(x_3, x_2) 
\backslash
land 
\backslash
neg A(x_3, x_3)) 
\backslash
land 
\backslash
exists(
\backslash
neg A(x_1, x_3) 
\backslash
land A(x_2, x_3) 
\backslash
land 
\backslash
neg A(x_3, x_1) 
\backslash
land 
\backslash
neg A(x_3, x_2) 
\backslash
land A(x_3, x_3)))) 
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
neg A(x_1, x_1) 
\backslash
land 
\backslash
exists(
\backslash
neg A(x_1, x_2) 
\backslash
land A(x_2, x_1) 
\backslash
land 
\backslash
neg A(x_2, x_2) 
\backslash
land 
\backslash
exists(A(x_1, x_3) 
\backslash
land 
\backslash
neg A(x_2, x_3) 
\backslash
land 
\backslash
neg A(x_3, x_1) 
\backslash
land 
\backslash
neg A(x_3, x_2) 
\backslash
land 
\backslash
neg A(x_3, x_3)) 
\backslash
land 
\backslash
exists(A(x_1, x_3) 
\backslash
land 
\backslash
neg A(x_2, x_3) 
\backslash
land 
\backslash
neg A(x_3, x_1) 
\backslash
land 
\backslash
neg A(x_3, x_2) 
\backslash
land A(x_3, x_3))))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
või alternatiivselt:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
neg A(1, 1) 
\backslash
land 
\backslash
exists(A(1, 2) 
\backslash
land 
\backslash
neg A(2, 1) 
\backslash
land 
\backslash
neg A(2, 2) 
\backslash
land 
\backslash
exists(
\backslash
neg A(1, 3) 
\backslash
land A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land 
\backslash
neg A(3, 3)) 
\backslash
land 
\backslash
exists(
\backslash
neg A(1, 3) 
\backslash
land A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land A(3, 3)))) 
\backslash
land 
\backslash
neg 
\backslash
exists(
\backslash
neg A(1, 1) 
\backslash
land 
\backslash
exists(
\backslash
neg A(1, 2) 
\backslash
land A(2, 1) 
\backslash
land 
\backslash
neg A(2, 2) 
\backslash
land 
\backslash
exists(A(1, 3) 
\backslash
land 
\backslash
neg A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land 
\backslash
neg A(3, 3)) 
\backslash
land 
\backslash
exists(A(1, 3) 
\backslash
land 
\backslash
neg A(2, 3) 
\backslash
land 
\backslash
neg A(3, 1) 
\backslash
land 
\backslash
neg A(3, 2) 
\backslash
land A(3, 3))))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
boolean sugar
\end_layout

\begin_layout Standard
väiteid saab panna predikaadi argumendiks.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$A(
\backslash
forall(...))$
\end_layout

\end_inset

 asemel 
\begin_inset ERT
status open

\begin_layout Plain Layout

$boolean(x)
\backslash
land (toene(x) 
\backslash
iff 
\backslash
forall(...)) 
\backslash
land A(x)$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
operaatorite (järjekorraga) sugar
\begin_inset CommandInset label
LatexCommand label
name "subsec:operaatorite-(järjekorraga)-sugar"

\end_inset


\end_layout

\begin_layout Enumerate
kuni valemis operaatoreid on:
\end_layout

\begin_layout Enumerate
: : paneb operaatoritega valemi ümber universaalsuskvantori nt.
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_{11}+x_{12}*x_{13}=x_{14}$
\end_layout

\end_inset

 peale seda sammu: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(x_{11}+x_{12}*x_{13}=x_{14})$
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
: : jaatab olemasolevale väite uus kvanteeritav on võrdne kõige esimesena
 tehtava operatsiooni tulemusega.
 näteks 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(x_{11}+x_{12}*x_{13}=x_{14})$
\end_layout

\end_inset

 peale seda sammu on: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(*(x_{12},x_{13},x_{15}) 
\backslash
land x_{11}+x_{12}*x_{13}=x_{14})$
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
: : asendab kõige esimesena tehtava operatsiooni uue kvanteeritavaga, et
 selle tehte tulemus on võrdne uue kvanteeritavaga.
 nt.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(*(x_{12},x_{13},x_{15}) 
\backslash
land x_{11}+x_{12}*x_{13}=x_{14})$
\end_layout

\end_inset

 peale seda sammu: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(*(x_{12},x_{13},x_{15}) 
\backslash
land x_{11}+x_{15}=x_{14})$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
näited:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$+(x_1,x_2,x_3)$
\end_layout

\end_inset

 tähendab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1+x_2=x_3$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$*(x_1,x_2,x_3)$
\end_layout

\end_inset

 tähendab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1*x_2=x_3$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$CALL(x_1,...,x_n)$
\end_layout

\end_inset

 tähendab, et funktsioon 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1$
\end_layout

\end_inset

 argumentidega ...
 tagastab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_n$
\end_layout

\end_inset

'i.
\end_layout

\begin_layout Standard
operaatorite järjekord: **,[*,/],[+,-]
\end_layout

\begin_layout Subparagraph
näide
\end_layout

\begin_layout Standard
näiteks teisendab 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(
\backslash
exists(
\backslash
exists(x_1*x_2+x_3=f(x_3,x_2,x_1,x_2))))$
\end_layout

\end_inset

 järgenvaks:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$*(x_1,x_2,x_4) 
\backslash
land +(x_4,x_3,x_5) 
\backslash
land on
\backslash
_f(x_6) 
\backslash
land CALL(x_6,x_3,x_2,x_1,x_2,x_7)$
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
näide
\end_layout

\begin_layout Standard
näiteks teisendab valemi:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_null(x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(x_1=x_1)
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(x_1=x_2
\backslash
land x_2=x_3 
\backslash
to x_3=x_1)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(on
\backslash
_naturaalarv(x_1)
\backslash
land x_1=x_2 
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(on
\backslash
_naturaalarv(x_1)
\backslash
land S(x_1,x_2)
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(=(x_1,x_2) 
\backslash
land S(x_1,x_3) 
\backslash
land S(x_2,x_4) 
\backslash
leftrightarrow =(x_3,x_4))) 
\backslash
land 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
to 
\backslash
neg 
\backslash
exists( S(x_2,x_1)
\backslash
land on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
exists(on
\backslash
_null(x_1) 
\backslash
land x_1 
\backslash
in K)
\backslash
land 
\backslash
forall(
\backslash
forall(x_1 
\backslash
in K 
\backslash
land S(x_1,x_2) 
\backslash
to x_2 
\backslash
in K)) 
\backslash
to 
\backslash
forall(x_1 
\backslash
in K)%edasi liitmise definitsioon
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2+x_1=x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1+S(x_2)=S(x_1+x_2)
\end_layout

\begin_layout Plain Layout

))%edasi korrutamise definitsioon
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2*x_1=x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1*S(x_2)=x_1+x_1*x_2
\end_layout

\begin_layout Plain Layout

))
\end_layout

\begin_layout Plain Layout

$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
kujule:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_null(x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(=(x_1,x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(=(x_1,x_2)
\backslash
land =(x_2,x_3)
\backslash
to =(x_3,x_1))))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(on
\backslash
_naturaalarv(x_1)
\backslash
land =(x_1,x_2)
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(on
\backslash
_naturaalarv(x_1)
\backslash
land S(x_1,x_2)
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(x_1=x_2 
\backslash
leftrightarrow S(x_1)=S(x_2))) 
\backslash
land 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
to 
\backslash
neg 
\backslash
exists( S(x_2,x_1)
\backslash
land on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
exists(on
\backslash
_null(x_1) 
\backslash
land x_1 
\backslash
in K)
\backslash
land 
\backslash
forall(
\backslash
forall(x_1 
\backslash
in K 
\backslash
land S(x_1,x_2) 
\backslash
to x_2 
\backslash
in K)) 
\backslash
to 
\backslash
forall(x_1 
\backslash
in K)
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(+(x_2,x_1,x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

S(x_2,x_3) 
\backslash
land +(x_1,x_2,x_4) 
\backslash
land S(x_4,x_5) 
\backslash
land +(x_1,x_3,x_6) 
\backslash
leftrightarrow =(x_6,x_5)
\end_layout

\begin_layout Plain Layout

))))))
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(*(x_2,x_1,x_1)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

S(x_2,x_3) 
\backslash
land *(x_1,x_2,x_4) 
\backslash
land +(x_1,x_4,x_5) 
\backslash
land  
\backslash
leftrightarrow =(x_6,x_5)
\end_layout

\begin_layout Plain Layout

))))))
\end_layout

\begin_layout Plain Layout

$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
transistiivsete operaatorite sug ar
\end_layout

\begin_layout Standard
et
\begin_inset ERT
status open

\begin_layout Plain Layout

$a=b=c$
\end_layout

\end_inset

tähendab
\begin_inset ERT
status open

\begin_layout Plain Layout

$a=b 
\backslash
land b=c$
\end_layout

\end_inset

 nt.
 operaatorite rakendamise järjekord.
 syntax nt 
\backslash
enable_syntaxsugar(kommunitiivsed_võdusmärgid)
\end_layout

\begin_layout Standard
.
\end_layout

\begin_layout Subsubsection
kantsulgude sugar
\end_layout

\begin_layout Standard
Kantsulgudel sulgudel selline tähendus, et 
\begin_inset ERT
status open

\begin_layout Plain Layout

$[a OP1 b OP1 c OP1 d] OP2 e = (a OP2 e) OP1 (b OP2 e) OP1 (c OP2 e) OP1
 (d OP2 e)$
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
predikaatide overloading
\end_layout

\begin_layout Standard
võib olla mitu sama nime, aga erineva argumentide arvuga, predikaati.
 kui argumentide arv on erinev, aga siis on tegemist erinevate predikaatidega
 - sellel et nimi on sama pole mingit tähtsust.
\end_layout

\begin_layout Subsubsection
väited predikaatide argumentidena
\end_layout

\begin_layout Standard
Elementaarseoste argumentideks saavad olla väited kui eelenvalt on defineeritud
 True ja False.
 Et nende tähendus olks sama, mis intuitiivne tähendus peab lisama ka nendega
 seotud väited 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(("onTrue"(x_1)
\backslash
land "onTrue"(x_2)
\backslash
to "="(x_1,x_2)) 
\backslash
land ("onTrue"(x_1)
\backslash
land "onFalse"(x_2)
\backslash
to 
\backslash
neg "="(x_1,x_2))))$
\end_layout

\end_inset

.
 Elementeersesos(väide) tähendab: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(väide 
\backslash
to 
\backslash
exists("onTrue(x_1) 
\backslash
land "elementaatseos"(x_1)) 
\backslash
land (
\backslash
neg väide 
\backslash
to 
\backslash
exists("onFalse"(x_1) 
\backslash
land "elementaatseos"(x_1)))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
importimine
\end_layout

\begin_layout Standard

\backslash
uri
\begin_inset Quotes erd
\end_inset

...
\begin_inset Quotes erd
\end_inset

 on uril ...
 olev väide.
\end_layout

\begin_layout Standard

\backslash
standarlibari
\begin_inset Quotes erd
\end_inset

...
\begin_inset Quotes erd
\end_inset

 on stadardses kohas kus palju kasulikke väiteid on olev väide.
\end_layout

\begin_layout Standard
imporditud väidetel on võivad olla viimased sulud puudu, sest need ütleva,
 et midagi eksisteerib, aga lasevad kasutajal sama kvantori (mille lähtekood
 on teises failis) väiteid juurde kirjutada.
\begin_inset Newline newline
\end_inset

Moodulid on eelnevalt 
\begin_inset Quotes eld
\end_inset

kompileeritud
\begin_inset Quotes eld
\end_inset

.
 Imortimisel nende väitenumbrit muudetakse nii , et see sobiks kokku ülejäänud
 predikaatide ja K'ga.
 Nii on efektiivsus suurem.
 Moodulite lähtekood ei pea kõigi moodulite puhul avalik olema.
\end_layout

\begin_layout Subsection
näiteid selles syntaxis definitsioonides
\end_layout

\begin_layout Subsubsection
piirväärtuse definitsioon
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$(lim_{x
\backslash
to a}(f(x))=A) 
\backslash
leftrightarrow 
\backslash
forall_{
\backslash
epsilon}(
\backslash
epsilon>0 
\backslash
to 
\backslash
exists_{
\backslash
delta}(
\backslash
delta>0 
\backslash
land 
\backslash
forall_x(((|x-a|<
\backslash
delta)
\backslash
land(|x-a|
\backslash
not =0))
\backslash
to|f(x)-A|<
\backslash
epsilon)))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Iga kauguse 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
epsilon$
\end_layout

\end_inset

 funktsiooni piiväärtusest kohal 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a$
\end_layout

\end_inset

, kohta leidub kaugus 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
delta$
\end_layout

\end_inset

 kohast 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a$
\end_layout

\end_inset

 nii, et iga koht 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x$
\end_layout

\end_inset

, mis on 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a$
\end_layout

\end_inset

'le lähemal kui 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
delta$
\end_layout

\end_inset

, aga mitte kohas 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a$
\end_layout

\end_inset

, korral on funktsioon kohal 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x$
\end_layout

\end_inset

 lähemal 
\begin_inset ERT
status open

\begin_layout Plain Layout

$A$
\end_layout

\end_inset

'le kui 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
epsilon$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
ehk: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(lim_{x
\backslash
to a}(f(x))=A) 
\backslash
leftrightarrow 
\backslash
forall_{x_1}(x_1>0 
\backslash
to 
\backslash
exists_{x_2}(x_2>0 
\backslash
land 
\backslash
forall_{x_3}(((|x_3-a|<x_2)
\backslash
land(|x_3-a|
\backslash
not =0))
\backslash
to|f(x_3)-A|<x_1)))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
peano aksioomid
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(on
\backslash
_null(x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{x_1}(=(x_1,x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{x_1}(
\backslash
forall_{x_2}(
\backslash
forall(=(x_1,x_2)
\backslash
land =(x_2,x_3)
\backslash
to =(x_3,x_1))))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{x_1}(
\backslash
forall_{x_2}(on
\backslash
_naturaalarv(x_1)
\backslash
land =(x_1,x_2)
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{x_1}(
\backslash
forall_{x_2}(on
\backslash
_naturaalarv(x_1)
\backslash
land S(x_1,x_2)
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{x_1}(on
\backslash
_null(x_1)
\backslash
to 
\backslash
neg 
\backslash
exists_{x_2}( S(x_2,x_1)
\backslash
land on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_K(
\backslash
exists_{x_1}(on
\backslash
_null(x_1) 
\backslash
land x_1 
\backslash
in K)
\backslash
land 
\backslash
forall_{x_1}(
\backslash
forall_{x_2}(x_1 
\backslash
in K 
\backslash
land S(x_1,x_2) 
\backslash
to x_2 
\backslash
in K)) 
\backslash
to 
\backslash
forall_{x_1}(x_1 
\backslash
in K))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
7.
 aksioom ilma väiteta, et kõik naturaalarvude alamhulgad eksisteerivad on
 kasutu.
\end_layout

\begin_layout Part
standard libary
\end_layout

\begin_layout Standard
seal on igasugu kasulikke väiteid, mida kasutaja saab enda omadega jaatada,
 et enda omade tõesust kontrollida.
\end_layout

\begin_layout Paragraph
robinsoni aritmeetika
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_null(x_1) 
\backslash
neg 
\backslash
exists(S(x_1,x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\backslash
forall(
\backslash
forall( x_1=x_2 
\backslash
land S(x_1,x_3)
\backslash
land S(x_2,x_4) 
\backslash
to x_3=x_4))))
\end_layout

\begin_layout Plain Layout

on
\backslash
_null(x_1)
\backslash
lor 
\backslash
exists(S(x_2,x_1))
\end_layout

\begin_layout Plain Layout

%edasi liitmise definitsioon
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2+x_1=x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1+S(x_2)=S(x_1+x_2)
\end_layout

\begin_layout Plain Layout

))%edasi korrutamise definitsioon
\end_layout

\begin_layout Plain Layout


\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2*x_1=x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1*S(x_2)=x_1+x_1*x_2
\end_layout

\begin_layout Plain Layout

))
\end_layout

\begin_layout Plain Layout

$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
astendamine
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_null(x_1)
\backslash
land 
\backslash
forall(x_2^{x_1}=S(x_1)))$
\end_layout

\end_inset

iga arv astmes 0 on 1.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(
\end_layout

\begin_layout Plain Layout

x_1^{S(x_2)}=x_1^{x_2}*x_1
\end_layout

\begin_layout Plain Layout

))$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
lahutamine
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(
\backslash
forall(x_1-x_2=x_3 
\backslash
leftrightarrow x_2+x_3=x_1)))$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
jagamine
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(
\backslash
forall(x_1/x_2=x_3 
\backslash
leftrightarrow x_2*x_3=x_1)))$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
peano viimane naturaalarvude hulga võimsuse aksioom
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists(on
\backslash
_null(x_1) 
\backslash
land x_1 
\backslash
in K)
\backslash
land 
\backslash
forall(
\backslash
forall(x_1 
\backslash
in K 
\backslash
land S(x_1,x_2) 
\backslash
to x_2 
\backslash
in K)) 
\backslash
to 
\backslash
forall(x_1 
\backslash
in K)$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
kõik naturaalarvud on reaalarvud
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_reaalarv(x_1)
\backslash
to on
\backslash
_naturaalarv(x_1))$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
reaalarvude võrdlemine
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(
\backslash
forall(x_1>x_2 
\backslash
leftrightarrow 
\backslash
exists( on
\backslash
_naturaalarv(x_3) 
\backslash
land x_1*x_3>x_2*x_3)))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
reaalarvude pid
\end_layout

\begin_layout Paragraph
täisarvu definitsioon
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_täisarv(x_1)
\backslash
leftrightarrow 
\backslash
exists(on
\backslash
_naturaalarv(x_2)
\backslash
land on
\backslash
_naturaalarv(x_1+x_2)))$
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
ratsionaalarvu definitsioon
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall(on
\backslash
_ratsionaalarv(x_1)
\backslash
leftrightarrow 
\backslash
exists(on
\backslash
_naturaalarv(x_2)
\backslash
land on
\backslash
_täisarv(x_1*x_2)))$
\end_layout

\end_inset


\end_layout

\end_body
\end_document
