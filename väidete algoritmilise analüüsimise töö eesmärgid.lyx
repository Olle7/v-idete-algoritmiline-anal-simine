#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
väidete algoritmilise analüüsimise töö eesmärgid
\end_layout

\begin_layout Author
Olger Männik
\end_layout

\begin_layout Part
Sissejuhatus
\end_layout

\begin_layout Paragraph
DEFINITSIOON:
\end_layout

\begin_layout Standard
Selles failis on kirjeldatud ainult töö eesmärgid.
 Mul on teine pikem fail, kus on eesmärkide saavutamist alustatud ja sellega
 üsna kaugele jõutud.
\end_layout

\begin_layout Standard

\color yellow
(võibolla on ka üldisem definitsioon kus kvantorid asendatakse, millegagi,
 mis tagsatavad midagi muud kui booleane)
\end_layout

\begin_layout Standard
Sõna väide on siin töös tavalakeelses tähenduses, ehk see on miski, mille
 tõele vastamisest järeldub mingi tõsiasi.
 Siin töös kasutan ühte kindlaid syntaxeid väidete kirja panemiseks.
 Selles syntaxis tohivad väited sisaldada booleanalgebra, kvantoreid ja
 predikaate(või elementaarseoseid või algasju predikaatide asemel).
\end_layout

\begin_layout Paragraph
eesmärgid
\end_layout

\begin_layout Standard
Töö eesmärk on koostada algoritm ja implementeerida see arvutiprogrammina,
 mille abil saaks väiteid minimaalsel vabadusastmel salvestada.
 Minimaalsel vabadusastmel salvestatud väiteid saaks kergesti analüüsida.
 Kui minimaalsel vabadusastmel salvaestamine on liiga raskesti implementeeritav,
 liiga keerukas või liiga palju mälu nõudev, siis võib selle asemel teha
 algoritmi, mis väiteid analüüsib ilma neid minimaalsel vabadusastmel salvestama
ta.
 Kasutaja sisestaks väited kergesti loetavas syntaxis.
 Seda saaks kasutada näiteks kõige üldisemate matemaatiliste probeemide
 (mis võivad olla võrranditena esitatud) lihtsustamiseks, lahendamiseks
 ja lahendite kontrollimiseks.
\end_layout

\begin_layout Standard
Kuna iga väide on salvestatud minimaalsel vabadusastmel, siis saab lihtsasti
 kontrollida, et kas see on üheselt vale, üheselt tõene või mitte kumbagi,
 sest kõigile üheselt valedele ja üheselt tõestele väidetele vastab sama
 arv.
 Tõenäoliselt ongi praktilisel kasutamisel kõige olulisem küsimus, et kas
 väide vormis 
\begin_inset ERT
status open

\begin_layout Plain Layout

$aksioomid 
\backslash
to väide$
\end_layout

\end_inset

 on üheselt vale üheselt õige või mitte kumbagi (
\begin_inset ERT
status open

\begin_layout Plain Layout

$programm(aksioomid 
\backslash
to väide)$
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Kui sellise programmi tegemine pole Gödeli teoreemi kohaselt võimalik, siis
 teha programm mis seni kuni kasutaja stopp paneb kontrollimist jätkab ja
 järjest täpsemaks läheb.
 arv 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

 peab siis sisaldama infot, et kui palju on selle poolt kirjeldatud väidet
 lihtsustatud.
 Võimalik et ei saa ka kunagi kindel olla kas antud väide on üheselt vale,
 üheselt tõene või mitte kumbagi.
 Kuigi Gödeli teoreemi kohaselt pole võimalik kogu täisarvude matemaatika
 aksiomaatiliselt kirjeldada(???) saab arvutile etteantavasse väideesse
 alati uusi aksioome juurde lisada ja tõestada, et teatud arvust 
\begin_inset ERT
status open

\begin_layout Plain Layout

$K_{max}$
\end_layout

\end_inset

 väiksemate K parameetritega väidete abil kirjeldatavad aksioomid on lisatud.
 Kasutaja ei peaks iga kord uuesti kõiki (näiteks reaalarvude kohta käivaid)
 aksioome sisestama, vaid saaks need moodulina 
\begin_inset Quotes eld
\end_inset

importida
\begin_inset Quotes erd
\end_inset

(
\begin_inset Quotes eld
\end_inset

includida
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
Hea oleks käsitleda minimaalsel vabadusastmel kirjeldatud väiteid naturaalarvude
na.
 Tähistame naturaalarvu, mis kirjeldab väidet 
\begin_inset ERT
status open

\begin_layout Plain Layout

$S$
\end_layout

\end_inset

 tähisega 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

.
 Selleks tuleb defineerida injektiivne vastavus võimalike väidete(võimalik
 vist ainult kindlas notatsioonis olevate väidete korral) ja naturaalarvude
 vahele.
 On võimalik defineerida mitmeid sarnaseid vastavusi.
 Tähistame funktsiooni, mis seab väite 
\begin_inset ERT
status open

\begin_layout Plain Layout

$S$
\end_layout

\end_inset

 vastavusse naturaalarvuga 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

 F'iga.
 Seega 
\begin_inset ERT
status open

\begin_layout Plain Layout

$F(S)=n_S$
\end_layout

\end_inset

.
 Selle pöördfunktsiooni tähistan f'iga.
 Seega 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f(n_S)=S$
\end_layout

\end_inset

.
 Järgnevalt loetlen omadusi, mis vastavusel (ja funktsioonil F) võiks olla,
 et sellisel kujul olevat väidet praktikas mugav kasutada oleks:
\end_layout

\begin_layout Itemize
Hea on kui sellisel kujul estitatud väidete vahel saab rakendada sagedasti
 kasututatavaid operaatoreid(näiteks AND, NAND, OR, NOR ja XOR) rakendades
 neile vastavaid lihtsasti arvutatavaid funktsioone väidet kirjeldavale
 arvule 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Hea on kui tavalises notatsioonis lühidalt kirjapandav väide on ka väikese
 või lihtsasti kirjeldatava naturaalarvuga vastavusse pandud.
\end_layout

\begin_layout Itemize
Hea on kui võimalikud jäävad väärtused 0 ja mingi arvu vahele(mis muide
 on 
\begin_inset ERT
status open

\begin_layout Plain Layout

(max $n_S$ väärtus)
\end_layout

\end_inset

)(kui K pole määratud, siis ei ole 
\begin_inset ERT
status open

\begin_layout Plain Layout

$n_S$
\end_layout

\end_inset

 ülmist piiri) nii, et igale nende vahel olevale naturaalarvule vastab erinev
 väide.
 Seega on funktsioon F bijektiivne.
\end_layout

\begin_layout Itemize
Hea on kui Falsele(kõigile üheselt valedele väidetele) vastab 0.
\end_layout

\begin_layout Itemize
Hea on kui Truele(kõigile üheselt tõestele väidetele) vastab 1.
\end_layout

\begin_layout Section
Näited progemmi kasutamisest
\end_layout

\begin_layout Subsection
lihtsamad näited
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide on üheselt vale (lühendatult
 ÜV): 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(A(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1}(A(x_1))$
\end_layout

\end_inset

, sest on väidetud et miski, mis rahuldab predikaati A eksisteerib ning
 samuti on väidetud, et seda ei eksisteeri.
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide pole üheselt vale: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(A(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1}(A(x_1)
\backslash
land B(x_1))$
\end_layout

\end_inset

, sest on väidetud et eksisteerib miski, mis rahuldab predikaati A aga,
 ei eksisteeri midagi, mis rahuldaks nii predikaate A kui B.
 Vastuolu ei ole.
 Sellest on lihtsam aru saada kui panna predikaatidele mingit intuitiivselt
 lihtsamini mõistetavamad nimed.
 nt.: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(on
\backslash
_loom(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1}(on
\backslash
_loom(x_1)
\backslash
land on
\backslash
_auto(x_1))$
\end_layout

\end_inset

.
 Ehk on väidetud, et eksisteerib mingi asi, mis on loom(eksisteerib mingi
 loom), aga ei eksisteeri midagi, mis oleks nii loom kui auto.
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide on üheselt vale: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(A(x_1)
\backslash
land B(x_1))
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1}(A(x_1))$
\end_layout

\end_inset

, sest on väidetud, et eksisteerib miski, mis rahuldab nii predikaati A
 kui ka predikaati B, aga ei eksisteeri midagi, mis rahuldaks predikaati
 A.
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide on üheselt vale: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(
\backslash
exists_{x_2}(A(x_1,x_2)
\backslash
land 
\backslash
exists_{x_3}(A(x_2,x_3)
\backslash
land A(x_2,x_2))))
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1}(
\backslash
exists_{x_2}(
\backslash
exists_{x_3}( A(x_2,x_1)
\backslash
land A(x_1,x_3)
\backslash
land A(x_1,x_1))))$
\end_layout

\end_inset

,sest on väidetud, et eksisteerib miski (
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_2$
\end_layout

\end_inset

), mis rahuldab millegagi predikaati A olles ise 2.
 argument, rahuldab millegi muuga predikaati A, olles ise 1.
 argument ja rahuldab predikaati A olles selle mõlemaks argumendiks ning
 väite teises osas on väidetud, et selliste omadustega asja just ei eksisteeri.
\end_layout

\begin_layout Standard
Eelnevalt näiteks toodud väidete vastuolulisust on kerge intuitiivselt(ilma
 algoritmita) ilma arvuti abita kontrollida, aga pikkade ja keerukate väidete
 vastuolulisust on niimoodi väga raske kontrollida.
 Siis ongi mu programm kasulik.
 Järgnevalt toon mõned näited keerukamatest väidetest, mille vastuolulisust
 on raske kontrollida:
\end_layout

\begin_layout Itemize
järgneva väite korral programm tagastab, et väide ei ole üheselt vale: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(on
\backslash
_mari(x_1) 
\backslash
land  
\backslash
neg
\backslash
exists_{x_2}(M(x_1, x_2) 
\backslash
land  
\backslash
exists_{x_3}(M(x_1, x_3) 
\backslash
land  
\backslash
neg M(x_2, x_3) 
\backslash
land  M(x_3, x_1)) 
\backslash
land  
\backslash
exists_{x_3}(M(x_1, x_3) 
\backslash
land  M(x_2, x_3)) 
\backslash
land  
\backslash
neg 
\backslash
exists_{x_3}(M(x_2, x_3) 
\backslash
land  M(x_3, x_3))))
\backslash
land             
\backslash
exists_{x_1}(
\backslash
exists_{x_2}(on
\backslash
_mari(x_2)
\backslash
land M(x_2,x_1)
\backslash
land 
\backslash
exists_{x_3}(M(x_1,x_3)
\backslash
land M(x_2,x_3))
\backslash
land 
\backslash
exists_{x_3}(M(x_2,x_3)
\backslash
land M(x_3,x_2)
\backslash
land 
\backslash
neg M(x_1,x_3)))
\backslash
land 
\backslash
neg 
\backslash
exists_{x_2}(M(x_2,x_1)
\backslash
land M(x_2,x_2)))
\backslash
lor
\backslash
exists_{x_1}(M(x_1,x_1)
\backslash
land 
\backslash
neg 
\backslash
exists_{x_2}(M(x_1,x_2)
\backslash
land M(x_2,x_2)
\backslash
land M(x_2,x_1)))$
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Sellest, et vastuolu pole, on lihtsam aru saada kui panna predikaatidele
 intuitiivselt lihtsamini mõistetavamad nimed.
 nt.:predikaat M on 
\begin_inset Quotes eld
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1$
\end_layout

\end_inset

'le meeldib 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_2$
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, ehk kui 
\begin_inset ERT
status open

\begin_layout Plain Layout

$M(x_1,x_2)$
\end_layout

\end_inset

, siis 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_1$
\end_layout

\end_inset

 meeldib 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x_2$
\end_layout

\end_inset

'le.
 Siis on väidetud , et: [kõigil, kes Marile meeldivad,[ei ole kedagi kes
 Marile meeldiks, aga temale mitte ja kellele meeldiks Mari] või [ei ole
 kedagi, kes nii talle kui Marile meeldiks] või [on keegi, kes neile meeldib
 ja kes iseendale meeldib]] ja ja leidub keegi, kes meeldib marile, nii,
 et eksisteerib [keegi, kes meeldib nii marile kui talle] ja [keegi, kes
 meeldib marile, kellele mari meeldib ja kelle ei meeldi talle] ja ei leidu
 kedagi, kes nii iseendale kui ka talle ta meeldiks või [on keegi(x_1) kes
 endale meeldib, aga [kellel pole kedagi kes nii talle kui iseendale meeldiks
 ja kellele meeldiks tema(x_1)]].
\end_layout

\begin_layout Itemize
Sellise väite korral programm tagastab, et väide on üheselt vale:
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(A(x_1,x_1)
\backslash
land 
\backslash
exists_{x_2}(A(x_2,x_2) 
\backslash
land A(x_2,x_1) 
\backslash
land A(x_1,x_2)) 
\backslash
land 
\backslash
exists_{x_2}(
\backslash
neg A(x_2,x_2) 
\backslash
land 
\backslash
neg A(x_1,x_2) 
\backslash
land A(x_2,x_1) 
\backslash
land 
\backslash
neg 
\backslash
exists_{x_3}(
\backslash
neg A(x_3,x_3) 
\backslash
land 
\backslash
neg A(x_3,x_2) 
\backslash
land A(x_3,x_1) 
\backslash
land A(x_2,x_3) 
\backslash
land A(x_1,x_3))))
\backslash
land
\end_layout

\begin_layout Plain Layout


\backslash
neg 
\backslash
exists_{x_1}(
\backslash
exists_{x_2}(
\backslash
exists_{x_3}(
\backslash
neg A(x_1,x_1)
\backslash
land 
\backslash
neg A(x_1,x_2)
\backslash
land 
\backslash
neg A(x_2,x_1)
\backslash
land 
\backslash
neg A(x_2,x_2)
\backslash
land 
\backslash
neg A(x_3,x_1)
\backslash
land 
\backslash
neg A(x_3,x_2)
\backslash
land 
\backslash
neg A(x_3,x_3)
\backslash
land 
\backslash
neg A(x_1,x_3)
\backslash
land 
\backslash
neg A(x_2,x_3)))
\backslash
lor A(x_1,x_1) 
\backslash
land 
\backslash
exists_{x_2}(A(x_2,x_2) 
\backslash
land 
\backslash
neg A(x_2,x_1) 
\backslash
land A(x_1,x_2) 
\backslash
neg 
\backslash
exists_{x_3}(
\backslash
neg A(x_3,x_3) 
\backslash
land A(x_3,x_2) 
\backslash
neg 
\backslash
land A(x_3,x_1) 
\backslash
land A(x_2,x_3) 
\backslash
land A(x_1,x_3)) ))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Siin on toodud mõned väited, mille üheselt valesust saaks minu programmiga
 kontrollida, aga mille vastuolulisuse kontrollimiseks on vaja kasutada
 matemaatiliste tehte märkide tähendusi kirjeldavaid väiteid ja arvude kohta
 käivaid aksioome.
 Programmi kasutaja ei peaks neid käsitsi sisestama vaid saaks need standard
 libarist võtta.
 Standard libariks olevat väidet tähistan siinkohal nimega STANDARD.
 Samuti on selleks vaja kasutada mõndasid syntax-sugareid.
\end_layout

\begin_layout Standard
mitte ÜV: 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists_{x_1}(x_1+3=7 
\backslash
land on
\backslash
_reaalarv(x_1))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1}(0*x_1=3 
\backslash
land on
\backslash
_reaalarv(x_1))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1}((on
\backslash
_naturaalarv(x_1) 
\backslash
to x_1>x_1) 
\backslash
lor x_1=x_1+1)$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists_{x_1}(on
\backslash
_reaalarv(x_1)
\backslash
land 
\backslash
exists_{x_2}(x_1+x_2=23
\backslash
land x_1+2*x_2=37 
\backslash
land x_1<53 
\backslash
land x_1*x_2<200 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1} (
\backslash
neg 
\backslash
exists_{x_2} (x_1>x_2 
\backslash
land on
\backslash
_reaalarv(x_1) 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

 ei leidu arvu, millest suuremat ei leiduks.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
neg 
\backslash
exists_{x_1} (
\backslash
exists_{x_2} (x_1>x_2
\backslash
land x_1<x_2 
\backslash
land on
\backslash
_reaalarv(x_1)  
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

ei leidu kahte arvu nii, et mõlemad oleksid teisest suuremad.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists_{x_1} (
\backslash
neg 
\backslash
exists_{x_2} (x_1*x_2 
\backslash
not = 0 
\backslash
land on
\backslash
_reaalarv(x_1) 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

Leidub arv(0), nii et ei leiduks arvu, millega seda korrutades ei saaks
 vastuseks nulli.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists_{x_1} (
\backslash
exists_{x_2} (x_1+x_2=9
\backslash
land x_1*x_2=20
\backslash
land x_1>x_2 
\backslash
land on
\backslash
_reaalarv(x_1) 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

 Need arvud on 5 ja 4.
\end_layout

\begin_layout Standard
ÜV:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists_{x_1}(
\backslash
exists_{x_2}(x_1^3-4*x_1^2+6*x_1-24-x_2^4+3*x_2=0 
\backslash
land x_2>1))$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$STANDARD 
\backslash
land 
\backslash
exists_{x_1}(on
\backslash
_reaalarv(x_1)
\backslash
land 
\backslash
neg 
\backslash
exists_{x_2}(x_1<x_2 
\backslash
land on
\backslash
_reaalarv(x_2)))$
\end_layout

\end_inset

, sest see väide ütleb, et eksiseerib selline reaalarv, nii et ei leidu
 ühtegi teist reaalarvu, mis sellest suurem oleks.
\end_layout

\begin_layout Standard
Saaks kontrollida ka, et kas mingi hüpotees(teoreem) järeldub aksioomidest(ehk
 standard libarist).
 Kui standard libaris on piisavalt palju infot, siis järgneva seose korral
 programm tagastab, et see seos on ÜV, ehk et see hüpotees oli tõene.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg (STANDARD 
\backslash
to 
\backslash
neg 
\backslash
exists_{x_1}(on
\backslash
_naturaalarv(x_1) 
\backslash
land 
\backslash
exists_{x_2}(on
\backslash
_naturaalarv(x_2) 
\backslash
land 
\backslash
exists_{x_3}( on
\backslash
_naturaalarv(x_3) 
\backslash
land 
\backslash
exists_{x_4}(x_1^{x_4}+x_2^{x_4}=x_3^{x_4} 
\backslash
land x_4>2 
\backslash
land on
\backslash
_naturaalarv(x_4))))))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Matemaatiliste mõistete vahelise väite kirjeldamine.
\end_layout

\begin_layout Subsection
algoritmi või arvutiprogrammi analüüsimiseks
\end_layout

\begin_layout Standard
igal pool asendada käsk x:=y väitega 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x(t+1)=y(t)$
\end_layout

\end_inset

, kus t on prgrammi samm.
\end_layout

\begin_layout Subsection
Füüsikalise mudeli kirjeldamiseks
\end_layout

\begin_layout Standard
Oluline on ka näidaya, et milliste erinevate väärtuste korral on süsteemid
 füüsikaliselt identsed.
 Näiteks ei ole oluline potentsiaali 0-nivoo ja koordinaatide alguspunkt.
\end_layout

\begin_layout Standard
Oluliseks pointiks nii tõenäosuste kui gemeetrilise ruumi(intuitiivsetst
 vektoritest) on, et intuitiivse tähendusega aja korrutis arvuga on samuti
 intuitiivne.
 See on vist kuidagi taustsüsteemiga seotud.
 taust spsteemi, mille algus on kohas 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
vec{a}$
\end_layout

\end_inset

 olev vektor 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
vec{b}$
\end_layout

\end_inset

 asub kohas 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
vec{a}+
\backslash
vec{b}$
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
näiteid selles syntaxis definitsioonides
\end_layout

\begin_layout Subsubsection
piirväärtuse definitsioon
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$(lim_{x
\backslash
to a}(f(x))=A) 
\backslash
leftrightarrow 
\backslash
forall_{
\backslash
epsilon}(
\backslash
epsilon>0 
\backslash
to 
\backslash
exists_{
\backslash
delta}(
\backslash
delta>0 
\backslash
land 
\backslash
forall_x(((|x-a|<
\backslash
delta)
\backslash
land(|x-a|
\backslash
not =0))
\backslash
to|f(x)-A|<
\backslash
epsilon)))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Iga kauguse 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
epsilon$
\end_layout

\end_inset

 funktsiooni piiväärtusest kohal 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a$
\end_layout

\end_inset

, kohta leidub kaugus 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
delta$
\end_layout

\end_inset

 kohast 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a$
\end_layout

\end_inset

 nii, et iga koht 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x$
\end_layout

\end_inset

, mis on 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a$
\end_layout

\end_inset

'le lähemal kui 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
delta$
\end_layout

\end_inset

, aga mitte kohas 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a$
\end_layout

\end_inset

, korral on funktsioon kohal 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x$
\end_layout

\end_inset

 lähemal 
\begin_inset ERT
status open

\begin_layout Plain Layout

$A$
\end_layout

\end_inset

'le kui 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
epsilon$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
ehk: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(lim_{x
\backslash
to a}(f(x))=A) 
\backslash
leftrightarrow 
\backslash
forall_{x_1}(x_1>0 
\backslash
to 
\backslash
exists_{x_2}(x_2>0 
\backslash
land 
\backslash
forall_{x_3}(((|x_3-a|<x_2)
\backslash
land(|x_3-a|
\backslash
not =0))
\backslash
to|f(x_3)-A|<x_1)))$
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
peano aksioomid
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
exists_{x_1}(on
\backslash
_null(x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{x_1}(=(x_1,x_1))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{x_1}(
\backslash
forall_{x_2}(
\backslash
forall(=(x_1,x_2)
\backslash
land =(x_2,x_3)
\backslash
to =(x_3,x_1))))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{x_1}(
\backslash
forall_{x_2}(on
\backslash
_naturaalarv(x_1)
\backslash
land =(x_1,x_2)
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{x_1}(
\backslash
forall_{x_2}(on
\backslash
_naturaalarv(x_1)
\backslash
land S(x_1,x_2)
\backslash
to on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_{x_1}(on
\backslash
_null(x_1)
\backslash
to 
\backslash
neg 
\backslash
exists_{x_2}( S(x_2,x_1)
\backslash
land on
\backslash
_naturaalarv(x_2)))
\backslash
land
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
forall_K(
\backslash
exists_{x_1}(on
\backslash
_null(x_1) 
\backslash
land x_1 
\backslash
in K)
\backslash
land 
\backslash
forall_{x_1}(
\backslash
forall_{x_2}(x_1 
\backslash
in K 
\backslash
land S(x_1,x_2) 
\backslash
to x_2 
\backslash
in K)) 
\backslash
to 
\backslash
forall_{x_1}(x_1 
\backslash
in K))$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
7.
 aksioom ilma väiteta, et kõik naturaalarvude alamhulgad eksisteerivad on
 kasutu.
\end_layout

\end_body
\end_document
